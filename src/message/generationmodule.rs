// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `generationmodule/generationmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationPoint {
    // message fields
    blackStartEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    reset: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    syncBackToGrid: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    transToIslndOnGridLossEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    startTime: ::protobuf::SingularPtrField<super::commonmodule::ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationPoint {
    fn default() -> &'a GenerationPoint {
        <GenerationPoint as ::protobuf::Message>::default_instance()
    }
}

impl GenerationPoint {
    pub fn new() -> GenerationPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC blackStartEnabled = 1;


    pub fn get_blackStartEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.blackStartEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackStartEnabled(&mut self) {
        self.blackStartEnabled.clear();
    }

    pub fn has_blackStartEnabled(&self) -> bool {
        self.blackStartEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackStartEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.blackStartEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackStartEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.blackStartEnabled.is_none() {
            self.blackStartEnabled.set_default();
        }
        self.blackStartEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackStartEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.blackStartEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 2;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 3;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 4;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 5;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC reset = 8;


    pub fn get_reset(&self) -> &super::commonmodule::ControlDPC {
        self.reset.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: super::commonmodule::ControlDPC) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> super::commonmodule::ControlDPC {
        self.reset.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 9;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC syncBackToGrid = 10;


    pub fn get_syncBackToGrid(&self) -> &super::commonmodule::ControlDPC {
        self.syncBackToGrid.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncBackToGrid(&mut self) {
        self.syncBackToGrid.clear();
    }

    pub fn has_syncBackToGrid(&self) -> bool {
        self.syncBackToGrid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBackToGrid(&mut self, v: super::commonmodule::ControlDPC) {
        self.syncBackToGrid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncBackToGrid(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.syncBackToGrid.is_none() {
            self.syncBackToGrid.set_default();
        }
        self.syncBackToGrid.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncBackToGrid(&mut self) -> super::commonmodule::ControlDPC {
        self.syncBackToGrid.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 11;


    pub fn get_transToIslndOnGridLossEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transToIslndOnGridLossEnabled(&mut self) {
        self.transToIslndOnGridLossEnabled.clear();
    }

    pub fn has_transToIslndOnGridLossEnabled(&self) -> bool {
        self.transToIslndOnGridLossEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transToIslndOnGridLossEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.transToIslndOnGridLossEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transToIslndOnGridLossEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.transToIslndOnGridLossEnabled.is_none() {
            self.transToIslndOnGridLossEnabled.set_default();
        }
        self.transToIslndOnGridLossEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_transToIslndOnGridLossEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 12;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlTimestamp startTime = 13;


    pub fn get_startTime(&self) -> &super::commonmodule::ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <super::commonmodule::ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::commonmodule::ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::commonmodule::ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::commonmodule::ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| super::commonmodule::ControlTimestamp::new())
    }
}

impl ::protobuf::Message for GenerationPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.blackStartEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncBackToGrid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transToIslndOnGridLossEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackStartEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncBackToGrid)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transToIslndOnGridLossEnabled)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationPoint {
        GenerationPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "blackStartEnabled",
                |m: &GenerationPoint| { &m.blackStartEnabled },
                |m: &mut GenerationPoint| { &mut m.blackStartEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &GenerationPoint| { &m.frequencySetPointEnabled },
                |m: &mut GenerationPoint| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &GenerationPoint| { &m.pctHzDroop },
                |m: &mut GenerationPoint| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &GenerationPoint| { &m.pctVDroop },
                |m: &mut GenerationPoint| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &GenerationPoint| { &m.rampRates },
                |m: &mut GenerationPoint| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &GenerationPoint| { &m.reactivePwrSetPointEnabled },
                |m: &mut GenerationPoint| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &GenerationPoint| { &m.realPwrSetPointEnabled },
                |m: &mut GenerationPoint| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reset",
                |m: &GenerationPoint| { &m.reset },
                |m: &mut GenerationPoint| { &mut m.reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &GenerationPoint| { &m.state },
                |m: &mut GenerationPoint| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "syncBackToGrid",
                |m: &GenerationPoint| { &m.syncBackToGrid },
                |m: &mut GenerationPoint| { &mut m.syncBackToGrid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "transToIslndOnGridLossEnabled",
                |m: &GenerationPoint| { &m.transToIslndOnGridLossEnabled },
                |m: &mut GenerationPoint| { &mut m.transToIslndOnGridLossEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &GenerationPoint| { &m.voltageSetPointEnabled },
                |m: &mut GenerationPoint| { &mut m.voltageSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlTimestamp>>(
                "startTime",
                |m: &GenerationPoint| { &m.startTime },
                |m: &mut GenerationPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationPoint>(
                "GenerationPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationPoint {
        static instance: ::protobuf::rt::LazyV2<GenerationPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationPoint::new)
    }
}

impl ::protobuf::Clear for GenerationPoint {
    fn clear(&mut self) {
        self.blackStartEnabled.clear();
        self.frequencySetPointEnabled.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.reset.clear();
        self.state.clear();
        self.syncBackToGrid.clear();
        self.transToIslndOnGridLossEnabled.clear();
        self.voltageSetPointEnabled.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<GenerationPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationCSG {
    fn default() -> &'a GenerationCSG {
        <GenerationCSG as ::protobuf::Message>::default_instance()
    }
}

impl GenerationCSG {
    pub fn new() -> GenerationCSG {
        ::std::default::Default::default()
    }

    // repeated .generationmodule.GenerationPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[GenerationPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<GenerationPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<GenerationPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<GenerationPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenerationCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationCSG {
        GenerationCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationPoint>>(
                "crvPts",
                |m: &GenerationCSG| { &m.crvPts },
                |m: &mut GenerationCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationCSG>(
                "GenerationCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationCSG {
        static instance: ::protobuf::rt::LazyV2<GenerationCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationCSG::new)
    }
}

impl ::protobuf::Clear for GenerationCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<GenerationCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationControlScheduleFSCH {
    fn default() -> &'a GenerationControlScheduleFSCH {
        <GenerationControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl GenerationControlScheduleFSCH {
    pub fn new() -> GenerationControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .generationmodule.GenerationCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &GenerationCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <GenerationCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: GenerationCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut GenerationCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> GenerationCSG {
        self.ValDCSG.take().unwrap_or_else(|| GenerationCSG::new())
    }
}

impl ::protobuf::Message for GenerationControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationControlScheduleFSCH {
        GenerationControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationCSG>>(
                "ValDCSG",
                |m: &GenerationControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut GenerationControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationControlScheduleFSCH>(
                "GenerationControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<GenerationControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for GenerationControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationControlFSCC {
    // message fields
    controlFSCC: ::protobuf::SingularPtrField<super::commonmodule::ControlFSCC>,
    GenerationControlScheduleFSCH: ::protobuf::SingularPtrField<GenerationControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationControlFSCC {
    fn default() -> &'a GenerationControlFSCC {
        <GenerationControlFSCC as ::protobuf::Message>::default_instance()
    }
}

impl GenerationControlFSCC {
    pub fn new() -> GenerationControlFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlFSCC controlFSCC = 1;


    pub fn get_controlFSCC(&self) -> &super::commonmodule::ControlFSCC {
        self.controlFSCC.as_ref().unwrap_or_else(|| <super::commonmodule::ControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlFSCC(&mut self) {
        self.controlFSCC.clear();
    }

    pub fn has_controlFSCC(&self) -> bool {
        self.controlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlFSCC(&mut self, v: super::commonmodule::ControlFSCC) {
        self.controlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlFSCC(&mut self) -> &mut super::commonmodule::ControlFSCC {
        if self.controlFSCC.is_none() {
            self.controlFSCC.set_default();
        }
        self.controlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlFSCC(&mut self) -> super::commonmodule::ControlFSCC {
        self.controlFSCC.take().unwrap_or_else(|| super::commonmodule::ControlFSCC::new())
    }

    // .generationmodule.GenerationControlScheduleFSCH GenerationControlScheduleFSCH = 2;


    pub fn get_GenerationControlScheduleFSCH(&self) -> &GenerationControlScheduleFSCH {
        self.GenerationControlScheduleFSCH.as_ref().unwrap_or_else(|| <GenerationControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GenerationControlScheduleFSCH(&mut self) {
        self.GenerationControlScheduleFSCH.clear();
    }

    pub fn has_GenerationControlScheduleFSCH(&self) -> bool {
        self.GenerationControlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GenerationControlScheduleFSCH(&mut self, v: GenerationControlScheduleFSCH) {
        self.GenerationControlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GenerationControlScheduleFSCH(&mut self) -> &mut GenerationControlScheduleFSCH {
        if self.GenerationControlScheduleFSCH.is_none() {
            self.GenerationControlScheduleFSCH.set_default();
        }
        self.GenerationControlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_GenerationControlScheduleFSCH(&mut self) -> GenerationControlScheduleFSCH {
        self.GenerationControlScheduleFSCH.take().unwrap_or_else(|| GenerationControlScheduleFSCH::new())
    }
}

impl ::protobuf::Message for GenerationControlFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.controlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GenerationControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlFSCC)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GenerationControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GenerationControlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlFSCC.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GenerationControlScheduleFSCH.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationControlFSCC {
        GenerationControlFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlFSCC>>(
                "controlFSCC",
                |m: &GenerationControlFSCC| { &m.controlFSCC },
                |m: &mut GenerationControlFSCC| { &mut m.controlFSCC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationControlScheduleFSCH>>(
                "GenerationControlScheduleFSCH",
                |m: &GenerationControlFSCC| { &m.GenerationControlScheduleFSCH },
                |m: &mut GenerationControlFSCC| { &mut m.GenerationControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationControlFSCC>(
                "GenerationControlFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationControlFSCC {
        static instance: ::protobuf::rt::LazyV2<GenerationControlFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationControlFSCC::new)
    }
}

impl ::protobuf::Clear for GenerationControlFSCC {
    fn clear(&mut self) {
        self.controlFSCC.clear();
        self.GenerationControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationControlFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationControlFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationControl {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    generationControlFSCC: ::protobuf::SingularPtrField<GenerationControlFSCC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationControl {
    fn default() -> &'a GenerationControl {
        <GenerationControl as ::protobuf::Message>::default_instance()
    }
}

impl GenerationControl {
    pub fn new() -> GenerationControl {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .generationmodule.GenerationControlFSCC generationControlFSCC = 3;


    pub fn get_generationControlFSCC(&self) -> &GenerationControlFSCC {
        self.generationControlFSCC.as_ref().unwrap_or_else(|| <GenerationControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationControlFSCC(&mut self) {
        self.generationControlFSCC.clear();
    }

    pub fn has_generationControlFSCC(&self) -> bool {
        self.generationControlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationControlFSCC(&mut self, v: GenerationControlFSCC) {
        self.generationControlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationControlFSCC(&mut self) -> &mut GenerationControlFSCC {
        if self.generationControlFSCC.is_none() {
            self.generationControlFSCC.set_default();
        }
        self.generationControlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationControlFSCC(&mut self) -> GenerationControlFSCC {
        self.generationControlFSCC.take().unwrap_or_else(|| GenerationControlFSCC::new())
    }
}

impl ::protobuf::Message for GenerationControl {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationControlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationControlFSCC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationControlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationControlFSCC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationControl {
        GenerationControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &GenerationControl| { &m.controlValue },
                |m: &mut GenerationControl| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &GenerationControl| { &m.check },
                |m: &mut GenerationControl| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationControlFSCC>>(
                "generationControlFSCC",
                |m: &GenerationControl| { &m.generationControlFSCC },
                |m: &mut GenerationControl| { &mut m.generationControlFSCC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationControl>(
                "GenerationControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationControl {
        static instance: ::protobuf::rt::LazyV2<GenerationControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationControl::new)
    }
}

impl ::protobuf::Clear for GenerationControl {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.generationControlFSCC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GeneratingUnit {
    // message fields
    conductingEquipment: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipment>,
    maxOperatingP: ::protobuf::SingularPtrField<super::commonmodule::ActivePower>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeneratingUnit {
    fn default() -> &'a GeneratingUnit {
        <GeneratingUnit as ::protobuf::Message>::default_instance()
    }
}

impl GeneratingUnit {
    pub fn new() -> GeneratingUnit {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipment conductingEquipment = 1;


    pub fn get_conductingEquipment(&self) -> &super::commonmodule::ConductingEquipment {
        self.conductingEquipment.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipment(&mut self) {
        self.conductingEquipment.clear();
    }

    pub fn has_conductingEquipment(&self) -> bool {
        self.conductingEquipment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipment(&mut self, v: super::commonmodule::ConductingEquipment) {
        self.conductingEquipment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipment(&mut self) -> &mut super::commonmodule::ConductingEquipment {
        if self.conductingEquipment.is_none() {
            self.conductingEquipment.set_default();
        }
        self.conductingEquipment.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipment(&mut self) -> super::commonmodule::ConductingEquipment {
        self.conductingEquipment.take().unwrap_or_else(|| super::commonmodule::ConductingEquipment::new())
    }

    // .commonmodule.ActivePower maxOperatingP = 2;


    pub fn get_maxOperatingP(&self) -> &super::commonmodule::ActivePower {
        self.maxOperatingP.as_ref().unwrap_or_else(|| <super::commonmodule::ActivePower as ::protobuf::Message>::default_instance())
    }
    pub fn clear_maxOperatingP(&mut self) {
        self.maxOperatingP.clear();
    }

    pub fn has_maxOperatingP(&self) -> bool {
        self.maxOperatingP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxOperatingP(&mut self, v: super::commonmodule::ActivePower) {
        self.maxOperatingP = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maxOperatingP(&mut self) -> &mut super::commonmodule::ActivePower {
        if self.maxOperatingP.is_none() {
            self.maxOperatingP.set_default();
        }
        self.maxOperatingP.as_mut().unwrap()
    }

    // Take field
    pub fn take_maxOperatingP(&mut self) -> super::commonmodule::ActivePower {
        self.maxOperatingP.take().unwrap_or_else(|| super::commonmodule::ActivePower::new())
    }
}

impl ::protobuf::Message for GeneratingUnit {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maxOperatingP {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maxOperatingP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maxOperatingP.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maxOperatingP.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeneratingUnit {
        GeneratingUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipment>>(
                "conductingEquipment",
                |m: &GeneratingUnit| { &m.conductingEquipment },
                |m: &mut GeneratingUnit| { &mut m.conductingEquipment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ActivePower>>(
                "maxOperatingP",
                |m: &GeneratingUnit| { &m.maxOperatingP },
                |m: &mut GeneratingUnit| { &mut m.maxOperatingP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GeneratingUnit>(
                "GeneratingUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GeneratingUnit {
        static instance: ::protobuf::rt::LazyV2<GeneratingUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GeneratingUnit::new)
    }
}

impl ::protobuf::Clear for GeneratingUnit {
    fn clear(&mut self) {
        self.conductingEquipment.clear();
        self.maxOperatingP.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeneratingUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeneratingUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationControlProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    generatingUnit: ::protobuf::SingularPtrField<GeneratingUnit>,
    generationControl: ::protobuf::SingularPtrField<GenerationControl>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationControlProfile {
    fn default() -> &'a GenerationControlProfile {
        <GenerationControlProfile as ::protobuf::Message>::default_instance()
    }
}

impl GenerationControlProfile {
    pub fn new() -> GenerationControlProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .generationmodule.GeneratingUnit generatingUnit = 2;


    pub fn get_generatingUnit(&self) -> &GeneratingUnit {
        self.generatingUnit.as_ref().unwrap_or_else(|| <GeneratingUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generatingUnit(&mut self) {
        self.generatingUnit.clear();
    }

    pub fn has_generatingUnit(&self) -> bool {
        self.generatingUnit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatingUnit(&mut self, v: GeneratingUnit) {
        self.generatingUnit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatingUnit(&mut self) -> &mut GeneratingUnit {
        if self.generatingUnit.is_none() {
            self.generatingUnit.set_default();
        }
        self.generatingUnit.as_mut().unwrap()
    }

    // Take field
    pub fn take_generatingUnit(&mut self) -> GeneratingUnit {
        self.generatingUnit.take().unwrap_or_else(|| GeneratingUnit::new())
    }

    // .generationmodule.GenerationControl generationControl = 3;


    pub fn get_generationControl(&self) -> &GenerationControl {
        self.generationControl.as_ref().unwrap_or_else(|| <GenerationControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationControl(&mut self) {
        self.generationControl.clear();
    }

    pub fn has_generationControl(&self) -> bool {
        self.generationControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationControl(&mut self, v: GenerationControl) {
        self.generationControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationControl(&mut self) -> &mut GenerationControl {
        if self.generationControl.is_none() {
            self.generationControl.set_default();
        }
        self.generationControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationControl(&mut self) -> GenerationControl {
        self.generationControl.take().unwrap_or_else(|| GenerationControl::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for GenerationControlProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generatingUnit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generatingUnit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationControl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationControl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationControlProfile {
        GenerationControlProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &GenerationControlProfile| { &m.controlMessageInfo },
                |m: &mut GenerationControlProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeneratingUnit>>(
                "generatingUnit",
                |m: &GenerationControlProfile| { &m.generatingUnit },
                |m: &mut GenerationControlProfile| { &mut m.generatingUnit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationControl>>(
                "generationControl",
                |m: &GenerationControlProfile| { &m.generationControl },
                |m: &mut GenerationControlProfile| { &mut m.generationControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &GenerationControlProfile| { &m.ied },
                |m: &mut GenerationControlProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationControlProfile>(
                "GenerationControlProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationControlProfile {
        static instance: ::protobuf::rt::LazyV2<GenerationControlProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationControlProfile::new)
    }
}

impl ::protobuf::Clear for GenerationControlProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.generatingUnit.clear();
        self.generationControl.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationControlProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationControlProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationReading {
    // message fields
    conductingEquipmentTerminalReading: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipmentTerminalReading>,
    phaseMMTN: ::protobuf::SingularPtrField<super::commonmodule::PhaseMMTN>,
    readingMMTR: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMTR>,
    readingMMXU: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMXU>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationReading {
    fn default() -> &'a GenerationReading {
        <GenerationReading as ::protobuf::Message>::default_instance()
    }
}

impl GenerationReading {
    pub fn new() -> GenerationReading {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1;


    pub fn get_conductingEquipmentTerminalReading(&self) -> &super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipmentTerminalReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipmentTerminalReading(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
    }

    pub fn has_conductingEquipmentTerminalReading(&self) -> bool {
        self.conductingEquipmentTerminalReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipmentTerminalReading(&mut self, v: super::commonmodule::ConductingEquipmentTerminalReading) {
        self.conductingEquipmentTerminalReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipmentTerminalReading(&mut self) -> &mut super::commonmodule::ConductingEquipmentTerminalReading {
        if self.conductingEquipmentTerminalReading.is_none() {
            self.conductingEquipmentTerminalReading.set_default();
        }
        self.conductingEquipmentTerminalReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipmentTerminalReading(&mut self) -> super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.take().unwrap_or_else(|| super::commonmodule::ConductingEquipmentTerminalReading::new())
    }

    // .commonmodule.PhaseMMTN phaseMMTN = 2;


    pub fn get_phaseMMTN(&self) -> &super::commonmodule::PhaseMMTN {
        self.phaseMMTN.as_ref().unwrap_or_else(|| <super::commonmodule::PhaseMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phaseMMTN(&mut self) {
        self.phaseMMTN.clear();
    }

    pub fn has_phaseMMTN(&self) -> bool {
        self.phaseMMTN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phaseMMTN(&mut self, v: super::commonmodule::PhaseMMTN) {
        self.phaseMMTN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phaseMMTN(&mut self) -> &mut super::commonmodule::PhaseMMTN {
        if self.phaseMMTN.is_none() {
            self.phaseMMTN.set_default();
        }
        self.phaseMMTN.as_mut().unwrap()
    }

    // Take field
    pub fn take_phaseMMTN(&mut self) -> super::commonmodule::PhaseMMTN {
        self.phaseMMTN.take().unwrap_or_else(|| super::commonmodule::PhaseMMTN::new())
    }

    // .commonmodule.ReadingMMTR readingMMTR = 3;


    pub fn get_readingMMTR(&self) -> &super::commonmodule::ReadingMMTR {
        self.readingMMTR.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMTR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMTR(&mut self) {
        self.readingMMTR.clear();
    }

    pub fn has_readingMMTR(&self) -> bool {
        self.readingMMTR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMTR(&mut self, v: super::commonmodule::ReadingMMTR) {
        self.readingMMTR = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMTR(&mut self) -> &mut super::commonmodule::ReadingMMTR {
        if self.readingMMTR.is_none() {
            self.readingMMTR.set_default();
        }
        self.readingMMTR.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMTR(&mut self) -> super::commonmodule::ReadingMMTR {
        self.readingMMTR.take().unwrap_or_else(|| super::commonmodule::ReadingMMTR::new())
    }

    // .commonmodule.ReadingMMXU readingMMXU = 4;


    pub fn get_readingMMXU(&self) -> &super::commonmodule::ReadingMMXU {
        self.readingMMXU.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMXU as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMXU(&mut self) {
        self.readingMMXU.clear();
    }

    pub fn has_readingMMXU(&self) -> bool {
        self.readingMMXU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMXU(&mut self, v: super::commonmodule::ReadingMMXU) {
        self.readingMMXU = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMXU(&mut self) -> &mut super::commonmodule::ReadingMMXU {
        if self.readingMMXU.is_none() {
            self.readingMMXU.set_default();
        }
        self.readingMMXU.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMXU(&mut self) -> super::commonmodule::ReadingMMXU {
        self.readingMMXU.take().unwrap_or_else(|| super::commonmodule::ReadingMMXU::new())
    }
}

impl ::protobuf::Message for GenerationReading {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipmentTerminalReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phaseMMTN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMTR {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMXU {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipmentTerminalReading)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phaseMMTN)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMTR)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMXU)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationReading {
        GenerationReading::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipmentTerminalReading>>(
                "conductingEquipmentTerminalReading",
                |m: &GenerationReading| { &m.conductingEquipmentTerminalReading },
                |m: &mut GenerationReading| { &mut m.conductingEquipmentTerminalReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::PhaseMMTN>>(
                "phaseMMTN",
                |m: &GenerationReading| { &m.phaseMMTN },
                |m: &mut GenerationReading| { &mut m.phaseMMTN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMTR>>(
                "readingMMTR",
                |m: &GenerationReading| { &m.readingMMTR },
                |m: &mut GenerationReading| { &mut m.readingMMTR },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMXU>>(
                "readingMMXU",
                |m: &GenerationReading| { &m.readingMMXU },
                |m: &mut GenerationReading| { &mut m.readingMMXU },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationReading>(
                "GenerationReading",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationReading {
        static instance: ::protobuf::rt::LazyV2<GenerationReading> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationReading::new)
    }
}

impl ::protobuf::Clear for GenerationReading {
    fn clear(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
        self.phaseMMTN.clear();
        self.readingMMTR.clear();
        self.readingMMXU.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationReading {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationReadingProfile {
    // message fields
    readingMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ReadingMessageInfo>,
    generatingUnit: ::protobuf::SingularPtrField<GeneratingUnit>,
    generationReading: ::protobuf::SingularPtrField<GenerationReading>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationReadingProfile {
    fn default() -> &'a GenerationReadingProfile {
        <GenerationReadingProfile as ::protobuf::Message>::default_instance()
    }
}

impl GenerationReadingProfile {
    pub fn new() -> GenerationReadingProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ReadingMessageInfo readingMessageInfo = 1;


    pub fn get_readingMessageInfo(&self) -> &super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMessageInfo(&mut self) {
        self.readingMessageInfo.clear();
    }

    pub fn has_readingMessageInfo(&self) -> bool {
        self.readingMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMessageInfo(&mut self, v: super::commonmodule::ReadingMessageInfo) {
        self.readingMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMessageInfo(&mut self) -> &mut super::commonmodule::ReadingMessageInfo {
        if self.readingMessageInfo.is_none() {
            self.readingMessageInfo.set_default();
        }
        self.readingMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMessageInfo(&mut self) -> super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.take().unwrap_or_else(|| super::commonmodule::ReadingMessageInfo::new())
    }

    // .generationmodule.GeneratingUnit generatingUnit = 2;


    pub fn get_generatingUnit(&self) -> &GeneratingUnit {
        self.generatingUnit.as_ref().unwrap_or_else(|| <GeneratingUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generatingUnit(&mut self) {
        self.generatingUnit.clear();
    }

    pub fn has_generatingUnit(&self) -> bool {
        self.generatingUnit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatingUnit(&mut self, v: GeneratingUnit) {
        self.generatingUnit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatingUnit(&mut self) -> &mut GeneratingUnit {
        if self.generatingUnit.is_none() {
            self.generatingUnit.set_default();
        }
        self.generatingUnit.as_mut().unwrap()
    }

    // Take field
    pub fn take_generatingUnit(&mut self) -> GeneratingUnit {
        self.generatingUnit.take().unwrap_or_else(|| GeneratingUnit::new())
    }

    // .generationmodule.GenerationReading generationReading = 3;


    pub fn get_generationReading(&self) -> &GenerationReading {
        self.generationReading.as_ref().unwrap_or_else(|| <GenerationReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationReading(&mut self) {
        self.generationReading.clear();
    }

    pub fn has_generationReading(&self) -> bool {
        self.generationReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationReading(&mut self, v: GenerationReading) {
        self.generationReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationReading(&mut self) -> &mut GenerationReading {
        if self.generationReading.is_none() {
            self.generationReading.set_default();
        }
        self.generationReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationReading(&mut self) -> GenerationReading {
        self.generationReading.take().unwrap_or_else(|| GenerationReading::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for GenerationReadingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.readingMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generatingUnit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generatingUnit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationReading)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationReading.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationReadingProfile {
        GenerationReadingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMessageInfo>>(
                "readingMessageInfo",
                |m: &GenerationReadingProfile| { &m.readingMessageInfo },
                |m: &mut GenerationReadingProfile| { &mut m.readingMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeneratingUnit>>(
                "generatingUnit",
                |m: &GenerationReadingProfile| { &m.generatingUnit },
                |m: &mut GenerationReadingProfile| { &mut m.generatingUnit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationReading>>(
                "generationReading",
                |m: &GenerationReadingProfile| { &m.generationReading },
                |m: &mut GenerationReadingProfile| { &mut m.generationReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &GenerationReadingProfile| { &m.ied },
                |m: &mut GenerationReadingProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationReadingProfile>(
                "GenerationReadingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationReadingProfile {
        static instance: ::protobuf::rt::LazyV2<GenerationReadingProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationReadingProfile::new)
    }
}

impl ::protobuf::Clear for GenerationReadingProfile {
    fn clear(&mut self) {
        self.readingMessageInfo.clear();
        self.generatingUnit.clear();
        self.generationReading.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationReadingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationReadingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationPointStatus {
    // message fields
    blackStartEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    syncBackToGrid: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    transToIslndOnGridLossEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationPointStatus {
    fn default() -> &'a GenerationPointStatus {
        <GenerationPointStatus as ::protobuf::Message>::default_instance()
    }
}

impl GenerationPointStatus {
    pub fn new() -> GenerationPointStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC blackStartEnabled = 1;


    pub fn get_blackStartEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.blackStartEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackStartEnabled(&mut self) {
        self.blackStartEnabled.clear();
    }

    pub fn has_blackStartEnabled(&self) -> bool {
        self.blackStartEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackStartEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.blackStartEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackStartEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.blackStartEnabled.is_none() {
            self.blackStartEnabled.set_default();
        }
        self.blackStartEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackStartEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.blackStartEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 2;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 3;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 4;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 5;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 8;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC syncBackToGrid = 9;


    pub fn get_syncBackToGrid(&self) -> &super::commonmodule::ControlDPC {
        self.syncBackToGrid.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncBackToGrid(&mut self) {
        self.syncBackToGrid.clear();
    }

    pub fn has_syncBackToGrid(&self) -> bool {
        self.syncBackToGrid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBackToGrid(&mut self, v: super::commonmodule::ControlDPC) {
        self.syncBackToGrid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncBackToGrid(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.syncBackToGrid.is_none() {
            self.syncBackToGrid.set_default();
        }
        self.syncBackToGrid.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncBackToGrid(&mut self) -> super::commonmodule::ControlDPC {
        self.syncBackToGrid.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 10;


    pub fn get_transToIslndOnGridLossEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transToIslndOnGridLossEnabled(&mut self) {
        self.transToIslndOnGridLossEnabled.clear();
    }

    pub fn has_transToIslndOnGridLossEnabled(&self) -> bool {
        self.transToIslndOnGridLossEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transToIslndOnGridLossEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.transToIslndOnGridLossEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transToIslndOnGridLossEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.transToIslndOnGridLossEnabled.is_none() {
            self.transToIslndOnGridLossEnabled.set_default();
        }
        self.transToIslndOnGridLossEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_transToIslndOnGridLossEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 11;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }
}

impl ::protobuf::Message for GenerationPointStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.blackStartEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncBackToGrid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transToIslndOnGridLossEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackStartEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncBackToGrid)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transToIslndOnGridLossEnabled)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationPointStatus {
        GenerationPointStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "blackStartEnabled",
                |m: &GenerationPointStatus| { &m.blackStartEnabled },
                |m: &mut GenerationPointStatus| { &mut m.blackStartEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &GenerationPointStatus| { &m.frequencySetPointEnabled },
                |m: &mut GenerationPointStatus| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &GenerationPointStatus| { &m.pctHzDroop },
                |m: &mut GenerationPointStatus| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &GenerationPointStatus| { &m.pctVDroop },
                |m: &mut GenerationPointStatus| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &GenerationPointStatus| { &m.rampRates },
                |m: &mut GenerationPointStatus| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &GenerationPointStatus| { &m.reactivePwrSetPointEnabled },
                |m: &mut GenerationPointStatus| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &GenerationPointStatus| { &m.realPwrSetPointEnabled },
                |m: &mut GenerationPointStatus| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &GenerationPointStatus| { &m.state },
                |m: &mut GenerationPointStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "syncBackToGrid",
                |m: &GenerationPointStatus| { &m.syncBackToGrid },
                |m: &mut GenerationPointStatus| { &mut m.syncBackToGrid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "transToIslndOnGridLossEnabled",
                |m: &GenerationPointStatus| { &m.transToIslndOnGridLossEnabled },
                |m: &mut GenerationPointStatus| { &mut m.transToIslndOnGridLossEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &GenerationPointStatus| { &m.voltageSetPointEnabled },
                |m: &mut GenerationPointStatus| { &mut m.voltageSetPointEnabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationPointStatus>(
                "GenerationPointStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationPointStatus {
        static instance: ::protobuf::rt::LazyV2<GenerationPointStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationPointStatus::new)
    }
}

impl ::protobuf::Clear for GenerationPointStatus {
    fn clear(&mut self) {
        self.blackStartEnabled.clear();
        self.frequencySetPointEnabled.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.state.clear();
        self.syncBackToGrid.clear();
        self.transToIslndOnGridLossEnabled.clear();
        self.voltageSetPointEnabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationPointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationPointStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationEventAndStatusZGEN {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    AuxPwrSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    DynamicTest: ::protobuf::SingularPtrField<super::commonmodule::ENS_DynamicTestKind>,
    EmgStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    GnSynSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PointStatus: ::protobuf::SingularPtrField<GenerationPointStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationEventAndStatusZGEN {
    fn default() -> &'a GenerationEventAndStatusZGEN {
        <GenerationEventAndStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl GenerationEventAndStatusZGEN {
    pub fn new() -> GenerationEventAndStatusZGEN {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.StatusSPS AuxPwrSt = 2;


    pub fn get_AuxPwrSt(&self) -> &super::commonmodule::StatusSPS {
        self.AuxPwrSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_AuxPwrSt(&mut self) {
        self.AuxPwrSt.clear();
    }

    pub fn has_AuxPwrSt(&self) -> bool {
        self.AuxPwrSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AuxPwrSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.AuxPwrSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AuxPwrSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.AuxPwrSt.is_none() {
            self.AuxPwrSt.set_default();
        }
        self.AuxPwrSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_AuxPwrSt(&mut self) -> super::commonmodule::StatusSPS {
        self.AuxPwrSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;


    pub fn get_DynamicTest(&self) -> &super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.as_ref().unwrap_or_else(|| <super::commonmodule::ENS_DynamicTestKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DynamicTest(&mut self) {
        self.DynamicTest.clear();
    }

    pub fn has_DynamicTest(&self) -> bool {
        self.DynamicTest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DynamicTest(&mut self, v: super::commonmodule::ENS_DynamicTestKind) {
        self.DynamicTest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DynamicTest(&mut self) -> &mut super::commonmodule::ENS_DynamicTestKind {
        if self.DynamicTest.is_none() {
            self.DynamicTest.set_default();
        }
        self.DynamicTest.as_mut().unwrap()
    }

    // Take field
    pub fn take_DynamicTest(&mut self) -> super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.take().unwrap_or_else(|| super::commonmodule::ENS_DynamicTestKind::new())
    }

    // .commonmodule.StatusSPS EmgStop = 4;


    pub fn get_EmgStop(&self) -> &super::commonmodule::StatusSPS {
        self.EmgStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_EmgStop(&mut self) {
        self.EmgStop.clear();
    }

    pub fn has_EmgStop(&self) -> bool {
        self.EmgStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EmgStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.EmgStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EmgStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.EmgStop.is_none() {
            self.EmgStop.set_default();
        }
        self.EmgStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_EmgStop(&mut self) -> super::commonmodule::StatusSPS {
        self.EmgStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS GnSynSt = 5;


    pub fn get_GnSynSt(&self) -> &super::commonmodule::StatusSPS {
        self.GnSynSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GnSynSt(&mut self) {
        self.GnSynSt.clear();
    }

    pub fn has_GnSynSt(&self) -> bool {
        self.GnSynSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GnSynSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.GnSynSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GnSynSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.GnSynSt.is_none() {
            self.GnSynSt.set_default();
        }
        self.GnSynSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_GnSynSt(&mut self) -> super::commonmodule::StatusSPS {
        self.GnSynSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .generationmodule.GenerationPointStatus PointStatus = 6;


    pub fn get_PointStatus(&self) -> &GenerationPointStatus {
        self.PointStatus.as_ref().unwrap_or_else(|| <GenerationPointStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PointStatus(&mut self) {
        self.PointStatus.clear();
    }

    pub fn has_PointStatus(&self) -> bool {
        self.PointStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PointStatus(&mut self, v: GenerationPointStatus) {
        self.PointStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PointStatus(&mut self) -> &mut GenerationPointStatus {
        if self.PointStatus.is_none() {
            self.PointStatus.set_default();
        }
        self.PointStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_PointStatus(&mut self) -> GenerationPointStatus {
        self.PointStatus.take().unwrap_or_else(|| GenerationPointStatus::new())
    }
}

impl ::protobuf::Message for GenerationEventAndStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.AuxPwrSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DynamicTest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EmgStop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GnSynSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PointStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AuxPwrSt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DynamicTest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EmgStop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GnSynSt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PointStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GnSynSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GnSynSt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationEventAndStatusZGEN {
        GenerationEventAndStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &GenerationEventAndStatusZGEN| { &m.logicalNodeForEventAndStatus },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "AuxPwrSt",
                |m: &GenerationEventAndStatusZGEN| { &m.AuxPwrSt },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.AuxPwrSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENS_DynamicTestKind>>(
                "DynamicTest",
                |m: &GenerationEventAndStatusZGEN| { &m.DynamicTest },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.DynamicTest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "EmgStop",
                |m: &GenerationEventAndStatusZGEN| { &m.EmgStop },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.EmgStop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "GnSynSt",
                |m: &GenerationEventAndStatusZGEN| { &m.GnSynSt },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.GnSynSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationPointStatus>>(
                "PointStatus",
                |m: &GenerationEventAndStatusZGEN| { &m.PointStatus },
                |m: &mut GenerationEventAndStatusZGEN| { &mut m.PointStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationEventAndStatusZGEN>(
                "GenerationEventAndStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationEventAndStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<GenerationEventAndStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationEventAndStatusZGEN::new)
    }
}

impl ::protobuf::Clear for GenerationEventAndStatusZGEN {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.AuxPwrSt.clear();
        self.DynamicTest.clear();
        self.EmgStop.clear();
        self.GnSynSt.clear();
        self.PointStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationEventAndStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationEventAndStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationEventZGEN {
    // message fields
    generationEventAndStatusZGEN: ::protobuf::SingularPtrField<GenerationEventAndStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationEventZGEN {
    fn default() -> &'a GenerationEventZGEN {
        <GenerationEventZGEN as ::protobuf::Message>::default_instance()
    }
}

impl GenerationEventZGEN {
    pub fn new() -> GenerationEventZGEN {
        ::std::default::Default::default()
    }

    // .generationmodule.GenerationEventAndStatusZGEN generationEventAndStatusZGEN = 1;


    pub fn get_generationEventAndStatusZGEN(&self) -> &GenerationEventAndStatusZGEN {
        self.generationEventAndStatusZGEN.as_ref().unwrap_or_else(|| <GenerationEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationEventAndStatusZGEN(&mut self) {
        self.generationEventAndStatusZGEN.clear();
    }

    pub fn has_generationEventAndStatusZGEN(&self) -> bool {
        self.generationEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationEventAndStatusZGEN(&mut self, v: GenerationEventAndStatusZGEN) {
        self.generationEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationEventAndStatusZGEN(&mut self) -> &mut GenerationEventAndStatusZGEN {
        if self.generationEventAndStatusZGEN.is_none() {
            self.generationEventAndStatusZGEN.set_default();
        }
        self.generationEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationEventAndStatusZGEN(&mut self) -> GenerationEventAndStatusZGEN {
        self.generationEventAndStatusZGEN.take().unwrap_or_else(|| GenerationEventAndStatusZGEN::new())
    }
}

impl ::protobuf::Message for GenerationEventZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.generationEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationEventAndStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.generationEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.generationEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationEventZGEN {
        GenerationEventZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationEventAndStatusZGEN>>(
                "generationEventAndStatusZGEN",
                |m: &GenerationEventZGEN| { &m.generationEventAndStatusZGEN },
                |m: &mut GenerationEventZGEN| { &mut m.generationEventAndStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationEventZGEN>(
                "GenerationEventZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationEventZGEN {
        static instance: ::protobuf::rt::LazyV2<GenerationEventZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationEventZGEN::new)
    }
}

impl ::protobuf::Clear for GenerationEventZGEN {
    fn clear(&mut self) {
        self.generationEventAndStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationEventZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationEventZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationEvent {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    generationEventZGEN: ::protobuf::SingularPtrField<GenerationEventZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationEvent {
    fn default() -> &'a GenerationEvent {
        <GenerationEvent as ::protobuf::Message>::default_instance()
    }
}

impl GenerationEvent {
    pub fn new() -> GenerationEvent {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .generationmodule.GenerationEventZGEN generationEventZGEN = 2;


    pub fn get_generationEventZGEN(&self) -> &GenerationEventZGEN {
        self.generationEventZGEN.as_ref().unwrap_or_else(|| <GenerationEventZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationEventZGEN(&mut self) {
        self.generationEventZGEN.clear();
    }

    pub fn has_generationEventZGEN(&self) -> bool {
        self.generationEventZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationEventZGEN(&mut self, v: GenerationEventZGEN) {
        self.generationEventZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationEventZGEN(&mut self) -> &mut GenerationEventZGEN {
        if self.generationEventZGEN.is_none() {
            self.generationEventZGEN.set_default();
        }
        self.generationEventZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationEventZGEN(&mut self) -> GenerationEventZGEN {
        self.generationEventZGEN.take().unwrap_or_else(|| GenerationEventZGEN::new())
    }
}

impl ::protobuf::Message for GenerationEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationEventZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationEventZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationEventZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationEventZGEN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationEvent {
        GenerationEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &GenerationEvent| { &m.eventValue },
                |m: &mut GenerationEvent| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationEventZGEN>>(
                "generationEventZGEN",
                |m: &GenerationEvent| { &m.generationEventZGEN },
                |m: &mut GenerationEvent| { &mut m.generationEventZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationEvent>(
                "GenerationEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationEvent {
        static instance: ::protobuf::rt::LazyV2<GenerationEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationEvent::new)
    }
}

impl ::protobuf::Clear for GenerationEvent {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.generationEventZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationEventProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    generatingUnit: ::protobuf::SingularPtrField<GeneratingUnit>,
    generationEvent: ::protobuf::SingularPtrField<GenerationEvent>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationEventProfile {
    fn default() -> &'a GenerationEventProfile {
        <GenerationEventProfile as ::protobuf::Message>::default_instance()
    }
}

impl GenerationEventProfile {
    pub fn new() -> GenerationEventProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .generationmodule.GeneratingUnit generatingUnit = 2;


    pub fn get_generatingUnit(&self) -> &GeneratingUnit {
        self.generatingUnit.as_ref().unwrap_or_else(|| <GeneratingUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generatingUnit(&mut self) {
        self.generatingUnit.clear();
    }

    pub fn has_generatingUnit(&self) -> bool {
        self.generatingUnit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatingUnit(&mut self, v: GeneratingUnit) {
        self.generatingUnit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatingUnit(&mut self) -> &mut GeneratingUnit {
        if self.generatingUnit.is_none() {
            self.generatingUnit.set_default();
        }
        self.generatingUnit.as_mut().unwrap()
    }

    // Take field
    pub fn take_generatingUnit(&mut self) -> GeneratingUnit {
        self.generatingUnit.take().unwrap_or_else(|| GeneratingUnit::new())
    }

    // .generationmodule.GenerationEvent generationEvent = 3;


    pub fn get_generationEvent(&self) -> &GenerationEvent {
        self.generationEvent.as_ref().unwrap_or_else(|| <GenerationEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationEvent(&mut self) {
        self.generationEvent.clear();
    }

    pub fn has_generationEvent(&self) -> bool {
        self.generationEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationEvent(&mut self, v: GenerationEvent) {
        self.generationEvent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationEvent(&mut self) -> &mut GenerationEvent {
        if self.generationEvent.is_none() {
            self.generationEvent.set_default();
        }
        self.generationEvent.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationEvent(&mut self) -> GenerationEvent {
        self.generationEvent.take().unwrap_or_else(|| GenerationEvent::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for GenerationEventProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generatingUnit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generatingUnit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationEvent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationEvent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationEvent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationEventProfile {
        GenerationEventProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &GenerationEventProfile| { &m.eventMessageInfo },
                |m: &mut GenerationEventProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeneratingUnit>>(
                "generatingUnit",
                |m: &GenerationEventProfile| { &m.generatingUnit },
                |m: &mut GenerationEventProfile| { &mut m.generatingUnit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationEvent>>(
                "generationEvent",
                |m: &GenerationEventProfile| { &m.generationEvent },
                |m: &mut GenerationEventProfile| { &mut m.generationEvent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &GenerationEventProfile| { &m.ied },
                |m: &mut GenerationEventProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationEventProfile>(
                "GenerationEventProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationEventProfile {
        static instance: ::protobuf::rt::LazyV2<GenerationEventProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationEventProfile::new)
    }
}

impl ::protobuf::Clear for GenerationEventProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.generatingUnit.clear();
        self.generationEvent.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationEventProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationEventProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationStatusZGEN {
    // message fields
    generationEventAndStatusZGEN: ::protobuf::SingularPtrField<GenerationEventAndStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationStatusZGEN {
    fn default() -> &'a GenerationStatusZGEN {
        <GenerationStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl GenerationStatusZGEN {
    pub fn new() -> GenerationStatusZGEN {
        ::std::default::Default::default()
    }

    // .generationmodule.GenerationEventAndStatusZGEN generationEventAndStatusZGEN = 1;


    pub fn get_generationEventAndStatusZGEN(&self) -> &GenerationEventAndStatusZGEN {
        self.generationEventAndStatusZGEN.as_ref().unwrap_or_else(|| <GenerationEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationEventAndStatusZGEN(&mut self) {
        self.generationEventAndStatusZGEN.clear();
    }

    pub fn has_generationEventAndStatusZGEN(&self) -> bool {
        self.generationEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationEventAndStatusZGEN(&mut self, v: GenerationEventAndStatusZGEN) {
        self.generationEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationEventAndStatusZGEN(&mut self) -> &mut GenerationEventAndStatusZGEN {
        if self.generationEventAndStatusZGEN.is_none() {
            self.generationEventAndStatusZGEN.set_default();
        }
        self.generationEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationEventAndStatusZGEN(&mut self) -> GenerationEventAndStatusZGEN {
        self.generationEventAndStatusZGEN.take().unwrap_or_else(|| GenerationEventAndStatusZGEN::new())
    }
}

impl ::protobuf::Message for GenerationStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.generationEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationEventAndStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.generationEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.generationEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationStatusZGEN {
        GenerationStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationEventAndStatusZGEN>>(
                "generationEventAndStatusZGEN",
                |m: &GenerationStatusZGEN| { &m.generationEventAndStatusZGEN },
                |m: &mut GenerationStatusZGEN| { &mut m.generationEventAndStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationStatusZGEN>(
                "GenerationStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<GenerationStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationStatusZGEN::new)
    }
}

impl ::protobuf::Clear for GenerationStatusZGEN {
    fn clear(&mut self) {
        self.generationEventAndStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationStatus {
    // message fields
    statusValue: ::protobuf::SingularPtrField<super::commonmodule::StatusValue>,
    generationStatusZGEN: ::protobuf::SingularPtrField<GenerationStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationStatus {
    fn default() -> &'a GenerationStatus {
        <GenerationStatus as ::protobuf::Message>::default_instance()
    }
}

impl GenerationStatus {
    pub fn new() -> GenerationStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusValue statusValue = 1;


    pub fn get_statusValue(&self) -> &super::commonmodule::StatusValue {
        self.statusValue.as_ref().unwrap_or_else(|| <super::commonmodule::StatusValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusValue(&mut self) {
        self.statusValue.clear();
    }

    pub fn has_statusValue(&self) -> bool {
        self.statusValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusValue(&mut self, v: super::commonmodule::StatusValue) {
        self.statusValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusValue(&mut self) -> &mut super::commonmodule::StatusValue {
        if self.statusValue.is_none() {
            self.statusValue.set_default();
        }
        self.statusValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusValue(&mut self) -> super::commonmodule::StatusValue {
        self.statusValue.take().unwrap_or_else(|| super::commonmodule::StatusValue::new())
    }

    // .generationmodule.GenerationStatusZGEN generationStatusZGEN = 2;


    pub fn get_generationStatusZGEN(&self) -> &GenerationStatusZGEN {
        self.generationStatusZGEN.as_ref().unwrap_or_else(|| <GenerationStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationStatusZGEN(&mut self) {
        self.generationStatusZGEN.clear();
    }

    pub fn has_generationStatusZGEN(&self) -> bool {
        self.generationStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationStatusZGEN(&mut self, v: GenerationStatusZGEN) {
        self.generationStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationStatusZGEN(&mut self) -> &mut GenerationStatusZGEN {
        if self.generationStatusZGEN.is_none() {
            self.generationStatusZGEN.set_default();
        }
        self.generationStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationStatusZGEN(&mut self) -> GenerationStatusZGEN {
        self.generationStatusZGEN.take().unwrap_or_else(|| GenerationStatusZGEN::new())
    }
}

impl ::protobuf::Message for GenerationStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.statusValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationStatusZGEN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationStatus {
        GenerationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusValue>>(
                "statusValue",
                |m: &GenerationStatus| { &m.statusValue },
                |m: &mut GenerationStatus| { &mut m.statusValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationStatusZGEN>>(
                "generationStatusZGEN",
                |m: &GenerationStatus| { &m.generationStatusZGEN },
                |m: &mut GenerationStatus| { &mut m.generationStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationStatus>(
                "GenerationStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationStatus {
        static instance: ::protobuf::rt::LazyV2<GenerationStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationStatus::new)
    }
}

impl ::protobuf::Clear for GenerationStatus {
    fn clear(&mut self) {
        self.statusValue.clear();
        self.generationStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerationStatusProfile {
    // message fields
    statusMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::StatusMessageInfo>,
    generatingUnit: ::protobuf::SingularPtrField<GeneratingUnit>,
    generationStatus: ::protobuf::SingularPtrField<GenerationStatus>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerationStatusProfile {
    fn default() -> &'a GenerationStatusProfile {
        <GenerationStatusProfile as ::protobuf::Message>::default_instance()
    }
}

impl GenerationStatusProfile {
    pub fn new() -> GenerationStatusProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusMessageInfo statusMessageInfo = 1;


    pub fn get_statusMessageInfo(&self) -> &super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::StatusMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusMessageInfo(&mut self) {
        self.statusMessageInfo.clear();
    }

    pub fn has_statusMessageInfo(&self) -> bool {
        self.statusMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusMessageInfo(&mut self, v: super::commonmodule::StatusMessageInfo) {
        self.statusMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusMessageInfo(&mut self) -> &mut super::commonmodule::StatusMessageInfo {
        if self.statusMessageInfo.is_none() {
            self.statusMessageInfo.set_default();
        }
        self.statusMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusMessageInfo(&mut self) -> super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.take().unwrap_or_else(|| super::commonmodule::StatusMessageInfo::new())
    }

    // .generationmodule.GeneratingUnit generatingUnit = 2;


    pub fn get_generatingUnit(&self) -> &GeneratingUnit {
        self.generatingUnit.as_ref().unwrap_or_else(|| <GeneratingUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generatingUnit(&mut self) {
        self.generatingUnit.clear();
    }

    pub fn has_generatingUnit(&self) -> bool {
        self.generatingUnit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generatingUnit(&mut self, v: GeneratingUnit) {
        self.generatingUnit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generatingUnit(&mut self) -> &mut GeneratingUnit {
        if self.generatingUnit.is_none() {
            self.generatingUnit.set_default();
        }
        self.generatingUnit.as_mut().unwrap()
    }

    // Take field
    pub fn take_generatingUnit(&mut self) -> GeneratingUnit {
        self.generatingUnit.take().unwrap_or_else(|| GeneratingUnit::new())
    }

    // .generationmodule.GenerationStatus generationStatus = 3;


    pub fn get_generationStatus(&self) -> &GenerationStatus {
        self.generationStatus.as_ref().unwrap_or_else(|| <GenerationStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_generationStatus(&mut self) {
        self.generationStatus.clear();
    }

    pub fn has_generationStatus(&self) -> bool {
        self.generationStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationStatus(&mut self, v: GenerationStatus) {
        self.generationStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generationStatus(&mut self) -> &mut GenerationStatus {
        if self.generationStatus.is_none() {
            self.generationStatus.set_default();
        }
        self.generationStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_generationStatus(&mut self) -> GenerationStatus {
        self.generationStatus.take().unwrap_or_else(|| GenerationStatus::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for GenerationStatusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.statusMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generatingUnit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generationStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generatingUnit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.generationStatus)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.generationStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generatingUnit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.generationStatus.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerationStatusProfile {
        GenerationStatusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusMessageInfo>>(
                "statusMessageInfo",
                |m: &GenerationStatusProfile| { &m.statusMessageInfo },
                |m: &mut GenerationStatusProfile| { &mut m.statusMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeneratingUnit>>(
                "generatingUnit",
                |m: &GenerationStatusProfile| { &m.generatingUnit },
                |m: &mut GenerationStatusProfile| { &mut m.generatingUnit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GenerationStatus>>(
                "generationStatus",
                |m: &GenerationStatusProfile| { &m.generationStatus },
                |m: &mut GenerationStatusProfile| { &mut m.generationStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &GenerationStatusProfile| { &m.ied },
                |m: &mut GenerationStatusProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerationStatusProfile>(
                "GenerationStatusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerationStatusProfile {
        static instance: ::protobuf::rt::LazyV2<GenerationStatusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerationStatusProfile::new)
    }
}

impl ::protobuf::Clear for GenerationStatusProfile {
    fn clear(&mut self) {
        self.statusMessageInfo.clear();
        self.generatingUnit.clear();
        self.generationStatus.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerationStatusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerationStatusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'generationmodule/generationmodule.proto\x12\x10generationmodule\"\xc7\
    \x07\n\x0fGenerationPoint\x12H\n\x11blackStartEnabled\x18\x01\x20\x01(\
    \x0b2\x18.commonmodule.ControlDPCR\x11blackStartEnabledB\0\x12V\n\x18fre\
    quencySetPointEnabled\x18\x02\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x18frequencySetPointEnabledB\0\x12=\n\npctHzDroop\x18\x03\x20\x01(\x0b2\
    \x1b.google.protobuf.FloatValueR\npctHzDroopB\0\x12;\n\tpctVDroop\x18\
    \x04\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\tpctVDroopB\0\x126\n\
    \trampRates\x18\x05\x20\x01(\x0b2\x16.commonmodule.RampRateR\trampRatesB\
    \0\x12Z\n\x1areactivePwrSetPointEnabled\x18\x06\x20\x01(\x0b2\x18.common\
    module.ControlDPCR\x1areactivePwrSetPointEnabledB\0\x12R\n\x16realPwrSet\
    PointEnabled\x18\x07\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16realP\
    wrSetPointEnabledB\0\x120\n\x05reset\x18\x08\x20\x01(\x0b2\x18.commonmod\
    ule.ControlDPCR\x05resetB\0\x128\n\x05state\x18\t\x20\x01(\x0b2\x20.comm\
    onmodule.Optional_StateKindR\x05stateB\0\x12B\n\x0esyncBackToGrid\x18\n\
    \x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x0esyncBackToGridB\0\x12`\n\
    \x1dtransToIslndOnGridLossEnabled\x18\x0b\x20\x01(\x0b2\x18.commonmodule\
    .ControlDPCR\x1dtransToIslndOnGridLossEnabledB\0\x12R\n\x16voltageSetPoi\
    ntEnabled\x18\x0c\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16voltageS\
    etPointEnabledB\0\x12F\n\tstartTime\x18\r\x20\x01(\x0b2\x1e.commonmodule\
    .ControlTimestampR\tstartTimeB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"V\
    \n\rGenerationCSG\x12C\n\x06crvPts\x18\x01\x20\x03(\x0b2!.generationmodu\
    le.GenerationPointR\x06crvPtsB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"f\
    \n\x1dGenerationControlScheduleFSCH\x12C\n\x07ValDCSG\x18\x01\x20\x01(\
    \x0b2\x1f.generationmodule.GenerationCSGR\x07ValDCSGB\x08\x88\xb5\x18\
    \x01\x90\xb5\x18\x01:\0\"\xd5\x01\n\x15GenerationControlFSCC\x12A\n\x0bc\
    ontrolFSCC\x18\x01\x20\x01(\x0b2\x19.commonmodule.ControlFSCCR\x0bcontro\
    lFSCCB\x04\x80\xb5\x18\x01\x12w\n\x1dGenerationControlScheduleFSCH\x18\
    \x02\x20\x01(\x0b2/.generationmodule.GenerationControlScheduleFSCHR\x1dG\
    enerationControlScheduleFSCHB\0:\0\"\xfb\x01\n\x11GenerationControl\x12D\
    \n\x0ccontrolValue\x18\x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\
    \x0ccontrolValueB\x04\x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\
    \x0b2\x1d.commonmodule.CheckConditionsR\x05checkB\0\x12g\n\x15generation\
    ControlFSCC\x18\x03\x20\x01(\x0b2'.generationmodule.GenerationControlFSC\
    CR\x15generationControlFSCCB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\
    \xb0\x01\n\x0eGeneratingUnit\x12Y\n\x13conductingEquipment\x18\x01\x20\
    \x01(\x0b2!.commonmodule.ConductingEquipmentR\x13conductingEquipmentB\
    \x04\x80\xb5\x18\x01\x12A\n\rmaxOperatingP\x18\x02\x20\x01(\x0b2\x19.com\
    monmodule.ActivePowerR\rmaxOperatingPB\0:\0\"\xd8\x02\n\x18GenerationCon\
    trolProfile\x12V\n\x12controlMessageInfo\x18\x01\x20\x01(\x0b2\x20.commo\
    nmodule.ControlMessageInfoR\x12controlMessageInfoB\x04\x80\xb5\x18\x01\
    \x12R\n\x0egeneratingUnit\x18\x02\x20\x01(\x0b2\x20.generationmodule.Gen\
    eratingUnitR\x0egeneratingUnitB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12[\
    \n\x11generationControl\x18\x03\x20\x01(\x0b2#.generationmodule.Generati\
    onControlR\x11generationControlB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12\
    -\n\x03ied\x18\x04\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\xd5\x02\n\x11Generat\
    ionReading\x12\x86\x01\n\"conductingEquipmentTerminalReading\x18\x01\x20\
    \x01(\x0b20.commonmodule.ConductingEquipmentTerminalReadingR\"conducting\
    EquipmentTerminalReadingB\x04\x80\xb5\x18\x01\x127\n\tphaseMMTN\x18\x02\
    \x20\x01(\x0b2\x17.commonmodule.PhaseMMTNR\tphaseMMTNB\0\x12=\n\x0breadi\
    ngMMTR\x18\x03\x20\x01(\x0b2\x19.commonmodule.ReadingMMTRR\x0breadingMMT\
    RB\0\x12=\n\x0breadingMMXU\x18\x04\x20\x01(\x0b2\x19.commonmodule.Readin\
    gMMXUR\x0breadingMMXUB\0:\0\"\xd8\x02\n\x18GenerationReadingProfile\x12V\
    \n\x12readingMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ReadingM\
    essageInfoR\x12readingMessageInfoB\x04\x80\xb5\x18\x01\x12R\n\x0egenerat\
    ingUnit\x18\x02\x20\x01(\x0b2\x20.generationmodule.GeneratingUnitR\x0ege\
    neratingUnitB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12[\n\x11generationRe\
    ading\x18\x03\x20\x01(\x0b2#.generationmodule.GenerationReadingR\x11gene\
    rationReadingB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ied\x18\x04\
    \x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\x01\x90\xb5\
    \x18\x01:\x04\xc0\xf3\x18\x01\"\xd3\x06\n\x15GenerationPointStatus\x12H\
    \n\x11blackStartEnabled\x18\x01\x20\x01(\x0b2\x18.commonmodule.ControlDP\
    CR\x11blackStartEnabledB\0\x12V\n\x18frequencySetPointEnabled\x18\x02\
    \x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x18frequencySetPointEnabledB\
    \0\x12=\n\npctHzDroop\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.FloatVal\
    ueR\npctHzDroopB\0\x12;\n\tpctVDroop\x18\x04\x20\x01(\x0b2\x1b.google.pr\
    otobuf.FloatValueR\tpctVDroopB\0\x126\n\trampRates\x18\x05\x20\x01(\x0b2\
    \x16.commonmodule.RampRateR\trampRatesB\0\x12Z\n\x1areactivePwrSetPointE\
    nabled\x18\x06\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1areactivePwr\
    SetPointEnabledB\0\x12R\n\x16realPwrSetPointEnabled\x18\x07\x20\x01(\x0b\
    2\x18.commonmodule.ControlDPCR\x16realPwrSetPointEnabledB\0\x128\n\x05st\
    ate\x18\x08\x20\x01(\x0b2\x20.commonmodule.Optional_StateKindR\x05stateB\
    \0\x12B\n\x0esyncBackToGrid\x18\t\x20\x01(\x0b2\x18.commonmodule.Control\
    DPCR\x0esyncBackToGridB\0\x12`\n\x1dtransToIslndOnGridLossEnabled\x18\n\
    \x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1dtransToIslndOnGridLossEna\
    bledB\0\x12R\n\x16voltageSetPointEnabled\x18\x0b\x20\x01(\x0b2\x18.commo\
    nmodule.ControlDPCR\x16voltageSetPointEnabledB\0:\0\"\xcb\x03\n\x1cGener\
    ationEventAndStatusZGEN\x12t\n\x1clogicalNodeForEventAndStatus\x18\x01\
    \x20\x01(\x0b2*.commonmodule.LogicalNodeForEventAndStatusR\x1clogicalNod\
    eForEventAndStatusB\x04\x80\xb5\x18\x01\x125\n\x08AuxPwrSt\x18\x02\x20\
    \x01(\x0b2\x17.commonmodule.StatusSPSR\x08AuxPwrStB\0\x12E\n\x0bDynamicT\
    est\x18\x03\x20\x01(\x0b2!.commonmodule.ENS_DynamicTestKindR\x0bDynamicT\
    estB\0\x123\n\x07EmgStop\x18\x04\x20\x01(\x0b2\x17.commonmodule.StatusSP\
    SR\x07EmgStopB\0\x123\n\x07GnSynSt\x18\x05\x20\x01(\x0b2\x17.commonmodul\
    e.StatusSPSR\x07GnSynStB\0\x12K\n\x0bPointStatus\x18\x06\x20\x01(\x0b2'.\
    generationmodule.GenerationPointStatusR\x0bPointStatusB\0:\0\"\x91\x01\n\
    \x13GenerationEventZGEN\x12x\n\x1cgenerationEventAndStatusZGEN\x18\x01\
    \x20\x01(\x0b2..generationmodule.GenerationEventAndStatusZGENR\x1cgenera\
    tionEventAndStatusZGENB\x04\x80\xb5\x18\x01:\0\"\xb6\x01\n\x0fGeneration\
    Event\x12>\n\neventValue\x18\x01\x20\x01(\x0b2\x18.commonmodule.EventVal\
    ueR\neventValueB\x04\x80\xb5\x18\x01\x12a\n\x13generationEventZGEN\x18\
    \x02\x20\x01(\x0b2%.generationmodule.GenerationEventZGENR\x13generationE\
    ventZGENB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xca\x02\n\x16Generati\
    onEventProfile\x12P\n\x10eventMessageInfo\x18\x01\x20\x01(\x0b2\x1e.comm\
    onmodule.EventMessageInfoR\x10eventMessageInfoB\x04\x80\xb5\x18\x01\x12R\
    \n\x0egeneratingUnit\x18\x02\x20\x01(\x0b2\x20.generationmodule.Generati\
    ngUnitR\x0egeneratingUnitB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12U\n\
    \x0fgenerationEvent\x18\x03\x20\x01(\x0b2!.generationmodule.GenerationEv\
    entR\x0fgenerationEventB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03i\
    ed\x18\x04\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\x92\x01\n\x14GenerationStatu\
    sZGEN\x12x\n\x1cgenerationEventAndStatusZGEN\x18\x01\x20\x01(\x0b2..gene\
    rationmodule.GenerationEventAndStatusZGENR\x1cgenerationEventAndStatusZG\
    ENB\x04\x80\xb5\x18\x01:\0\"\xbd\x01\n\x10GenerationStatus\x12A\n\x0bsta\
    tusValue\x18\x01\x20\x01(\x0b2\x19.commonmodule.StatusValueR\x0bstatusVa\
    lueB\x04\x80\xb5\x18\x01\x12d\n\x14generationStatusZGEN\x18\x02\x20\x01(\
    \x0b2&.generationmodule.GenerationStatusZGENR\x14generationStatusZGENB\
    \x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xd1\x02\n\x17GenerationStatusP\
    rofile\x12S\n\x11statusMessageInfo\x18\x01\x20\x01(\x0b2\x1f.commonmodul\
    e.StatusMessageInfoR\x11statusMessageInfoB\x04\x80\xb5\x18\x01\x12R\n\
    \x0egeneratingUnit\x18\x02\x20\x01(\x0b2\x20.generationmodule.Generating\
    UnitR\x0egeneratingUnitB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12X\n\x10g\
    enerationStatus\x18\x03\x20\x01(\x0b2\".generationmodule.GenerationStatu\
    sR\x10generationStatusB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ie\
    d\x18\x04\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\
    \x01\x90\xb5\x18\x01:\x04\xc0\xf3\x18\x01B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
