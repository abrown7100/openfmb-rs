// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `solarmodule/solarmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarPoint {
    // message fields
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    mode: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    reset: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    startTime: ::protobuf::SingularPtrField<super::commonmodule::ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarPoint {
    fn default() -> &'a SolarPoint {
        <SolarPoint as ::protobuf::Message>::default_instance()
    }
}

impl SolarPoint {
    pub fn new() -> SolarPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 1;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ENG_GridConnectModeKind mode = 2;


    pub fn get_mode(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.mode.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.mode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.mode.is_none() {
            self.mode.set_default();
        }
        self.mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_mode(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.mode.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 3;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 4;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 5;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC reset = 8;


    pub fn get_reset(&self) -> &super::commonmodule::ControlDPC {
        self.reset.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: super::commonmodule::ControlDPC) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> super::commonmodule::ControlDPC {
        self.reset.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 9;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 10;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlTimestamp startTime = 11;


    pub fn get_startTime(&self) -> &super::commonmodule::ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <super::commonmodule::ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::commonmodule::ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::commonmodule::ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::commonmodule::ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| super::commonmodule::ControlTimestamp::new())
    }
}

impl ::protobuf::Message for SolarPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mode.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarPoint {
        SolarPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &SolarPoint| { &m.frequencySetPointEnabled },
                |m: &mut SolarPoint| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "mode",
                |m: &SolarPoint| { &m.mode },
                |m: &mut SolarPoint| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &SolarPoint| { &m.pctHzDroop },
                |m: &mut SolarPoint| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &SolarPoint| { &m.pctVDroop },
                |m: &mut SolarPoint| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &SolarPoint| { &m.rampRates },
                |m: &mut SolarPoint| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &SolarPoint| { &m.reactivePwrSetPointEnabled },
                |m: &mut SolarPoint| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &SolarPoint| { &m.realPwrSetPointEnabled },
                |m: &mut SolarPoint| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reset",
                |m: &SolarPoint| { &m.reset },
                |m: &mut SolarPoint| { &mut m.reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &SolarPoint| { &m.state },
                |m: &mut SolarPoint| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &SolarPoint| { &m.voltageSetPointEnabled },
                |m: &mut SolarPoint| { &mut m.voltageSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlTimestamp>>(
                "startTime",
                |m: &SolarPoint| { &m.startTime },
                |m: &mut SolarPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarPoint>(
                "SolarPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarPoint {
        static instance: ::protobuf::rt::LazyV2<SolarPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarPoint::new)
    }
}

impl ::protobuf::Clear for SolarPoint {
    fn clear(&mut self) {
        self.frequencySetPointEnabled.clear();
        self.mode.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.reset.clear();
        self.state.clear();
        self.voltageSetPointEnabled.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<SolarPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarCSG {
    fn default() -> &'a SolarCSG {
        <SolarCSG as ::protobuf::Message>::default_instance()
    }
}

impl SolarCSG {
    pub fn new() -> SolarCSG {
        ::std::default::Default::default()
    }

    // repeated .solarmodule.SolarPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[SolarPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<SolarPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<SolarPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<SolarPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SolarCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarCSG {
        SolarCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarPoint>>(
                "crvPts",
                |m: &SolarCSG| { &m.crvPts },
                |m: &mut SolarCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarCSG>(
                "SolarCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarCSG {
        static instance: ::protobuf::rt::LazyV2<SolarCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarCSG::new)
    }
}

impl ::protobuf::Clear for SolarCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<SolarCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarControlScheduleFSCH {
    fn default() -> &'a SolarControlScheduleFSCH {
        <SolarControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl SolarControlScheduleFSCH {
    pub fn new() -> SolarControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .solarmodule.SolarCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &SolarCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <SolarCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: SolarCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut SolarCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> SolarCSG {
        self.ValDCSG.take().unwrap_or_else(|| SolarCSG::new())
    }
}

impl ::protobuf::Message for SolarControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarControlScheduleFSCH {
        SolarControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarCSG>>(
                "ValDCSG",
                |m: &SolarControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut SolarControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarControlScheduleFSCH>(
                "SolarControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<SolarControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for SolarControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarControlFSCC {
    // message fields
    controlFSCC: ::protobuf::SingularPtrField<super::commonmodule::ControlFSCC>,
    SolarControlScheduleFSCH: ::protobuf::SingularPtrField<SolarControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarControlFSCC {
    fn default() -> &'a SolarControlFSCC {
        <SolarControlFSCC as ::protobuf::Message>::default_instance()
    }
}

impl SolarControlFSCC {
    pub fn new() -> SolarControlFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlFSCC controlFSCC = 1;


    pub fn get_controlFSCC(&self) -> &super::commonmodule::ControlFSCC {
        self.controlFSCC.as_ref().unwrap_or_else(|| <super::commonmodule::ControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlFSCC(&mut self) {
        self.controlFSCC.clear();
    }

    pub fn has_controlFSCC(&self) -> bool {
        self.controlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlFSCC(&mut self, v: super::commonmodule::ControlFSCC) {
        self.controlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlFSCC(&mut self) -> &mut super::commonmodule::ControlFSCC {
        if self.controlFSCC.is_none() {
            self.controlFSCC.set_default();
        }
        self.controlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlFSCC(&mut self) -> super::commonmodule::ControlFSCC {
        self.controlFSCC.take().unwrap_or_else(|| super::commonmodule::ControlFSCC::new())
    }

    // .solarmodule.SolarControlScheduleFSCH SolarControlScheduleFSCH = 2;


    pub fn get_SolarControlScheduleFSCH(&self) -> &SolarControlScheduleFSCH {
        self.SolarControlScheduleFSCH.as_ref().unwrap_or_else(|| <SolarControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SolarControlScheduleFSCH(&mut self) {
        self.SolarControlScheduleFSCH.clear();
    }

    pub fn has_SolarControlScheduleFSCH(&self) -> bool {
        self.SolarControlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SolarControlScheduleFSCH(&mut self, v: SolarControlScheduleFSCH) {
        self.SolarControlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SolarControlScheduleFSCH(&mut self) -> &mut SolarControlScheduleFSCH {
        if self.SolarControlScheduleFSCH.is_none() {
            self.SolarControlScheduleFSCH.set_default();
        }
        self.SolarControlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_SolarControlScheduleFSCH(&mut self) -> SolarControlScheduleFSCH {
        self.SolarControlScheduleFSCH.take().unwrap_or_else(|| SolarControlScheduleFSCH::new())
    }
}

impl ::protobuf::Message for SolarControlFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.controlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SolarControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlFSCC)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SolarControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SolarControlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlFSCC.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SolarControlScheduleFSCH.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarControlFSCC {
        SolarControlFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlFSCC>>(
                "controlFSCC",
                |m: &SolarControlFSCC| { &m.controlFSCC },
                |m: &mut SolarControlFSCC| { &mut m.controlFSCC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarControlScheduleFSCH>>(
                "SolarControlScheduleFSCH",
                |m: &SolarControlFSCC| { &m.SolarControlScheduleFSCH },
                |m: &mut SolarControlFSCC| { &mut m.SolarControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarControlFSCC>(
                "SolarControlFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarControlFSCC {
        static instance: ::protobuf::rt::LazyV2<SolarControlFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarControlFSCC::new)
    }
}

impl ::protobuf::Clear for SolarControlFSCC {
    fn clear(&mut self) {
        self.controlFSCC.clear();
        self.SolarControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarControlFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarControlFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarControl {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    solarControlFSCC: ::protobuf::SingularPtrField<SolarControlFSCC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarControl {
    fn default() -> &'a SolarControl {
        <SolarControl as ::protobuf::Message>::default_instance()
    }
}

impl SolarControl {
    pub fn new() -> SolarControl {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .solarmodule.SolarControlFSCC solarControlFSCC = 3;


    pub fn get_solarControlFSCC(&self) -> &SolarControlFSCC {
        self.solarControlFSCC.as_ref().unwrap_or_else(|| <SolarControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarControlFSCC(&mut self) {
        self.solarControlFSCC.clear();
    }

    pub fn has_solarControlFSCC(&self) -> bool {
        self.solarControlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarControlFSCC(&mut self, v: SolarControlFSCC) {
        self.solarControlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarControlFSCC(&mut self) -> &mut SolarControlFSCC {
        if self.solarControlFSCC.is_none() {
            self.solarControlFSCC.set_default();
        }
        self.solarControlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarControlFSCC(&mut self) -> SolarControlFSCC {
        self.solarControlFSCC.take().unwrap_or_else(|| SolarControlFSCC::new())
    }
}

impl ::protobuf::Message for SolarControl {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarControlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarControlFSCC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarControlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarControlFSCC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarControl {
        SolarControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &SolarControl| { &m.controlValue },
                |m: &mut SolarControl| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &SolarControl| { &m.check },
                |m: &mut SolarControl| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarControlFSCC>>(
                "solarControlFSCC",
                |m: &SolarControl| { &m.solarControlFSCC },
                |m: &mut SolarControl| { &mut m.solarControlFSCC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarControl>(
                "SolarControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarControl {
        static instance: ::protobuf::rt::LazyV2<SolarControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarControl::new)
    }
}

impl ::protobuf::Clear for SolarControl {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.solarControlFSCC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarInverter {
    // message fields
    conductingEquipment: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarInverter {
    fn default() -> &'a SolarInverter {
        <SolarInverter as ::protobuf::Message>::default_instance()
    }
}

impl SolarInverter {
    pub fn new() -> SolarInverter {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipment conductingEquipment = 1;


    pub fn get_conductingEquipment(&self) -> &super::commonmodule::ConductingEquipment {
        self.conductingEquipment.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipment(&mut self) {
        self.conductingEquipment.clear();
    }

    pub fn has_conductingEquipment(&self) -> bool {
        self.conductingEquipment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipment(&mut self, v: super::commonmodule::ConductingEquipment) {
        self.conductingEquipment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipment(&mut self) -> &mut super::commonmodule::ConductingEquipment {
        if self.conductingEquipment.is_none() {
            self.conductingEquipment.set_default();
        }
        self.conductingEquipment.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipment(&mut self) -> super::commonmodule::ConductingEquipment {
        self.conductingEquipment.take().unwrap_or_else(|| super::commonmodule::ConductingEquipment::new())
    }
}

impl ::protobuf::Message for SolarInverter {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarInverter {
        SolarInverter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipment>>(
                "conductingEquipment",
                |m: &SolarInverter| { &m.conductingEquipment },
                |m: &mut SolarInverter| { &mut m.conductingEquipment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarInverter>(
                "SolarInverter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarInverter {
        static instance: ::protobuf::rt::LazyV2<SolarInverter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarInverter::new)
    }
}

impl ::protobuf::Clear for SolarInverter {
    fn clear(&mut self) {
        self.conductingEquipment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarInverter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarInverter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarControlProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    solarControl: ::protobuf::SingularPtrField<SolarControl>,
    solarInverter: ::protobuf::SingularPtrField<SolarInverter>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarControlProfile {
    fn default() -> &'a SolarControlProfile {
        <SolarControlProfile as ::protobuf::Message>::default_instance()
    }
}

impl SolarControlProfile {
    pub fn new() -> SolarControlProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.IED ied = 2;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .solarmodule.SolarControl solarControl = 3;


    pub fn get_solarControl(&self) -> &SolarControl {
        self.solarControl.as_ref().unwrap_or_else(|| <SolarControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarControl(&mut self) {
        self.solarControl.clear();
    }

    pub fn has_solarControl(&self) -> bool {
        self.solarControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarControl(&mut self, v: SolarControl) {
        self.solarControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarControl(&mut self) -> &mut SolarControl {
        if self.solarControl.is_none() {
            self.solarControl.set_default();
        }
        self.solarControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarControl(&mut self) -> SolarControl {
        self.solarControl.take().unwrap_or_else(|| SolarControl::new())
    }

    // .solarmodule.SolarInverter solarInverter = 4;


    pub fn get_solarInverter(&self) -> &SolarInverter {
        self.solarInverter.as_ref().unwrap_or_else(|| <SolarInverter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarInverter(&mut self) {
        self.solarInverter.clear();
    }

    pub fn has_solarInverter(&self) -> bool {
        self.solarInverter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarInverter(&mut self, v: SolarInverter) {
        self.solarInverter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarInverter(&mut self) -> &mut SolarInverter {
        if self.solarInverter.is_none() {
            self.solarInverter.set_default();
        }
        self.solarInverter.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarInverter(&mut self) -> SolarInverter {
        self.solarInverter.take().unwrap_or_else(|| SolarInverter::new())
    }
}

impl ::protobuf::Message for SolarControlProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarInverter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarControl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarInverter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarControl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarControlProfile {
        SolarControlProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &SolarControlProfile| { &m.controlMessageInfo },
                |m: &mut SolarControlProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &SolarControlProfile| { &m.ied },
                |m: &mut SolarControlProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarControl>>(
                "solarControl",
                |m: &SolarControlProfile| { &m.solarControl },
                |m: &mut SolarControlProfile| { &mut m.solarControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarInverter>>(
                "solarInverter",
                |m: &SolarControlProfile| { &m.solarInverter },
                |m: &mut SolarControlProfile| { &mut m.solarInverter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarControlProfile>(
                "SolarControlProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarControlProfile {
        static instance: ::protobuf::rt::LazyV2<SolarControlProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarControlProfile::new)
    }
}

impl ::protobuf::Clear for SolarControlProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.ied.clear();
        self.solarControl.clear();
        self.solarInverter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarControlProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarControlProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarPointStatus {
    // message fields
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    mode: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarPointStatus {
    fn default() -> &'a SolarPointStatus {
        <SolarPointStatus as ::protobuf::Message>::default_instance()
    }
}

impl SolarPointStatus {
    pub fn new() -> SolarPointStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 1;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ENG_GridConnectModeKind mode = 2;


    pub fn get_mode(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.mode.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.mode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.mode.is_none() {
            self.mode.set_default();
        }
        self.mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_mode(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.mode.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 3;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 4;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 5;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 6;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 7;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 8;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 9;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }
}

impl ::protobuf::Message for SolarPointStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mode.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarPointStatus {
        SolarPointStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &SolarPointStatus| { &m.frequencySetPointEnabled },
                |m: &mut SolarPointStatus| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "mode",
                |m: &SolarPointStatus| { &m.mode },
                |m: &mut SolarPointStatus| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &SolarPointStatus| { &m.pctHzDroop },
                |m: &mut SolarPointStatus| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &SolarPointStatus| { &m.pctVDroop },
                |m: &mut SolarPointStatus| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &SolarPointStatus| { &m.rampRates },
                |m: &mut SolarPointStatus| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &SolarPointStatus| { &m.reactivePwrSetPointEnabled },
                |m: &mut SolarPointStatus| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &SolarPointStatus| { &m.realPwrSetPointEnabled },
                |m: &mut SolarPointStatus| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &SolarPointStatus| { &m.state },
                |m: &mut SolarPointStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &SolarPointStatus| { &m.voltageSetPointEnabled },
                |m: &mut SolarPointStatus| { &mut m.voltageSetPointEnabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarPointStatus>(
                "SolarPointStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarPointStatus {
        static instance: ::protobuf::rt::LazyV2<SolarPointStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarPointStatus::new)
    }
}

impl ::protobuf::Clear for SolarPointStatus {
    fn clear(&mut self) {
        self.frequencySetPointEnabled.clear();
        self.mode.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.state.clear();
        self.voltageSetPointEnabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarPointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarPointStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarEventAndStatusZGEN {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    AuxPwrSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    DynamicTest: ::protobuf::SingularPtrField<super::commonmodule::ENS_DynamicTestKind>,
    EmgStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PointStatus: ::protobuf::SingularPtrField<SolarPointStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarEventAndStatusZGEN {
    fn default() -> &'a SolarEventAndStatusZGEN {
        <SolarEventAndStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl SolarEventAndStatusZGEN {
    pub fn new() -> SolarEventAndStatusZGEN {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.StatusSPS AuxPwrSt = 2;


    pub fn get_AuxPwrSt(&self) -> &super::commonmodule::StatusSPS {
        self.AuxPwrSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_AuxPwrSt(&mut self) {
        self.AuxPwrSt.clear();
    }

    pub fn has_AuxPwrSt(&self) -> bool {
        self.AuxPwrSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AuxPwrSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.AuxPwrSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AuxPwrSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.AuxPwrSt.is_none() {
            self.AuxPwrSt.set_default();
        }
        self.AuxPwrSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_AuxPwrSt(&mut self) -> super::commonmodule::StatusSPS {
        self.AuxPwrSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;


    pub fn get_DynamicTest(&self) -> &super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.as_ref().unwrap_or_else(|| <super::commonmodule::ENS_DynamicTestKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DynamicTest(&mut self) {
        self.DynamicTest.clear();
    }

    pub fn has_DynamicTest(&self) -> bool {
        self.DynamicTest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DynamicTest(&mut self, v: super::commonmodule::ENS_DynamicTestKind) {
        self.DynamicTest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DynamicTest(&mut self) -> &mut super::commonmodule::ENS_DynamicTestKind {
        if self.DynamicTest.is_none() {
            self.DynamicTest.set_default();
        }
        self.DynamicTest.as_mut().unwrap()
    }

    // Take field
    pub fn take_DynamicTest(&mut self) -> super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.take().unwrap_or_else(|| super::commonmodule::ENS_DynamicTestKind::new())
    }

    // .commonmodule.StatusSPS EmgStop = 4;


    pub fn get_EmgStop(&self) -> &super::commonmodule::StatusSPS {
        self.EmgStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_EmgStop(&mut self) {
        self.EmgStop.clear();
    }

    pub fn has_EmgStop(&self) -> bool {
        self.EmgStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EmgStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.EmgStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EmgStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.EmgStop.is_none() {
            self.EmgStop.set_default();
        }
        self.EmgStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_EmgStop(&mut self) -> super::commonmodule::StatusSPS {
        self.EmgStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .solarmodule.SolarPointStatus PointStatus = 5;


    pub fn get_PointStatus(&self) -> &SolarPointStatus {
        self.PointStatus.as_ref().unwrap_or_else(|| <SolarPointStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PointStatus(&mut self) {
        self.PointStatus.clear();
    }

    pub fn has_PointStatus(&self) -> bool {
        self.PointStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PointStatus(&mut self, v: SolarPointStatus) {
        self.PointStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PointStatus(&mut self) -> &mut SolarPointStatus {
        if self.PointStatus.is_none() {
            self.PointStatus.set_default();
        }
        self.PointStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_PointStatus(&mut self) -> SolarPointStatus {
        self.PointStatus.take().unwrap_or_else(|| SolarPointStatus::new())
    }
}

impl ::protobuf::Message for SolarEventAndStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.AuxPwrSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DynamicTest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EmgStop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PointStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AuxPwrSt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DynamicTest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EmgStop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PointStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarEventAndStatusZGEN {
        SolarEventAndStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &SolarEventAndStatusZGEN| { &m.logicalNodeForEventAndStatus },
                |m: &mut SolarEventAndStatusZGEN| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "AuxPwrSt",
                |m: &SolarEventAndStatusZGEN| { &m.AuxPwrSt },
                |m: &mut SolarEventAndStatusZGEN| { &mut m.AuxPwrSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENS_DynamicTestKind>>(
                "DynamicTest",
                |m: &SolarEventAndStatusZGEN| { &m.DynamicTest },
                |m: &mut SolarEventAndStatusZGEN| { &mut m.DynamicTest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "EmgStop",
                |m: &SolarEventAndStatusZGEN| { &m.EmgStop },
                |m: &mut SolarEventAndStatusZGEN| { &mut m.EmgStop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarPointStatus>>(
                "PointStatus",
                |m: &SolarEventAndStatusZGEN| { &m.PointStatus },
                |m: &mut SolarEventAndStatusZGEN| { &mut m.PointStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarEventAndStatusZGEN>(
                "SolarEventAndStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarEventAndStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<SolarEventAndStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarEventAndStatusZGEN::new)
    }
}

impl ::protobuf::Clear for SolarEventAndStatusZGEN {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.AuxPwrSt.clear();
        self.DynamicTest.clear();
        self.EmgStop.clear();
        self.PointStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarEventAndStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarEventAndStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarEventZGEN {
    // message fields
    solarEventAndStatusZGEN: ::protobuf::SingularPtrField<SolarEventAndStatusZGEN>,
    GriMod: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarEventZGEN {
    fn default() -> &'a SolarEventZGEN {
        <SolarEventZGEN as ::protobuf::Message>::default_instance()
    }
}

impl SolarEventZGEN {
    pub fn new() -> SolarEventZGEN {
        ::std::default::Default::default()
    }

    // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1;


    pub fn get_solarEventAndStatusZGEN(&self) -> &SolarEventAndStatusZGEN {
        self.solarEventAndStatusZGEN.as_ref().unwrap_or_else(|| <SolarEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarEventAndStatusZGEN(&mut self) {
        self.solarEventAndStatusZGEN.clear();
    }

    pub fn has_solarEventAndStatusZGEN(&self) -> bool {
        self.solarEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarEventAndStatusZGEN(&mut self, v: SolarEventAndStatusZGEN) {
        self.solarEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarEventAndStatusZGEN(&mut self) -> &mut SolarEventAndStatusZGEN {
        if self.solarEventAndStatusZGEN.is_none() {
            self.solarEventAndStatusZGEN.set_default();
        }
        self.solarEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarEventAndStatusZGEN(&mut self) -> SolarEventAndStatusZGEN {
        self.solarEventAndStatusZGEN.take().unwrap_or_else(|| SolarEventAndStatusZGEN::new())
    }

    // .commonmodule.ENG_GridConnectModeKind GriMod = 2;


    pub fn get_GriMod(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GriMod(&mut self) {
        self.GriMod.clear();
    }

    pub fn has_GriMod(&self) -> bool {
        self.GriMod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GriMod(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.GriMod = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GriMod(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.GriMod.is_none() {
            self.GriMod.set_default();
        }
        self.GriMod.as_mut().unwrap()
    }

    // Take field
    pub fn take_GriMod(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }
}

impl ::protobuf::Message for SolarEventZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.solarEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GriMod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarEventAndStatusZGEN)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GriMod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.solarEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.solarEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarEventZGEN {
        SolarEventZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarEventAndStatusZGEN>>(
                "solarEventAndStatusZGEN",
                |m: &SolarEventZGEN| { &m.solarEventAndStatusZGEN },
                |m: &mut SolarEventZGEN| { &mut m.solarEventAndStatusZGEN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "GriMod",
                |m: &SolarEventZGEN| { &m.GriMod },
                |m: &mut SolarEventZGEN| { &mut m.GriMod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarEventZGEN>(
                "SolarEventZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarEventZGEN {
        static instance: ::protobuf::rt::LazyV2<SolarEventZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarEventZGEN::new)
    }
}

impl ::protobuf::Clear for SolarEventZGEN {
    fn clear(&mut self) {
        self.solarEventAndStatusZGEN.clear();
        self.GriMod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarEventZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarEventZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarEvent {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    solarEventZGEN: ::protobuf::SingularPtrField<SolarEventZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarEvent {
    fn default() -> &'a SolarEvent {
        <SolarEvent as ::protobuf::Message>::default_instance()
    }
}

impl SolarEvent {
    pub fn new() -> SolarEvent {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .solarmodule.SolarEventZGEN solarEventZGEN = 2;


    pub fn get_solarEventZGEN(&self) -> &SolarEventZGEN {
        self.solarEventZGEN.as_ref().unwrap_or_else(|| <SolarEventZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarEventZGEN(&mut self) {
        self.solarEventZGEN.clear();
    }

    pub fn has_solarEventZGEN(&self) -> bool {
        self.solarEventZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarEventZGEN(&mut self, v: SolarEventZGEN) {
        self.solarEventZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarEventZGEN(&mut self) -> &mut SolarEventZGEN {
        if self.solarEventZGEN.is_none() {
            self.solarEventZGEN.set_default();
        }
        self.solarEventZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarEventZGEN(&mut self) -> SolarEventZGEN {
        self.solarEventZGEN.take().unwrap_or_else(|| SolarEventZGEN::new())
    }
}

impl ::protobuf::Message for SolarEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarEventZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarEventZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarEventZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarEventZGEN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarEvent {
        SolarEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &SolarEvent| { &m.eventValue },
                |m: &mut SolarEvent| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarEventZGEN>>(
                "solarEventZGEN",
                |m: &SolarEvent| { &m.solarEventZGEN },
                |m: &mut SolarEvent| { &mut m.solarEventZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarEvent>(
                "SolarEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarEvent {
        static instance: ::protobuf::rt::LazyV2<SolarEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarEvent::new)
    }
}

impl ::protobuf::Clear for SolarEvent {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.solarEventZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarEventProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    solarEvent: ::protobuf::SingularPtrField<SolarEvent>,
    solarInverter: ::protobuf::SingularPtrField<SolarInverter>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarEventProfile {
    fn default() -> &'a SolarEventProfile {
        <SolarEventProfile as ::protobuf::Message>::default_instance()
    }
}

impl SolarEventProfile {
    pub fn new() -> SolarEventProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .commonmodule.IED ied = 2;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .solarmodule.SolarEvent solarEvent = 3;


    pub fn get_solarEvent(&self) -> &SolarEvent {
        self.solarEvent.as_ref().unwrap_or_else(|| <SolarEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarEvent(&mut self) {
        self.solarEvent.clear();
    }

    pub fn has_solarEvent(&self) -> bool {
        self.solarEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarEvent(&mut self, v: SolarEvent) {
        self.solarEvent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarEvent(&mut self) -> &mut SolarEvent {
        if self.solarEvent.is_none() {
            self.solarEvent.set_default();
        }
        self.solarEvent.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarEvent(&mut self) -> SolarEvent {
        self.solarEvent.take().unwrap_or_else(|| SolarEvent::new())
    }

    // .solarmodule.SolarInverter solarInverter = 4;


    pub fn get_solarInverter(&self) -> &SolarInverter {
        self.solarInverter.as_ref().unwrap_or_else(|| <SolarInverter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarInverter(&mut self) {
        self.solarInverter.clear();
    }

    pub fn has_solarInverter(&self) -> bool {
        self.solarInverter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarInverter(&mut self, v: SolarInverter) {
        self.solarInverter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarInverter(&mut self) -> &mut SolarInverter {
        if self.solarInverter.is_none() {
            self.solarInverter.set_default();
        }
        self.solarInverter.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarInverter(&mut self) -> SolarInverter {
        self.solarInverter.take().unwrap_or_else(|| SolarInverter::new())
    }
}

impl ::protobuf::Message for SolarEventProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarInverter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarEvent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarInverter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarEvent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarEvent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarEventProfile {
        SolarEventProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &SolarEventProfile| { &m.eventMessageInfo },
                |m: &mut SolarEventProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &SolarEventProfile| { &m.ied },
                |m: &mut SolarEventProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarEvent>>(
                "solarEvent",
                |m: &SolarEventProfile| { &m.solarEvent },
                |m: &mut SolarEventProfile| { &mut m.solarEvent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarInverter>>(
                "solarInverter",
                |m: &SolarEventProfile| { &m.solarInverter },
                |m: &mut SolarEventProfile| { &mut m.solarInverter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarEventProfile>(
                "SolarEventProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarEventProfile {
        static instance: ::protobuf::rt::LazyV2<SolarEventProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarEventProfile::new)
    }
}

impl ::protobuf::Clear for SolarEventProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.ied.clear();
        self.solarEvent.clear();
        self.solarInverter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarEventProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarEventProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarReading {
    // message fields
    conductingEquipmentTerminalReading: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipmentTerminalReading>,
    phaseMMTN: ::protobuf::SingularPtrField<super::commonmodule::PhaseMMTN>,
    readingMMTR: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMTR>,
    readingMMXU: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMXU>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarReading {
    fn default() -> &'a SolarReading {
        <SolarReading as ::protobuf::Message>::default_instance()
    }
}

impl SolarReading {
    pub fn new() -> SolarReading {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1;


    pub fn get_conductingEquipmentTerminalReading(&self) -> &super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipmentTerminalReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipmentTerminalReading(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
    }

    pub fn has_conductingEquipmentTerminalReading(&self) -> bool {
        self.conductingEquipmentTerminalReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipmentTerminalReading(&mut self, v: super::commonmodule::ConductingEquipmentTerminalReading) {
        self.conductingEquipmentTerminalReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipmentTerminalReading(&mut self) -> &mut super::commonmodule::ConductingEquipmentTerminalReading {
        if self.conductingEquipmentTerminalReading.is_none() {
            self.conductingEquipmentTerminalReading.set_default();
        }
        self.conductingEquipmentTerminalReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipmentTerminalReading(&mut self) -> super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.take().unwrap_or_else(|| super::commonmodule::ConductingEquipmentTerminalReading::new())
    }

    // .commonmodule.PhaseMMTN phaseMMTN = 2;


    pub fn get_phaseMMTN(&self) -> &super::commonmodule::PhaseMMTN {
        self.phaseMMTN.as_ref().unwrap_or_else(|| <super::commonmodule::PhaseMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phaseMMTN(&mut self) {
        self.phaseMMTN.clear();
    }

    pub fn has_phaseMMTN(&self) -> bool {
        self.phaseMMTN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phaseMMTN(&mut self, v: super::commonmodule::PhaseMMTN) {
        self.phaseMMTN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phaseMMTN(&mut self) -> &mut super::commonmodule::PhaseMMTN {
        if self.phaseMMTN.is_none() {
            self.phaseMMTN.set_default();
        }
        self.phaseMMTN.as_mut().unwrap()
    }

    // Take field
    pub fn take_phaseMMTN(&mut self) -> super::commonmodule::PhaseMMTN {
        self.phaseMMTN.take().unwrap_or_else(|| super::commonmodule::PhaseMMTN::new())
    }

    // .commonmodule.ReadingMMTR readingMMTR = 3;


    pub fn get_readingMMTR(&self) -> &super::commonmodule::ReadingMMTR {
        self.readingMMTR.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMTR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMTR(&mut self) {
        self.readingMMTR.clear();
    }

    pub fn has_readingMMTR(&self) -> bool {
        self.readingMMTR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMTR(&mut self, v: super::commonmodule::ReadingMMTR) {
        self.readingMMTR = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMTR(&mut self) -> &mut super::commonmodule::ReadingMMTR {
        if self.readingMMTR.is_none() {
            self.readingMMTR.set_default();
        }
        self.readingMMTR.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMTR(&mut self) -> super::commonmodule::ReadingMMTR {
        self.readingMMTR.take().unwrap_or_else(|| super::commonmodule::ReadingMMTR::new())
    }

    // .commonmodule.ReadingMMXU readingMMXU = 4;


    pub fn get_readingMMXU(&self) -> &super::commonmodule::ReadingMMXU {
        self.readingMMXU.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMXU as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMXU(&mut self) {
        self.readingMMXU.clear();
    }

    pub fn has_readingMMXU(&self) -> bool {
        self.readingMMXU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMXU(&mut self, v: super::commonmodule::ReadingMMXU) {
        self.readingMMXU = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMXU(&mut self) -> &mut super::commonmodule::ReadingMMXU {
        if self.readingMMXU.is_none() {
            self.readingMMXU.set_default();
        }
        self.readingMMXU.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMXU(&mut self) -> super::commonmodule::ReadingMMXU {
        self.readingMMXU.take().unwrap_or_else(|| super::commonmodule::ReadingMMXU::new())
    }
}

impl ::protobuf::Message for SolarReading {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipmentTerminalReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phaseMMTN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMTR {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMXU {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipmentTerminalReading)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phaseMMTN)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMTR)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMXU)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarReading {
        SolarReading::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipmentTerminalReading>>(
                "conductingEquipmentTerminalReading",
                |m: &SolarReading| { &m.conductingEquipmentTerminalReading },
                |m: &mut SolarReading| { &mut m.conductingEquipmentTerminalReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::PhaseMMTN>>(
                "phaseMMTN",
                |m: &SolarReading| { &m.phaseMMTN },
                |m: &mut SolarReading| { &mut m.phaseMMTN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMTR>>(
                "readingMMTR",
                |m: &SolarReading| { &m.readingMMTR },
                |m: &mut SolarReading| { &mut m.readingMMTR },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMXU>>(
                "readingMMXU",
                |m: &SolarReading| { &m.readingMMXU },
                |m: &mut SolarReading| { &mut m.readingMMXU },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarReading>(
                "SolarReading",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarReading {
        static instance: ::protobuf::rt::LazyV2<SolarReading> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarReading::new)
    }
}

impl ::protobuf::Clear for SolarReading {
    fn clear(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
        self.phaseMMTN.clear();
        self.readingMMTR.clear();
        self.readingMMXU.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarReading {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarReadingProfile {
    // message fields
    readingMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ReadingMessageInfo>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    solarInverter: ::protobuf::SingularPtrField<SolarInverter>,
    solarReading: ::protobuf::SingularPtrField<SolarReading>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarReadingProfile {
    fn default() -> &'a SolarReadingProfile {
        <SolarReadingProfile as ::protobuf::Message>::default_instance()
    }
}

impl SolarReadingProfile {
    pub fn new() -> SolarReadingProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ReadingMessageInfo readingMessageInfo = 1;


    pub fn get_readingMessageInfo(&self) -> &super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMessageInfo(&mut self) {
        self.readingMessageInfo.clear();
    }

    pub fn has_readingMessageInfo(&self) -> bool {
        self.readingMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMessageInfo(&mut self, v: super::commonmodule::ReadingMessageInfo) {
        self.readingMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMessageInfo(&mut self) -> &mut super::commonmodule::ReadingMessageInfo {
        if self.readingMessageInfo.is_none() {
            self.readingMessageInfo.set_default();
        }
        self.readingMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMessageInfo(&mut self) -> super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.take().unwrap_or_else(|| super::commonmodule::ReadingMessageInfo::new())
    }

    // .commonmodule.IED ied = 2;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .solarmodule.SolarInverter solarInverter = 3;


    pub fn get_solarInverter(&self) -> &SolarInverter {
        self.solarInverter.as_ref().unwrap_or_else(|| <SolarInverter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarInverter(&mut self) {
        self.solarInverter.clear();
    }

    pub fn has_solarInverter(&self) -> bool {
        self.solarInverter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarInverter(&mut self, v: SolarInverter) {
        self.solarInverter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarInverter(&mut self) -> &mut SolarInverter {
        if self.solarInverter.is_none() {
            self.solarInverter.set_default();
        }
        self.solarInverter.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarInverter(&mut self) -> SolarInverter {
        self.solarInverter.take().unwrap_or_else(|| SolarInverter::new())
    }

    // .solarmodule.SolarReading solarReading = 4;


    pub fn get_solarReading(&self) -> &SolarReading {
        self.solarReading.as_ref().unwrap_or_else(|| <SolarReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarReading(&mut self) {
        self.solarReading.clear();
    }

    pub fn has_solarReading(&self) -> bool {
        self.solarReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarReading(&mut self, v: SolarReading) {
        self.solarReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarReading(&mut self) -> &mut SolarReading {
        if self.solarReading.is_none() {
            self.solarReading.set_default();
        }
        self.solarReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarReading(&mut self) -> SolarReading {
        self.solarReading.take().unwrap_or_else(|| SolarReading::new())
    }
}

impl ::protobuf::Message for SolarReadingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.readingMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarInverter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarReading {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarInverter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarReading)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarReading.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarReadingProfile {
        SolarReadingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMessageInfo>>(
                "readingMessageInfo",
                |m: &SolarReadingProfile| { &m.readingMessageInfo },
                |m: &mut SolarReadingProfile| { &mut m.readingMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &SolarReadingProfile| { &m.ied },
                |m: &mut SolarReadingProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarInverter>>(
                "solarInverter",
                |m: &SolarReadingProfile| { &m.solarInverter },
                |m: &mut SolarReadingProfile| { &mut m.solarInverter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarReading>>(
                "solarReading",
                |m: &SolarReadingProfile| { &m.solarReading },
                |m: &mut SolarReadingProfile| { &mut m.solarReading },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarReadingProfile>(
                "SolarReadingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarReadingProfile {
        static instance: ::protobuf::rt::LazyV2<SolarReadingProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarReadingProfile::new)
    }
}

impl ::protobuf::Clear for SolarReadingProfile {
    fn clear(&mut self) {
        self.readingMessageInfo.clear();
        self.ied.clear();
        self.solarInverter.clear();
        self.solarReading.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarReadingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarReadingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarStatusZGEN {
    // message fields
    solarEventAndStatusZGEN: ::protobuf::SingularPtrField<SolarEventAndStatusZGEN>,
    GriMod: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarStatusZGEN {
    fn default() -> &'a SolarStatusZGEN {
        <SolarStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl SolarStatusZGEN {
    pub fn new() -> SolarStatusZGEN {
        ::std::default::Default::default()
    }

    // .solarmodule.SolarEventAndStatusZGEN solarEventAndStatusZGEN = 1;


    pub fn get_solarEventAndStatusZGEN(&self) -> &SolarEventAndStatusZGEN {
        self.solarEventAndStatusZGEN.as_ref().unwrap_or_else(|| <SolarEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarEventAndStatusZGEN(&mut self) {
        self.solarEventAndStatusZGEN.clear();
    }

    pub fn has_solarEventAndStatusZGEN(&self) -> bool {
        self.solarEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarEventAndStatusZGEN(&mut self, v: SolarEventAndStatusZGEN) {
        self.solarEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarEventAndStatusZGEN(&mut self) -> &mut SolarEventAndStatusZGEN {
        if self.solarEventAndStatusZGEN.is_none() {
            self.solarEventAndStatusZGEN.set_default();
        }
        self.solarEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarEventAndStatusZGEN(&mut self) -> SolarEventAndStatusZGEN {
        self.solarEventAndStatusZGEN.take().unwrap_or_else(|| SolarEventAndStatusZGEN::new())
    }

    // .commonmodule.ENG_GridConnectModeKind GriMod = 2;


    pub fn get_GriMod(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GriMod(&mut self) {
        self.GriMod.clear();
    }

    pub fn has_GriMod(&self) -> bool {
        self.GriMod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GriMod(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.GriMod = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GriMod(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.GriMod.is_none() {
            self.GriMod.set_default();
        }
        self.GriMod.as_mut().unwrap()
    }

    // Take field
    pub fn take_GriMod(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }
}

impl ::protobuf::Message for SolarStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.solarEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GriMod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarEventAndStatusZGEN)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GriMod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.solarEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.solarEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarStatusZGEN {
        SolarStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarEventAndStatusZGEN>>(
                "solarEventAndStatusZGEN",
                |m: &SolarStatusZGEN| { &m.solarEventAndStatusZGEN },
                |m: &mut SolarStatusZGEN| { &mut m.solarEventAndStatusZGEN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "GriMod",
                |m: &SolarStatusZGEN| { &m.GriMod },
                |m: &mut SolarStatusZGEN| { &mut m.GriMod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarStatusZGEN>(
                "SolarStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<SolarStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarStatusZGEN::new)
    }
}

impl ::protobuf::Clear for SolarStatusZGEN {
    fn clear(&mut self) {
        self.solarEventAndStatusZGEN.clear();
        self.GriMod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarStatus {
    // message fields
    statusValue: ::protobuf::SingularPtrField<super::commonmodule::StatusValue>,
    solarStatusZGEN: ::protobuf::SingularPtrField<SolarStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarStatus {
    fn default() -> &'a SolarStatus {
        <SolarStatus as ::protobuf::Message>::default_instance()
    }
}

impl SolarStatus {
    pub fn new() -> SolarStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusValue statusValue = 1;


    pub fn get_statusValue(&self) -> &super::commonmodule::StatusValue {
        self.statusValue.as_ref().unwrap_or_else(|| <super::commonmodule::StatusValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusValue(&mut self) {
        self.statusValue.clear();
    }

    pub fn has_statusValue(&self) -> bool {
        self.statusValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusValue(&mut self, v: super::commonmodule::StatusValue) {
        self.statusValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusValue(&mut self) -> &mut super::commonmodule::StatusValue {
        if self.statusValue.is_none() {
            self.statusValue.set_default();
        }
        self.statusValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusValue(&mut self) -> super::commonmodule::StatusValue {
        self.statusValue.take().unwrap_or_else(|| super::commonmodule::StatusValue::new())
    }

    // .solarmodule.SolarStatusZGEN solarStatusZGEN = 2;


    pub fn get_solarStatusZGEN(&self) -> &SolarStatusZGEN {
        self.solarStatusZGEN.as_ref().unwrap_or_else(|| <SolarStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarStatusZGEN(&mut self) {
        self.solarStatusZGEN.clear();
    }

    pub fn has_solarStatusZGEN(&self) -> bool {
        self.solarStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarStatusZGEN(&mut self, v: SolarStatusZGEN) {
        self.solarStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarStatusZGEN(&mut self) -> &mut SolarStatusZGEN {
        if self.solarStatusZGEN.is_none() {
            self.solarStatusZGEN.set_default();
        }
        self.solarStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarStatusZGEN(&mut self) -> SolarStatusZGEN {
        self.solarStatusZGEN.take().unwrap_or_else(|| SolarStatusZGEN::new())
    }
}

impl ::protobuf::Message for SolarStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.statusValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarStatusZGEN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarStatus {
        SolarStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusValue>>(
                "statusValue",
                |m: &SolarStatus| { &m.statusValue },
                |m: &mut SolarStatus| { &mut m.statusValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarStatusZGEN>>(
                "solarStatusZGEN",
                |m: &SolarStatus| { &m.solarStatusZGEN },
                |m: &mut SolarStatus| { &mut m.solarStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarStatus>(
                "SolarStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarStatus {
        static instance: ::protobuf::rt::LazyV2<SolarStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarStatus::new)
    }
}

impl ::protobuf::Clear for SolarStatus {
    fn clear(&mut self) {
        self.statusValue.clear();
        self.solarStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SolarStatusProfile {
    // message fields
    statusMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::StatusMessageInfo>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    solarInverter: ::protobuf::SingularPtrField<SolarInverter>,
    solarStatus: ::protobuf::SingularPtrField<SolarStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SolarStatusProfile {
    fn default() -> &'a SolarStatusProfile {
        <SolarStatusProfile as ::protobuf::Message>::default_instance()
    }
}

impl SolarStatusProfile {
    pub fn new() -> SolarStatusProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusMessageInfo statusMessageInfo = 1;


    pub fn get_statusMessageInfo(&self) -> &super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::StatusMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusMessageInfo(&mut self) {
        self.statusMessageInfo.clear();
    }

    pub fn has_statusMessageInfo(&self) -> bool {
        self.statusMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusMessageInfo(&mut self, v: super::commonmodule::StatusMessageInfo) {
        self.statusMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusMessageInfo(&mut self) -> &mut super::commonmodule::StatusMessageInfo {
        if self.statusMessageInfo.is_none() {
            self.statusMessageInfo.set_default();
        }
        self.statusMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusMessageInfo(&mut self) -> super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.take().unwrap_or_else(|| super::commonmodule::StatusMessageInfo::new())
    }

    // .commonmodule.IED ied = 2;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .solarmodule.SolarInverter solarInverter = 3;


    pub fn get_solarInverter(&self) -> &SolarInverter {
        self.solarInverter.as_ref().unwrap_or_else(|| <SolarInverter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarInverter(&mut self) {
        self.solarInverter.clear();
    }

    pub fn has_solarInverter(&self) -> bool {
        self.solarInverter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarInverter(&mut self, v: SolarInverter) {
        self.solarInverter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarInverter(&mut self) -> &mut SolarInverter {
        if self.solarInverter.is_none() {
            self.solarInverter.set_default();
        }
        self.solarInverter.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarInverter(&mut self) -> SolarInverter {
        self.solarInverter.take().unwrap_or_else(|| SolarInverter::new())
    }

    // .solarmodule.SolarStatus solarStatus = 4;


    pub fn get_solarStatus(&self) -> &SolarStatus {
        self.solarStatus.as_ref().unwrap_or_else(|| <SolarStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solarStatus(&mut self) {
        self.solarStatus.clear();
    }

    pub fn has_solarStatus(&self) -> bool {
        self.solarStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solarStatus(&mut self, v: SolarStatus) {
        self.solarStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solarStatus(&mut self) -> &mut SolarStatus {
        if self.solarStatus.is_none() {
            self.solarStatus.set_default();
        }
        self.solarStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_solarStatus(&mut self) -> SolarStatus {
        self.solarStatus.take().unwrap_or_else(|| SolarStatus::new())
    }
}

impl ::protobuf::Message for SolarStatusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.statusMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarInverter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solarStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarInverter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solarStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solarStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarInverter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solarStatus.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SolarStatusProfile {
        SolarStatusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusMessageInfo>>(
                "statusMessageInfo",
                |m: &SolarStatusProfile| { &m.statusMessageInfo },
                |m: &mut SolarStatusProfile| { &mut m.statusMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &SolarStatusProfile| { &m.ied },
                |m: &mut SolarStatusProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarInverter>>(
                "solarInverter",
                |m: &SolarStatusProfile| { &m.solarInverter },
                |m: &mut SolarStatusProfile| { &mut m.solarInverter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SolarStatus>>(
                "solarStatus",
                |m: &SolarStatusProfile| { &m.solarStatus },
                |m: &mut SolarStatusProfile| { &mut m.solarStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SolarStatusProfile>(
                "SolarStatusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SolarStatusProfile {
        static instance: ::protobuf::rt::LazyV2<SolarStatusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SolarStatusProfile::new)
    }
}

impl ::protobuf::Clear for SolarStatusProfile {
    fn clear(&mut self) {
        self.statusMessageInfo.clear();
        self.ied.clear();
        self.solarInverter.clear();
        self.solarStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SolarStatusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SolarStatusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dsolarmodule/solarmodule.proto\x12\x0bsolarmodule\"\x8f\x06\n\nSola\
    rPoint\x12V\n\x18frequencySetPointEnabled\x18\x01\x20\x01(\x0b2\x18.comm\
    onmodule.ControlDPCR\x18frequencySetPointEnabledB\0\x12;\n\x04mode\x18\
    \x02\x20\x01(\x0b2%.commonmodule.ENG_GridConnectModeKindR\x04modeB\0\x12\
    =\n\npctHzDroop\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\np\
    ctHzDroopB\0\x12;\n\tpctVDroop\x18\x04\x20\x01(\x0b2\x1b.google.protobuf\
    .FloatValueR\tpctVDroopB\0\x126\n\trampRates\x18\x05\x20\x01(\x0b2\x16.c\
    ommonmodule.RampRateR\trampRatesB\0\x12Z\n\x1areactivePwrSetPointEnabled\
    \x18\x06\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1areactivePwrSetPoi\
    ntEnabledB\0\x12R\n\x16realPwrSetPointEnabled\x18\x07\x20\x01(\x0b2\x18.\
    commonmodule.ControlDPCR\x16realPwrSetPointEnabledB\0\x120\n\x05reset\
    \x18\x08\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x05resetB\0\x128\n\
    \x05state\x18\t\x20\x01(\x0b2\x20.commonmodule.Optional_StateKindR\x05st\
    ateB\0\x12R\n\x16voltageSetPointEnabled\x18\n\x20\x01(\x0b2\x18.commonmo\
    dule.ControlDPCR\x16voltageSetPointEnabledB\0\x12F\n\tstartTime\x18\x0b\
    \x20\x01(\x0b2\x1e.commonmodule.ControlTimestampR\tstartTimeB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01:\0\"G\n\x08SolarCSG\x129\n\x06crvPts\x18\
    \x01\x20\x03(\x0b2\x17.solarmodule.SolarPointR\x06crvPtsB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"W\n\x18SolarControlScheduleFSCH\x129\n\x07V\
    alDCSG\x18\x01\x20\x01(\x0b2\x15.solarmodule.SolarCSGR\x07ValDCSGB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xbc\x01\n\x10SolarControlFSCC\x12A\
    \n\x0bcontrolFSCC\x18\x01\x20\x01(\x0b2\x19.commonmodule.ControlFSCCR\
    \x0bcontrolFSCCB\x04\x80\xb5\x18\x01\x12c\n\x18SolarControlScheduleFSCH\
    \x18\x02\x20\x01(\x0b2%.solarmodule.SolarControlScheduleFSCHR\x18SolarCo\
    ntrolScheduleFSCHB\0:\0\"\xda\x01\n\x0cSolarControl\x12D\n\x0ccontrolVal\
    ue\x18\x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\x0ccontrolValueB\
    \x04\x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\x0b2\x1d.commonmod\
    ule.CheckConditionsR\x05checkB\0\x12K\n\x10solarControlFSCC\x18\x03\x20\
    \x01(\x0b2\x1d.solarmodule.SolarControlFSCCR\x10solarControlFSCCB\0:\0\"\
    l\n\rSolarInverter\x12Y\n\x13conductingEquipment\x18\x01\x20\x01(\x0b2!.\
    commonmodule.ConductingEquipmentR\x13conductingEquipmentB\x04\x80\xb5\
    \x18\x01:\0\"\xb7\x02\n\x13SolarControlProfile\x12V\n\x12controlMessageI\
    nfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ControlMessageInfoR\x12contro\
    lMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03ied\x18\x02\x20\x01(\x0b2\
    \x11.commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12G\
    \n\x0csolarControl\x18\x03\x20\x01(\x0b2\x19.solarmodule.SolarControlR\
    \x0csolarControlB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12J\n\rsolarInver\
    ter\x18\x04\x20\x01(\x0b2\x1a.solarmodule.SolarInverterR\rsolarInverterB\
    \x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\x9b\x05\n\
    \x10SolarPointStatus\x12V\n\x18frequencySetPointEnabled\x18\x01\x20\x01(\
    \x0b2\x18.commonmodule.ControlDPCR\x18frequencySetPointEnabledB\0\x12;\n\
    \x04mode\x18\x02\x20\x01(\x0b2%.commonmodule.ENG_GridConnectModeKindR\
    \x04modeB\0\x12=\n\npctHzDroop\x18\x03\x20\x01(\x0b2\x1b.google.protobuf\
    .FloatValueR\npctHzDroopB\0\x12;\n\tpctVDroop\x18\x04\x20\x01(\x0b2\x1b.\
    google.protobuf.FloatValueR\tpctVDroopB\0\x126\n\trampRates\x18\x05\x20\
    \x01(\x0b2\x16.commonmodule.RampRateR\trampRatesB\0\x12Z\n\x1areactivePw\
    rSetPointEnabled\x18\x06\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1ar\
    eactivePwrSetPointEnabledB\0\x12R\n\x16realPwrSetPointEnabled\x18\x07\
    \x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16realPwrSetPointEnabledB\0\
    \x128\n\x05state\x18\x08\x20\x01(\x0b2\x20.commonmodule.Optional_StateKi\
    ndR\x05stateB\0\x12R\n\x16voltageSetPointEnabled\x18\t\x20\x01(\x0b2\x18\
    .commonmodule.ControlDPCR\x16voltageSetPointEnabledB\0:\0\"\x87\x03\n\
    \x17SolarEventAndStatusZGEN\x12t\n\x1clogicalNodeForEventAndStatus\x18\
    \x01\x20\x01(\x0b2*.commonmodule.LogicalNodeForEventAndStatusR\x1clogica\
    lNodeForEventAndStatusB\x04\x80\xb5\x18\x01\x125\n\x08AuxPwrSt\x18\x02\
    \x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x08AuxPwrStB\0\x12E\n\x0bDyna\
    micTest\x18\x03\x20\x01(\x0b2!.commonmodule.ENS_DynamicTestKindR\x0bDyna\
    micTestB\0\x123\n\x07EmgStop\x18\x04\x20\x01(\x0b2\x17.commonmodule.Stat\
    usSPSR\x07EmgStopB\0\x12A\n\x0bPointStatus\x18\x05\x20\x01(\x0b2\x1d.sol\
    armodule.SolarPointStatusR\x0bPointStatusB\0:\0\"\xb9\x01\n\x0eSolarEven\
    tZGEN\x12d\n\x17solarEventAndStatusZGEN\x18\x01\x20\x01(\x0b2$.solarmodu\
    le.SolarEventAndStatusZGENR\x17solarEventAndStatusZGENB\x04\x80\xb5\x18\
    \x01\x12?\n\x06GriMod\x18\x02\x20\x01(\x0b2%.commonmodule.ENG_GridConnec\
    tModeKindR\x06GriModB\0:\0\"\x9d\x01\n\nSolarEvent\x12>\n\neventValue\
    \x18\x01\x20\x01(\x0b2\x18.commonmodule.EventValueR\neventValueB\x04\x80\
    \xb5\x18\x01\x12M\n\x0esolarEventZGEN\x18\x02\x20\x01(\x0b2\x1b.solarmod\
    ule.SolarEventZGENR\x0esolarEventZGENB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01:\0\"\xa9\x02\n\x11SolarEventProfile\x12P\n\x10eventMessageInfo\x18\
    \x01\x20\x01(\x0b2\x1e.commonmodule.EventMessageInfoR\x10eventMessageInf\
    oB\x04\x80\xb5\x18\x01\x12-\n\x03ied\x18\x02\x20\x01(\x0b2\x11.commonmod\
    ule.IEDR\x03iedB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12A\n\nsolarEvent\
    \x18\x03\x20\x01(\x0b2\x17.solarmodule.SolarEventR\nsolarEventB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01\x12J\n\rsolarInverter\x18\x04\x20\x01(\x0b2\
    \x1a.solarmodule.SolarInverterR\rsolarInverterB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\xd0\x02\n\x0cSolarReading\x12\x86\
    \x01\n\"conductingEquipmentTerminalReading\x18\x01\x20\x01(\x0b20.common\
    module.ConductingEquipmentTerminalReadingR\"conductingEquipmentTerminalR\
    eadingB\x04\x80\xb5\x18\x01\x127\n\tphaseMMTN\x18\x02\x20\x01(\x0b2\x17.\
    commonmodule.PhaseMMTNR\tphaseMMTNB\0\x12=\n\x0breadingMMTR\x18\x03\x20\
    \x01(\x0b2\x19.commonmodule.ReadingMMTRR\x0breadingMMTRB\0\x12=\n\x0brea\
    dingMMXU\x18\x04\x20\x01(\x0b2\x19.commonmodule.ReadingMMXUR\x0breadingM\
    MXUB\0:\0\"\xb7\x02\n\x13SolarReadingProfile\x12V\n\x12readingMessageInf\
    o\x18\x01\x20\x01(\x0b2\x20.commonmodule.ReadingMessageInfoR\x12readingM\
    essageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03ied\x18\x02\x20\x01(\x0b2\x11.\
    commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12J\n\rso\
    larInverter\x18\x03\x20\x01(\x0b2\x1a.solarmodule.SolarInverterR\rsolarI\
    nverterB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12G\n\x0csolarReading\x18\
    \x04\x20\x01(\x0b2\x19.solarmodule.SolarReadingR\x0csolarReadingB\x08\
    \x90\xb5\x18\x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\xba\x01\n\x0fSol\
    arStatusZGEN\x12d\n\x17solarEventAndStatusZGEN\x18\x01\x20\x01(\x0b2$.so\
    larmodule.SolarEventAndStatusZGENR\x17solarEventAndStatusZGENB\x04\x80\
    \xb5\x18\x01\x12?\n\x06GriMod\x18\x02\x20\x01(\x0b2%.commonmodule.ENG_Gr\
    idConnectModeKindR\x06GriModB\0:\0\"\xa4\x01\n\x0bSolarStatus\x12A\n\x0b\
    statusValue\x18\x01\x20\x01(\x0b2\x19.commonmodule.StatusValueR\x0bstatu\
    sValueB\x04\x80\xb5\x18\x01\x12P\n\x0fsolarStatusZGEN\x18\x02\x20\x01(\
    \x0b2\x1c.solarmodule.SolarStatusZGENR\x0fsolarStatusZGENB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"\xb0\x02\n\x12SolarStatusProfile\x12S\n\x11\
    statusMessageInfo\x18\x01\x20\x01(\x0b2\x1f.commonmodule.StatusMessageIn\
    foR\x11statusMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03ied\x18\x02\x20\
    \x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12J\n\rsolarInverter\x18\x03\x20\x01(\x0b2\x1a.solarmodule.SolarIn\
    verterR\rsolarInverterB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12D\n\x0bso\
    larStatus\x18\x04\x20\x01(\x0b2\x18.solarmodule.SolarStatusR\x0bsolarSta\
    tusB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\xf3\x18\x01B\0b\x06pro\
    to3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
