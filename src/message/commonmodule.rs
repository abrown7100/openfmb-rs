// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `commonmodule/commonmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IdentifiedObject {
    // message fields
    description: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    mRID: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    name: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdentifiedObject {
    fn default() -> &'a IdentifiedObject {
        <IdentifiedObject as ::protobuf::Message>::default_instance()
    }
}

impl IdentifiedObject {
    pub fn new() -> IdentifiedObject {
        ::std::default::Default::default()
    }

    // .google.protobuf.StringValue description = 1;


    pub fn get_description(&self) -> &::protobuf::well_known_types::StringValue {
        self.description.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.description.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    // .google.protobuf.StringValue mRID = 2;


    pub fn get_mRID(&self) -> &::protobuf::well_known_types::StringValue {
        self.mRID.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mRID(&mut self) {
        self.mRID.clear();
    }

    pub fn has_mRID(&self) -> bool {
        self.mRID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mRID(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.mRID = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mRID(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.mRID.is_none() {
            self.mRID.set_default();
        }
        self.mRID.as_mut().unwrap()
    }

    // Take field
    pub fn take_mRID(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.mRID.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    // .google.protobuf.StringValue name = 3;


    pub fn get_name(&self) -> &::protobuf::well_known_types::StringValue {
        self.name.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.name.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }
}

impl ::protobuf::Message for IdentifiedObject {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mRID {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mRID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mRID.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mRID.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentifiedObject {
        IdentifiedObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "description",
                |m: &IdentifiedObject| { &m.description },
                |m: &mut IdentifiedObject| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "mRID",
                |m: &IdentifiedObject| { &m.mRID },
                |m: &mut IdentifiedObject| { &mut m.mRID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "name",
                |m: &IdentifiedObject| { &m.name },
                |m: &mut IdentifiedObject| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdentifiedObject>(
                "IdentifiedObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdentifiedObject {
        static instance: ::protobuf::rt::LazyV2<IdentifiedObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdentifiedObject::new)
    }
}

impl ::protobuf::Clear for IdentifiedObject {
    fn clear(&mut self) {
        self.description.clear();
        self.mRID.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentifiedObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifiedObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ACDCTerminal {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    connected: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    sequenceNumber: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACDCTerminal {
    fn default() -> &'a ACDCTerminal {
        <ACDCTerminal as ::protobuf::Message>::default_instance()
    }
}

impl ACDCTerminal {
    pub fn new() -> ACDCTerminal {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }

    // .google.protobuf.BoolValue connected = 2;


    pub fn get_connected(&self) -> &::protobuf::well_known_types::BoolValue {
        self.connected.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.connected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connected(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.connected.is_none() {
            self.connected.set_default();
        }
        self.connected.as_mut().unwrap()
    }

    // Take field
    pub fn take_connected(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.connected.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.Int32Value sequenceNumber = 3;


    pub fn get_sequenceNumber(&self) -> &::protobuf::well_known_types::Int32Value {
        self.sequenceNumber.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sequenceNumber(&mut self) {
        self.sequenceNumber.clear();
    }

    pub fn has_sequenceNumber(&self) -> bool {
        self.sequenceNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequenceNumber(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.sequenceNumber = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequenceNumber(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.sequenceNumber.is_none() {
            self.sequenceNumber.set_default();
        }
        self.sequenceNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequenceNumber(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.sequenceNumber.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }
}

impl ::protobuf::Message for ACDCTerminal {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sequenceNumber {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connected)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sequenceNumber)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sequenceNumber.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connected.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sequenceNumber.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACDCTerminal {
        ACDCTerminal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &ACDCTerminal| { &m.identifiedObject },
                |m: &mut ACDCTerminal| { &mut m.identifiedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "connected",
                |m: &ACDCTerminal| { &m.connected },
                |m: &mut ACDCTerminal| { &mut m.connected },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                "sequenceNumber",
                |m: &ACDCTerminal| { &m.sequenceNumber },
                |m: &mut ACDCTerminal| { &mut m.sequenceNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACDCTerminal>(
                "ACDCTerminal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACDCTerminal {
        static instance: ::protobuf::rt::LazyV2<ACDCTerminal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACDCTerminal::new)
    }
}

impl ::protobuf::Clear for ACDCTerminal {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.connected.clear();
        self.sequenceNumber.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACDCTerminal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACDCTerminal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_UnitSymbolKind {
    // message fields
    pub value: UnitSymbolKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_UnitSymbolKind {
    fn default() -> &'a Optional_UnitSymbolKind {
        <Optional_UnitSymbolKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_UnitSymbolKind {
    pub fn new() -> Optional_UnitSymbolKind {
        ::std::default::Default::default()
    }

    // .commonmodule.UnitSymbolKind value = 1;


    pub fn get_value(&self) -> UnitSymbolKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = UnitSymbolKind::UnitSymbolKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UnitSymbolKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_UnitSymbolKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UnitSymbolKind::UnitSymbolKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != UnitSymbolKind::UnitSymbolKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_UnitSymbolKind {
        Optional_UnitSymbolKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnitSymbolKind>>(
                "value",
                |m: &Optional_UnitSymbolKind| { &m.value },
                |m: &mut Optional_UnitSymbolKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_UnitSymbolKind>(
                "Optional_UnitSymbolKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_UnitSymbolKind {
        static instance: ::protobuf::rt::LazyV2<Optional_UnitSymbolKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_UnitSymbolKind::new)
    }
}

impl ::protobuf::Clear for Optional_UnitSymbolKind {
    fn clear(&mut self) {
        self.value = UnitSymbolKind::UnitSymbolKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_UnitSymbolKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_UnitSymbolKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_UnitMultiplierKind {
    // message fields
    pub value: UnitMultiplierKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_UnitMultiplierKind {
    fn default() -> &'a Optional_UnitMultiplierKind {
        <Optional_UnitMultiplierKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_UnitMultiplierKind {
    pub fn new() -> Optional_UnitMultiplierKind {
        ::std::default::Default::default()
    }

    // .commonmodule.UnitMultiplierKind value = 1;


    pub fn get_value(&self) -> UnitMultiplierKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = UnitMultiplierKind::UnitMultiplierKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UnitMultiplierKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_UnitMultiplierKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UnitMultiplierKind::UnitMultiplierKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != UnitMultiplierKind::UnitMultiplierKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_UnitMultiplierKind {
        Optional_UnitMultiplierKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnitMultiplierKind>>(
                "value",
                |m: &Optional_UnitMultiplierKind| { &m.value },
                |m: &mut Optional_UnitMultiplierKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_UnitMultiplierKind>(
                "Optional_UnitMultiplierKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_UnitMultiplierKind {
        static instance: ::protobuf::rt::LazyV2<Optional_UnitMultiplierKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_UnitMultiplierKind::new)
    }
}

impl ::protobuf::Clear for Optional_UnitMultiplierKind {
    fn clear(&mut self) {
        self.value = UnitMultiplierKind::UnitMultiplierKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_UnitMultiplierKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_UnitMultiplierKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ActivePower {
    // message fields
    multiplier: ::protobuf::SingularPtrField<Optional_UnitMultiplierKind>,
    unit: ::protobuf::SingularPtrField<Optional_UnitSymbolKind>,
    value: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActivePower {
    fn default() -> &'a ActivePower {
        <ActivePower as ::protobuf::Message>::default_instance()
    }
}

impl ActivePower {
    pub fn new() -> ActivePower {
        ::std::default::Default::default()
    }

    // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;


    pub fn get_multiplier(&self) -> &Optional_UnitMultiplierKind {
        self.multiplier.as_ref().unwrap_or_else(|| <Optional_UnitMultiplierKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multiplier(&mut self) {
        self.multiplier.clear();
    }

    pub fn has_multiplier(&self) -> bool {
        self.multiplier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiplier(&mut self, v: Optional_UnitMultiplierKind) {
        self.multiplier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multiplier(&mut self) -> &mut Optional_UnitMultiplierKind {
        if self.multiplier.is_none() {
            self.multiplier.set_default();
        }
        self.multiplier.as_mut().unwrap()
    }

    // Take field
    pub fn take_multiplier(&mut self) -> Optional_UnitMultiplierKind {
        self.multiplier.take().unwrap_or_else(|| Optional_UnitMultiplierKind::new())
    }

    // .commonmodule.Optional_UnitSymbolKind unit = 2;


    pub fn get_unit(&self) -> &Optional_UnitSymbolKind {
        self.unit.as_ref().unwrap_or_else(|| <Optional_UnitSymbolKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: Optional_UnitSymbolKind) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut Optional_UnitSymbolKind {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> Optional_UnitSymbolKind {
        self.unit.take().unwrap_or_else(|| Optional_UnitSymbolKind::new())
    }

    // .google.protobuf.FloatValue value = 3;


    pub fn get_value(&self) -> &::protobuf::well_known_types::FloatValue {
        self.value.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.value.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for ActivePower {
    fn is_initialized(&self) -> bool {
        for v in &self.multiplier {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multiplier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.multiplier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.multiplier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivePower {
        ActivePower::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_UnitMultiplierKind>>(
                "multiplier",
                |m: &ActivePower| { &m.multiplier },
                |m: &mut ActivePower| { &mut m.multiplier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_UnitSymbolKind>>(
                "unit",
                |m: &ActivePower| { &m.unit },
                |m: &mut ActivePower| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "value",
                |m: &ActivePower| { &m.value },
                |m: &mut ActivePower| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActivePower>(
                "ActivePower",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActivePower {
        static instance: ::protobuf::rt::LazyV2<ActivePower> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActivePower::new)
    }
}

impl ::protobuf::Clear for ActivePower {
    fn clear(&mut self) {
        self.multiplier.clear();
        self.unit.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivePower {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivePower {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_PhaseCodeKind {
    // message fields
    pub value: PhaseCodeKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_PhaseCodeKind {
    fn default() -> &'a Optional_PhaseCodeKind {
        <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_PhaseCodeKind {
    pub fn new() -> Optional_PhaseCodeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.PhaseCodeKind value = 1;


    pub fn get_value(&self) -> PhaseCodeKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = PhaseCodeKind::PhaseCodeKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PhaseCodeKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_PhaseCodeKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PhaseCodeKind::PhaseCodeKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != PhaseCodeKind::PhaseCodeKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_PhaseCodeKind {
        Optional_PhaseCodeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhaseCodeKind>>(
                "value",
                |m: &Optional_PhaseCodeKind| { &m.value },
                |m: &mut Optional_PhaseCodeKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_PhaseCodeKind>(
                "Optional_PhaseCodeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_PhaseCodeKind {
        static instance: ::protobuf::rt::LazyV2<Optional_PhaseCodeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_PhaseCodeKind::new)
    }
}

impl ::protobuf::Clear for Optional_PhaseCodeKind {
    fn clear(&mut self) {
        self.value = PhaseCodeKind::PhaseCodeKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_PhaseCodeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_PhaseCodeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AnalogueValue {
    // message fields
    f: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    i: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalogueValue {
    fn default() -> &'a AnalogueValue {
        <AnalogueValue as ::protobuf::Message>::default_instance()
    }
}

impl AnalogueValue {
    pub fn new() -> AnalogueValue {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue f = 1;


    pub fn get_f(&self) -> &::protobuf::well_known_types::FloatValue {
        self.f.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_f(&mut self) {
        self.f.clear();
    }

    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.f = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.f.is_none() {
            self.f.set_default();
        }
        self.f.as_mut().unwrap()
    }

    // Take field
    pub fn take_f(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.f.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.Int32Value i = 2;


    pub fn get_i(&self) -> &::protobuf::well_known_types::Int32Value {
        self.i.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_i(&mut self) {
        self.i.clear();
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.i = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_i(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.i.is_none() {
            self.i.set_default();
        }
        self.i.as_mut().unwrap()
    }

    // Take field
    pub fn take_i(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.i.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }
}

impl ::protobuf::Message for AnalogueValue {
    fn is_initialized(&self) -> bool {
        for v in &self.f {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.i {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.f)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.i)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.f.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.i.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.f.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.i.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalogueValue {
        AnalogueValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "f",
                |m: &AnalogueValue| { &m.f },
                |m: &mut AnalogueValue| { &mut m.f },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                "i",
                |m: &AnalogueValue| { &m.i },
                |m: &mut AnalogueValue| { &mut m.i },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalogueValue>(
                "AnalogueValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalogueValue {
        static instance: ::protobuf::rt::LazyV2<AnalogueValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalogueValue::new)
    }
}

impl ::protobuf::Clear for AnalogueValue {
    fn clear(&mut self) {
        self.f.clear();
        self.i.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalogueValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalogueValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_ValidityKind {
    // message fields
    pub value: ValidityKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_ValidityKind {
    fn default() -> &'a Optional_ValidityKind {
        <Optional_ValidityKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_ValidityKind {
    pub fn new() -> Optional_ValidityKind {
        ::std::default::Default::default()
    }

    // .commonmodule.ValidityKind value = 1;


    pub fn get_value(&self) -> ValidityKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = ValidityKind::ValidityKind_good;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ValidityKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_ValidityKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ValidityKind::ValidityKind_good {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != ValidityKind::ValidityKind_good {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_ValidityKind {
        Optional_ValidityKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ValidityKind>>(
                "value",
                |m: &Optional_ValidityKind| { &m.value },
                |m: &mut Optional_ValidityKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_ValidityKind>(
                "Optional_ValidityKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_ValidityKind {
        static instance: ::protobuf::rt::LazyV2<Optional_ValidityKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_ValidityKind::new)
    }
}

impl ::protobuf::Clear for Optional_ValidityKind {
    fn clear(&mut self) {
        self.value = ValidityKind::ValidityKind_good;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_ValidityKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_ValidityKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DetailQual {
    // message fields
    pub badReference: bool,
    pub failure: bool,
    pub inaccurate: bool,
    pub inconsistent: bool,
    pub oldData: bool,
    pub oscillatory: bool,
    pub outOfRange: bool,
    pub overflow: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetailQual {
    fn default() -> &'a DetailQual {
        <DetailQual as ::protobuf::Message>::default_instance()
    }
}

impl DetailQual {
    pub fn new() -> DetailQual {
        ::std::default::Default::default()
    }

    // bool badReference = 1;


    pub fn get_badReference(&self) -> bool {
        self.badReference
    }
    pub fn clear_badReference(&mut self) {
        self.badReference = false;
    }

    // Param is passed by value, moved
    pub fn set_badReference(&mut self, v: bool) {
        self.badReference = v;
    }

    // bool failure = 2;


    pub fn get_failure(&self) -> bool {
        self.failure
    }
    pub fn clear_failure(&mut self) {
        self.failure = false;
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: bool) {
        self.failure = v;
    }

    // bool inaccurate = 3;


    pub fn get_inaccurate(&self) -> bool {
        self.inaccurate
    }
    pub fn clear_inaccurate(&mut self) {
        self.inaccurate = false;
    }

    // Param is passed by value, moved
    pub fn set_inaccurate(&mut self, v: bool) {
        self.inaccurate = v;
    }

    // bool inconsistent = 4;


    pub fn get_inconsistent(&self) -> bool {
        self.inconsistent
    }
    pub fn clear_inconsistent(&mut self) {
        self.inconsistent = false;
    }

    // Param is passed by value, moved
    pub fn set_inconsistent(&mut self, v: bool) {
        self.inconsistent = v;
    }

    // bool oldData = 5;


    pub fn get_oldData(&self) -> bool {
        self.oldData
    }
    pub fn clear_oldData(&mut self) {
        self.oldData = false;
    }

    // Param is passed by value, moved
    pub fn set_oldData(&mut self, v: bool) {
        self.oldData = v;
    }

    // bool oscillatory = 6;


    pub fn get_oscillatory(&self) -> bool {
        self.oscillatory
    }
    pub fn clear_oscillatory(&mut self) {
        self.oscillatory = false;
    }

    // Param is passed by value, moved
    pub fn set_oscillatory(&mut self, v: bool) {
        self.oscillatory = v;
    }

    // bool outOfRange = 7;


    pub fn get_outOfRange(&self) -> bool {
        self.outOfRange
    }
    pub fn clear_outOfRange(&mut self) {
        self.outOfRange = false;
    }

    // Param is passed by value, moved
    pub fn set_outOfRange(&mut self, v: bool) {
        self.outOfRange = v;
    }

    // bool overflow = 8;


    pub fn get_overflow(&self) -> bool {
        self.overflow
    }
    pub fn clear_overflow(&mut self) {
        self.overflow = false;
    }

    // Param is passed by value, moved
    pub fn set_overflow(&mut self, v: bool) {
        self.overflow = v;
    }
}

impl ::protobuf::Message for DetailQual {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.badReference = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failure = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inaccurate = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inconsistent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oldData = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oscillatory = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.outOfRange = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overflow = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.badReference != false {
            my_size += 2;
        }
        if self.failure != false {
            my_size += 2;
        }
        if self.inaccurate != false {
            my_size += 2;
        }
        if self.inconsistent != false {
            my_size += 2;
        }
        if self.oldData != false {
            my_size += 2;
        }
        if self.oscillatory != false {
            my_size += 2;
        }
        if self.outOfRange != false {
            my_size += 2;
        }
        if self.overflow != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.badReference != false {
            os.write_bool(1, self.badReference)?;
        }
        if self.failure != false {
            os.write_bool(2, self.failure)?;
        }
        if self.inaccurate != false {
            os.write_bool(3, self.inaccurate)?;
        }
        if self.inconsistent != false {
            os.write_bool(4, self.inconsistent)?;
        }
        if self.oldData != false {
            os.write_bool(5, self.oldData)?;
        }
        if self.oscillatory != false {
            os.write_bool(6, self.oscillatory)?;
        }
        if self.outOfRange != false {
            os.write_bool(7, self.outOfRange)?;
        }
        if self.overflow != false {
            os.write_bool(8, self.overflow)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailQual {
        DetailQual::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "badReference",
                |m: &DetailQual| { &m.badReference },
                |m: &mut DetailQual| { &mut m.badReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failure",
                |m: &DetailQual| { &m.failure },
                |m: &mut DetailQual| { &mut m.failure },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inaccurate",
                |m: &DetailQual| { &m.inaccurate },
                |m: &mut DetailQual| { &mut m.inaccurate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inconsistent",
                |m: &DetailQual| { &m.inconsistent },
                |m: &mut DetailQual| { &mut m.inconsistent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oldData",
                |m: &DetailQual| { &m.oldData },
                |m: &mut DetailQual| { &mut m.oldData },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oscillatory",
                |m: &DetailQual| { &m.oscillatory },
                |m: &mut DetailQual| { &mut m.oscillatory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "outOfRange",
                |m: &DetailQual| { &m.outOfRange },
                |m: &mut DetailQual| { &mut m.outOfRange },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "overflow",
                |m: &DetailQual| { &m.overflow },
                |m: &mut DetailQual| { &mut m.overflow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetailQual>(
                "DetailQual",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetailQual {
        static instance: ::protobuf::rt::LazyV2<DetailQual> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetailQual::new)
    }
}

impl ::protobuf::Clear for DetailQual {
    fn clear(&mut self) {
        self.badReference = false;
        self.failure = false;
        self.inaccurate = false;
        self.inconsistent = false;
        self.oldData = false;
        self.oscillatory = false;
        self.outOfRange = false;
        self.overflow = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailQual {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailQual {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_SourceKind {
    // message fields
    pub value: SourceKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_SourceKind {
    fn default() -> &'a Optional_SourceKind {
        <Optional_SourceKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_SourceKind {
    pub fn new() -> Optional_SourceKind {
        ::std::default::Default::default()
    }

    // .commonmodule.SourceKind value = 1;


    pub fn get_value(&self) -> SourceKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = SourceKind::SourceKind_process;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SourceKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_SourceKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SourceKind::SourceKind_process {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != SourceKind::SourceKind_process {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_SourceKind {
        Optional_SourceKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SourceKind>>(
                "value",
                |m: &Optional_SourceKind| { &m.value },
                |m: &mut Optional_SourceKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_SourceKind>(
                "Optional_SourceKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_SourceKind {
        static instance: ::protobuf::rt::LazyV2<Optional_SourceKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_SourceKind::new)
    }
}

impl ::protobuf::Clear for Optional_SourceKind {
    fn clear(&mut self) {
        self.value = SourceKind::SourceKind_process;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_SourceKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_SourceKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Quality {
    // message fields
    detailQual: ::protobuf::SingularPtrField<DetailQual>,
    pub operatorBlocked: bool,
    pub source: SourceKind,
    pub test: bool,
    pub validity: ValidityKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Quality {
    fn default() -> &'a Quality {
        <Quality as ::protobuf::Message>::default_instance()
    }
}

impl Quality {
    pub fn new() -> Quality {
        ::std::default::Default::default()
    }

    // .commonmodule.DetailQual detailQual = 1;


    pub fn get_detailQual(&self) -> &DetailQual {
        self.detailQual.as_ref().unwrap_or_else(|| <DetailQual as ::protobuf::Message>::default_instance())
    }
    pub fn clear_detailQual(&mut self) {
        self.detailQual.clear();
    }

    pub fn has_detailQual(&self) -> bool {
        self.detailQual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detailQual(&mut self, v: DetailQual) {
        self.detailQual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detailQual(&mut self) -> &mut DetailQual {
        if self.detailQual.is_none() {
            self.detailQual.set_default();
        }
        self.detailQual.as_mut().unwrap()
    }

    // Take field
    pub fn take_detailQual(&mut self) -> DetailQual {
        self.detailQual.take().unwrap_or_else(|| DetailQual::new())
    }

    // bool operatorBlocked = 2;


    pub fn get_operatorBlocked(&self) -> bool {
        self.operatorBlocked
    }
    pub fn clear_operatorBlocked(&mut self) {
        self.operatorBlocked = false;
    }

    // Param is passed by value, moved
    pub fn set_operatorBlocked(&mut self, v: bool) {
        self.operatorBlocked = v;
    }

    // .commonmodule.SourceKind source = 3;


    pub fn get_source(&self) -> SourceKind {
        self.source
    }
    pub fn clear_source(&mut self) {
        self.source = SourceKind::SourceKind_process;
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: SourceKind) {
        self.source = v;
    }

    // bool test = 4;


    pub fn get_test(&self) -> bool {
        self.test
    }
    pub fn clear_test(&mut self) {
        self.test = false;
    }

    // Param is passed by value, moved
    pub fn set_test(&mut self, v: bool) {
        self.test = v;
    }

    // .commonmodule.ValidityKind validity = 5;


    pub fn get_validity(&self) -> ValidityKind {
        self.validity
    }
    pub fn clear_validity(&mut self) {
        self.validity = ValidityKind::ValidityKind_good;
    }

    // Param is passed by value, moved
    pub fn set_validity(&mut self, v: ValidityKind) {
        self.validity = v;
    }
}

impl ::protobuf::Message for Quality {
    fn is_initialized(&self) -> bool {
        for v in &self.detailQual {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.detailQual)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.operatorBlocked = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.test = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.validity, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.detailQual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.operatorBlocked != false {
            my_size += 2;
        }
        if self.source != SourceKind::SourceKind_process {
            my_size += ::protobuf::rt::enum_size(3, self.source);
        }
        if self.test != false {
            my_size += 2;
        }
        if self.validity != ValidityKind::ValidityKind_good {
            my_size += ::protobuf::rt::enum_size(5, self.validity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.detailQual.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.operatorBlocked != false {
            os.write_bool(2, self.operatorBlocked)?;
        }
        if self.source != SourceKind::SourceKind_process {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.source))?;
        }
        if self.test != false {
            os.write_bool(4, self.test)?;
        }
        if self.validity != ValidityKind::ValidityKind_good {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.validity))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quality {
        Quality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailQual>>(
                "detailQual",
                |m: &Quality| { &m.detailQual },
                |m: &mut Quality| { &mut m.detailQual },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "operatorBlocked",
                |m: &Quality| { &m.operatorBlocked },
                |m: &mut Quality| { &mut m.operatorBlocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SourceKind>>(
                "source",
                |m: &Quality| { &m.source },
                |m: &mut Quality| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "test",
                |m: &Quality| { &m.test },
                |m: &mut Quality| { &mut m.test },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ValidityKind>>(
                "validity",
                |m: &Quality| { &m.validity },
                |m: &mut Quality| { &mut m.validity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Quality>(
                "Quality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Quality {
        static instance: ::protobuf::rt::LazyV2<Quality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Quality::new)
    }
}

impl ::protobuf::Clear for Quality {
    fn clear(&mut self) {
        self.detailQual.clear();
        self.operatorBlocked = false;
        self.source = SourceKind::SourceKind_process;
        self.test = false;
        self.validity = ValidityKind::ValidityKind_good;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_TimeAccuracyKind {
    // message fields
    pub value: TimeAccuracyKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_TimeAccuracyKind {
    fn default() -> &'a Optional_TimeAccuracyKind {
        <Optional_TimeAccuracyKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_TimeAccuracyKind {
    pub fn new() -> Optional_TimeAccuracyKind {
        ::std::default::Default::default()
    }

    // .commonmodule.TimeAccuracyKind value = 1;


    pub fn get_value(&self) -> TimeAccuracyKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = TimeAccuracyKind::TimeAccuracyKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TimeAccuracyKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_TimeAccuracyKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TimeAccuracyKind::TimeAccuracyKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != TimeAccuracyKind::TimeAccuracyKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_TimeAccuracyKind {
        Optional_TimeAccuracyKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TimeAccuracyKind>>(
                "value",
                |m: &Optional_TimeAccuracyKind| { &m.value },
                |m: &mut Optional_TimeAccuracyKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_TimeAccuracyKind>(
                "Optional_TimeAccuracyKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_TimeAccuracyKind {
        static instance: ::protobuf::rt::LazyV2<Optional_TimeAccuracyKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_TimeAccuracyKind::new)
    }
}

impl ::protobuf::Clear for Optional_TimeAccuracyKind {
    fn clear(&mut self) {
        self.value = TimeAccuracyKind::TimeAccuracyKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_TimeAccuracyKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_TimeAccuracyKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TimeQuality {
    // message fields
    pub clockFailure: bool,
    pub clockNotSynchronized: bool,
    pub leapSecondsKnown: bool,
    pub timeAccuracy: TimeAccuracyKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeQuality {
    fn default() -> &'a TimeQuality {
        <TimeQuality as ::protobuf::Message>::default_instance()
    }
}

impl TimeQuality {
    pub fn new() -> TimeQuality {
        ::std::default::Default::default()
    }

    // bool clockFailure = 1;


    pub fn get_clockFailure(&self) -> bool {
        self.clockFailure
    }
    pub fn clear_clockFailure(&mut self) {
        self.clockFailure = false;
    }

    // Param is passed by value, moved
    pub fn set_clockFailure(&mut self, v: bool) {
        self.clockFailure = v;
    }

    // bool clockNotSynchronized = 2;


    pub fn get_clockNotSynchronized(&self) -> bool {
        self.clockNotSynchronized
    }
    pub fn clear_clockNotSynchronized(&mut self) {
        self.clockNotSynchronized = false;
    }

    // Param is passed by value, moved
    pub fn set_clockNotSynchronized(&mut self, v: bool) {
        self.clockNotSynchronized = v;
    }

    // bool leapSecondsKnown = 3;


    pub fn get_leapSecondsKnown(&self) -> bool {
        self.leapSecondsKnown
    }
    pub fn clear_leapSecondsKnown(&mut self) {
        self.leapSecondsKnown = false;
    }

    // Param is passed by value, moved
    pub fn set_leapSecondsKnown(&mut self, v: bool) {
        self.leapSecondsKnown = v;
    }

    // .commonmodule.TimeAccuracyKind timeAccuracy = 4;


    pub fn get_timeAccuracy(&self) -> TimeAccuracyKind {
        self.timeAccuracy
    }
    pub fn clear_timeAccuracy(&mut self) {
        self.timeAccuracy = TimeAccuracyKind::TimeAccuracyKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_timeAccuracy(&mut self, v: TimeAccuracyKind) {
        self.timeAccuracy = v;
    }
}

impl ::protobuf::Message for TimeQuality {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clockFailure = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clockNotSynchronized = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.leapSecondsKnown = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.timeAccuracy, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.clockFailure != false {
            my_size += 2;
        }
        if self.clockNotSynchronized != false {
            my_size += 2;
        }
        if self.leapSecondsKnown != false {
            my_size += 2;
        }
        if self.timeAccuracy != TimeAccuracyKind::TimeAccuracyKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(4, self.timeAccuracy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.clockFailure != false {
            os.write_bool(1, self.clockFailure)?;
        }
        if self.clockNotSynchronized != false {
            os.write_bool(2, self.clockNotSynchronized)?;
        }
        if self.leapSecondsKnown != false {
            os.write_bool(3, self.leapSecondsKnown)?;
        }
        if self.timeAccuracy != TimeAccuracyKind::TimeAccuracyKind_UNDEFINED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.timeAccuracy))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeQuality {
        TimeQuality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clockFailure",
                |m: &TimeQuality| { &m.clockFailure },
                |m: &mut TimeQuality| { &mut m.clockFailure },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clockNotSynchronized",
                |m: &TimeQuality| { &m.clockNotSynchronized },
                |m: &mut TimeQuality| { &mut m.clockNotSynchronized },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "leapSecondsKnown",
                |m: &TimeQuality| { &m.leapSecondsKnown },
                |m: &mut TimeQuality| { &mut m.leapSecondsKnown },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TimeAccuracyKind>>(
                "timeAccuracy",
                |m: &TimeQuality| { &m.timeAccuracy },
                |m: &mut TimeQuality| { &mut m.timeAccuracy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeQuality>(
                "TimeQuality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeQuality {
        static instance: ::protobuf::rt::LazyV2<TimeQuality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeQuality::new)
    }
}

impl ::protobuf::Clear for TimeQuality {
    fn clear(&mut self) {
        self.clockFailure = false;
        self.clockNotSynchronized = false;
        self.leapSecondsKnown = false;
        self.timeAccuracy = TimeAccuracyKind::TimeAccuracyKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeQuality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Timestamp {
    // message fields
    pub fraction: u32,
    pub seconds: u64,
    tq: ::protobuf::SingularPtrField<TimeQuality>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Timestamp {
    fn default() -> &'a Timestamp {
        <Timestamp as ::protobuf::Message>::default_instance()
    }
}

impl Timestamp {
    pub fn new() -> Timestamp {
        ::std::default::Default::default()
    }

    // uint32 fraction = 1;


    pub fn get_fraction(&self) -> u32 {
        self.fraction
    }
    pub fn clear_fraction(&mut self) {
        self.fraction = 0;
    }

    // Param is passed by value, moved
    pub fn set_fraction(&mut self, v: u32) {
        self.fraction = v;
    }

    // uint64 seconds = 2;


    pub fn get_seconds(&self) -> u64 {
        self.seconds
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u64) {
        self.seconds = v;
    }

    // .commonmodule.TimeQuality tq = 3;


    pub fn get_tq(&self) -> &TimeQuality {
        self.tq.as_ref().unwrap_or_else(|| <TimeQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tq(&mut self) {
        self.tq.clear();
    }

    pub fn has_tq(&self) -> bool {
        self.tq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tq(&mut self, v: TimeQuality) {
        self.tq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tq(&mut self) -> &mut TimeQuality {
        if self.tq.is_none() {
            self.tq.set_default();
        }
        self.tq.as_mut().unwrap()
    }

    // Take field
    pub fn take_tq(&mut self) -> TimeQuality {
        self.tq.take().unwrap_or_else(|| TimeQuality::new())
    }
}

impl ::protobuf::Message for Timestamp {
    fn is_initialized(&self) -> bool {
        for v in &self.tq {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fraction = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seconds = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tq)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fraction != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fraction, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seconds != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fraction != 0 {
            os.write_uint32(1, self.fraction)?;
        }
        if self.seconds != 0 {
            os.write_uint64(2, self.seconds)?;
        }
        if let Some(ref v) = self.tq.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timestamp {
        Timestamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fraction",
                |m: &Timestamp| { &m.fraction },
                |m: &mut Timestamp| { &mut m.fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seconds",
                |m: &Timestamp| { &m.seconds },
                |m: &mut Timestamp| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeQuality>>(
                "tq",
                |m: &Timestamp| { &m.tq },
                |m: &mut Timestamp| { &mut m.tq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Timestamp>(
                "Timestamp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Timestamp {
        static instance: ::protobuf::rt::LazyV2<Timestamp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Timestamp::new)
    }
}

impl ::protobuf::Clear for Timestamp {
    fn clear(&mut self) {
        self.fraction = 0;
        self.seconds = 0;
        self.tq.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Unit {
    // message fields
    multiplier: ::protobuf::SingularPtrField<Optional_UnitMultiplierKind>,
    pub SIUnit: UnitSymbolKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Unit {
    fn default() -> &'a Unit {
        <Unit as ::protobuf::Message>::default_instance()
    }
}

impl Unit {
    pub fn new() -> Unit {
        ::std::default::Default::default()
    }

    // .commonmodule.Optional_UnitMultiplierKind multiplier = 1;


    pub fn get_multiplier(&self) -> &Optional_UnitMultiplierKind {
        self.multiplier.as_ref().unwrap_or_else(|| <Optional_UnitMultiplierKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multiplier(&mut self) {
        self.multiplier.clear();
    }

    pub fn has_multiplier(&self) -> bool {
        self.multiplier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiplier(&mut self, v: Optional_UnitMultiplierKind) {
        self.multiplier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multiplier(&mut self) -> &mut Optional_UnitMultiplierKind {
        if self.multiplier.is_none() {
            self.multiplier.set_default();
        }
        self.multiplier.as_mut().unwrap()
    }

    // Take field
    pub fn take_multiplier(&mut self) -> Optional_UnitMultiplierKind {
        self.multiplier.take().unwrap_or_else(|| Optional_UnitMultiplierKind::new())
    }

    // .commonmodule.UnitSymbolKind SIUnit = 2;


    pub fn get_SIUnit(&self) -> UnitSymbolKind {
        self.SIUnit
    }
    pub fn clear_SIUnit(&mut self) {
        self.SIUnit = UnitSymbolKind::UnitSymbolKind_none;
    }

    // Param is passed by value, moved
    pub fn set_SIUnit(&mut self, v: UnitSymbolKind) {
        self.SIUnit = v;
    }
}

impl ::protobuf::Message for Unit {
    fn is_initialized(&self) -> bool {
        for v in &self.multiplier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multiplier)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.SIUnit, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.multiplier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.SIUnit != UnitSymbolKind::UnitSymbolKind_none {
            my_size += ::protobuf::rt::enum_size(2, self.SIUnit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.multiplier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.SIUnit != UnitSymbolKind::UnitSymbolKind_none {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.SIUnit))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unit {
        Unit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_UnitMultiplierKind>>(
                "multiplier",
                |m: &Unit| { &m.multiplier },
                |m: &mut Unit| { &mut m.multiplier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnitSymbolKind>>(
                "SIUnit",
                |m: &Unit| { &m.SIUnit },
                |m: &mut Unit| { &mut m.SIUnit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Unit>(
                "Unit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Unit {
        static instance: ::protobuf::rt::LazyV2<Unit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Unit::new)
    }
}

impl ::protobuf::Clear for Unit {
    fn clear(&mut self) {
        self.multiplier.clear();
        self.SIUnit = UnitSymbolKind::UnitSymbolKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MV {
    // message fields
    mag: ::protobuf::SingularPtrField<AnalogueValue>,
    q: ::protobuf::SingularPtrField<Quality>,
    t: ::protobuf::SingularPtrField<Timestamp>,
    units: ::protobuf::SingularPtrField<Unit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MV {
    fn default() -> &'a MV {
        <MV as ::protobuf::Message>::default_instance()
    }
}

impl MV {
    pub fn new() -> MV {
        ::std::default::Default::default()
    }

    // .commonmodule.AnalogueValue mag = 1;


    pub fn get_mag(&self) -> &AnalogueValue {
        self.mag.as_ref().unwrap_or_else(|| <AnalogueValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mag(&mut self) {
        self.mag.clear();
    }

    pub fn has_mag(&self) -> bool {
        self.mag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mag(&mut self, v: AnalogueValue) {
        self.mag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mag(&mut self) -> &mut AnalogueValue {
        if self.mag.is_none() {
            self.mag.set_default();
        }
        self.mag.as_mut().unwrap()
    }

    // Take field
    pub fn take_mag(&mut self) -> AnalogueValue {
        self.mag.take().unwrap_or_else(|| AnalogueValue::new())
    }

    // .commonmodule.Quality q = 2;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }

    // .commonmodule.Unit units = 4;


    pub fn get_units(&self) -> &Unit {
        self.units.as_ref().unwrap_or_else(|| <Unit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Unit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Unit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Unit {
        self.units.take().unwrap_or_else(|| Unit::new())
    }
}

impl ::protobuf::Message for MV {
    fn is_initialized(&self) -> bool {
        for v in &self.mag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mag.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MV {
        MV::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogueValue>>(
                "mag",
                |m: &MV| { &m.mag },
                |m: &mut MV| { &mut m.mag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &MV| { &m.q },
                |m: &mut MV| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &MV| { &m.t },
                |m: &mut MV| { &mut m.t },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &MV| { &m.units },
                |m: &mut MV| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MV>(
                "MV",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MV {
        static instance: ::protobuf::rt::LazyV2<MV> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MV::new)
    }
}

impl ::protobuf::Clear for MV {
    fn clear(&mut self) {
        self.mag.clear();
        self.q.clear();
        self.t.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MV {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LogicalNode {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogicalNode {
    fn default() -> &'a LogicalNode {
        <LogicalNode as ::protobuf::Message>::default_instance()
    }
}

impl LogicalNode {
    pub fn new() -> LogicalNode {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for LogicalNode {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalNode {
        LogicalNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &LogicalNode| { &m.identifiedObject },
                |m: &mut LogicalNode| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogicalNode>(
                "LogicalNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogicalNode {
        static instance: ::protobuf::rt::LazyV2<LogicalNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogicalNode::new)
    }
}

impl ::protobuf::Clear for LogicalNode {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AnalogStatusGGIO {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    AnIn: ::protobuf::SingularPtrField<MV>,
    Phase: ::protobuf::SingularPtrField<Optional_PhaseCodeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalogStatusGGIO {
    fn default() -> &'a AnalogStatusGGIO {
        <AnalogStatusGGIO as ::protobuf::Message>::default_instance()
    }
}

impl AnalogStatusGGIO {
    pub fn new() -> AnalogStatusGGIO {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.MV AnIn = 2;


    pub fn get_AnIn(&self) -> &MV {
        self.AnIn.as_ref().unwrap_or_else(|| <MV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_AnIn(&mut self) {
        self.AnIn.clear();
    }

    pub fn has_AnIn(&self) -> bool {
        self.AnIn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AnIn(&mut self, v: MV) {
        self.AnIn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AnIn(&mut self) -> &mut MV {
        if self.AnIn.is_none() {
            self.AnIn.set_default();
        }
        self.AnIn.as_mut().unwrap()
    }

    // Take field
    pub fn take_AnIn(&mut self) -> MV {
        self.AnIn.take().unwrap_or_else(|| MV::new())
    }

    // .commonmodule.Optional_PhaseCodeKind Phase = 3;


    pub fn get_Phase(&self) -> &Optional_PhaseCodeKind {
        self.Phase.as_ref().unwrap_or_else(|| <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Phase(&mut self) {
        self.Phase.clear();
    }

    pub fn has_Phase(&self) -> bool {
        self.Phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Phase(&mut self, v: Optional_PhaseCodeKind) {
        self.Phase = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Phase(&mut self) -> &mut Optional_PhaseCodeKind {
        if self.Phase.is_none() {
            self.Phase.set_default();
        }
        self.Phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_Phase(&mut self) -> Optional_PhaseCodeKind {
        self.Phase.take().unwrap_or_else(|| Optional_PhaseCodeKind::new())
    }
}

impl ::protobuf::Message for AnalogStatusGGIO {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.AnIn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Phase {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AnIn)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Phase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.AnIn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.AnIn.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalogStatusGGIO {
        AnalogStatusGGIO::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &AnalogStatusGGIO| { &m.logicalNode },
                |m: &mut AnalogStatusGGIO| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MV>>(
                "AnIn",
                |m: &AnalogStatusGGIO| { &m.AnIn },
                |m: &mut AnalogStatusGGIO| { &mut m.AnIn },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_PhaseCodeKind>>(
                "Phase",
                |m: &AnalogStatusGGIO| { &m.Phase },
                |m: &mut AnalogStatusGGIO| { &mut m.Phase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalogStatusGGIO>(
                "AnalogStatusGGIO",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalogStatusGGIO {
        static instance: ::protobuf::rt::LazyV2<AnalogStatusGGIO> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalogStatusGGIO::new)
    }
}

impl ::protobuf::Clear for AnalogStatusGGIO {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.AnIn.clear();
        self.Phase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalogStatusGGIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalogStatusGGIO {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AnalogueValueCtl {
    // message fields
    f: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    i: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalogueValueCtl {
    fn default() -> &'a AnalogueValueCtl {
        <AnalogueValueCtl as ::protobuf::Message>::default_instance()
    }
}

impl AnalogueValueCtl {
    pub fn new() -> AnalogueValueCtl {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue f = 1;


    pub fn get_f(&self) -> &::protobuf::well_known_types::FloatValue {
        self.f.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_f(&mut self) {
        self.f.clear();
    }

    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.f = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.f.is_none() {
            self.f.set_default();
        }
        self.f.as_mut().unwrap()
    }

    // Take field
    pub fn take_f(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.f.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.Int32Value i = 2;


    pub fn get_i(&self) -> &::protobuf::well_known_types::Int32Value {
        self.i.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_i(&mut self) {
        self.i.clear();
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.i = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_i(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.i.is_none() {
            self.i.set_default();
        }
        self.i.as_mut().unwrap()
    }

    // Take field
    pub fn take_i(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.i.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }
}

impl ::protobuf::Message for AnalogueValueCtl {
    fn is_initialized(&self) -> bool {
        for v in &self.f {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.i {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.f)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.i)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.f.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.i.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.f.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.i.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalogueValueCtl {
        AnalogueValueCtl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "f",
                |m: &AnalogueValueCtl| { &m.f },
                |m: &mut AnalogueValueCtl| { &mut m.f },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                "i",
                |m: &AnalogueValueCtl| { &m.i },
                |m: &mut AnalogueValueCtl| { &mut m.i },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalogueValueCtl>(
                "AnalogueValueCtl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalogueValueCtl {
        static instance: ::protobuf::rt::LazyV2<AnalogueValueCtl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalogueValueCtl::new)
    }
}

impl ::protobuf::Clear for AnalogueValueCtl {
    fn clear(&mut self) {
        self.f.clear();
        self.i.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalogueValueCtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalogueValueCtl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NamedObject {
    // message fields
    description: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    name: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamedObject {
    fn default() -> &'a NamedObject {
        <NamedObject as ::protobuf::Message>::default_instance()
    }
}

impl NamedObject {
    pub fn new() -> NamedObject {
        ::std::default::Default::default()
    }

    // .google.protobuf.StringValue description = 1;


    pub fn get_description(&self) -> &::protobuf::well_known_types::StringValue {
        self.description.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.description.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    // .google.protobuf.StringValue name = 2;


    pub fn get_name(&self) -> &::protobuf::well_known_types::StringValue {
        self.name.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.name.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }
}

impl ::protobuf::Message for NamedObject {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamedObject {
        NamedObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "description",
                |m: &NamedObject| { &m.description },
                |m: &mut NamedObject| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "name",
                |m: &NamedObject| { &m.name },
                |m: &mut NamedObject| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamedObject>(
                "NamedObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamedObject {
        static instance: ::protobuf::rt::LazyV2<NamedObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamedObject::new)
    }
}

impl ::protobuf::Clear for NamedObject {
    fn clear(&mut self) {
        self.description.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamedObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamedObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ApplicationSystem {
    // message fields
    namedObject: ::protobuf::SingularPtrField<NamedObject>,
    pub mRID: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationSystem {
    fn default() -> &'a ApplicationSystem {
        <ApplicationSystem as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationSystem {
    pub fn new() -> ApplicationSystem {
        ::std::default::Default::default()
    }

    // .commonmodule.NamedObject namedObject = 1;


    pub fn get_namedObject(&self) -> &NamedObject {
        self.namedObject.as_ref().unwrap_or_else(|| <NamedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namedObject(&mut self) {
        self.namedObject.clear();
    }

    pub fn has_namedObject(&self) -> bool {
        self.namedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedObject(&mut self, v: NamedObject) {
        self.namedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedObject(&mut self) -> &mut NamedObject {
        if self.namedObject.is_none() {
            self.namedObject.set_default();
        }
        self.namedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_namedObject(&mut self) -> NamedObject {
        self.namedObject.take().unwrap_or_else(|| NamedObject::new())
    }

    // string mRID = 2;


    pub fn get_mRID(&self) -> &str {
        &self.mRID
    }
    pub fn clear_mRID(&mut self) {
        self.mRID.clear();
    }

    // Param is passed by value, moved
    pub fn set_mRID(&mut self, v: ::std::string::String) {
        self.mRID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mRID(&mut self) -> &mut ::std::string::String {
        &mut self.mRID
    }

    // Take field
    pub fn take_mRID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mRID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ApplicationSystem {
    fn is_initialized(&self) -> bool {
        for v in &self.namedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namedObject)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mRID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.mRID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mRID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.mRID.is_empty() {
            os.write_string(2, &self.mRID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationSystem {
        ApplicationSystem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamedObject>>(
                "namedObject",
                |m: &ApplicationSystem| { &m.namedObject },
                |m: &mut ApplicationSystem| { &mut m.namedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mRID",
                |m: &ApplicationSystem| { &m.mRID },
                |m: &mut ApplicationSystem| { &mut m.mRID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplicationSystem>(
                "ApplicationSystem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplicationSystem {
        static instance: ::protobuf::rt::LazyV2<ApplicationSystem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplicationSystem::new)
    }
}

impl ::protobuf::Clear for ApplicationSystem {
    fn clear(&mut self) {
        self.namedObject.clear();
        self.mRID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationSystem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ASG {
    // message fields
    setMag: ::protobuf::SingularPtrField<AnalogueValueCtl>,
    units: ::protobuf::SingularPtrField<Unit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ASG {
    fn default() -> &'a ASG {
        <ASG as ::protobuf::Message>::default_instance()
    }
}

impl ASG {
    pub fn new() -> ASG {
        ::std::default::Default::default()
    }

    // .commonmodule.AnalogueValueCtl setMag = 1;


    pub fn get_setMag(&self) -> &AnalogueValueCtl {
        self.setMag.as_ref().unwrap_or_else(|| <AnalogueValueCtl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_setMag(&mut self) {
        self.setMag.clear();
    }

    pub fn has_setMag(&self) -> bool {
        self.setMag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setMag(&mut self, v: AnalogueValueCtl) {
        self.setMag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setMag(&mut self) -> &mut AnalogueValueCtl {
        if self.setMag.is_none() {
            self.setMag.set_default();
        }
        self.setMag.as_mut().unwrap()
    }

    // Take field
    pub fn take_setMag(&mut self) -> AnalogueValueCtl {
        self.setMag.take().unwrap_or_else(|| AnalogueValueCtl::new())
    }

    // .commonmodule.Unit units = 2;


    pub fn get_units(&self) -> &Unit {
        self.units.as_ref().unwrap_or_else(|| <Unit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Unit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Unit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Unit {
        self.units.take().unwrap_or_else(|| Unit::new())
    }
}

impl ::protobuf::Message for ASG {
    fn is_initialized(&self) -> bool {
        for v in &self.setMag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.setMag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.setMag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.setMag.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ASG {
        ASG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogueValueCtl>>(
                "setMag",
                |m: &ASG| { &m.setMag },
                |m: &mut ASG| { &mut m.setMag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &ASG| { &m.units },
                |m: &mut ASG| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ASG>(
                "ASG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ASG {
        static instance: ::protobuf::rt::LazyV2<ASG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ASG::new)
    }
}

impl ::protobuf::Clear for ASG {
    fn clear(&mut self) {
        self.setMag.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ASG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ASG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BCR {
    // message fields
    pub actVal: i64,
    q: ::protobuf::SingularPtrField<Quality>,
    t: ::protobuf::SingularPtrField<Timestamp>,
    units: ::protobuf::SingularPtrField<Optional_UnitSymbolKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BCR {
    fn default() -> &'a BCR {
        <BCR as ::protobuf::Message>::default_instance()
    }
}

impl BCR {
    pub fn new() -> BCR {
        ::std::default::Default::default()
    }

    // int64 actVal = 1;


    pub fn get_actVal(&self) -> i64 {
        self.actVal
    }
    pub fn clear_actVal(&mut self) {
        self.actVal = 0;
    }

    // Param is passed by value, moved
    pub fn set_actVal(&mut self, v: i64) {
        self.actVal = v;
    }

    // .commonmodule.Quality q = 2;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }

    // .commonmodule.Optional_UnitSymbolKind units = 4;


    pub fn get_units(&self) -> &Optional_UnitSymbolKind {
        self.units.as_ref().unwrap_or_else(|| <Optional_UnitSymbolKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Optional_UnitSymbolKind) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Optional_UnitSymbolKind {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Optional_UnitSymbolKind {
        self.units.take().unwrap_or_else(|| Optional_UnitSymbolKind::new())
    }
}

impl ::protobuf::Message for BCR {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.actVal = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.actVal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.actVal, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.actVal != 0 {
            os.write_int64(1, self.actVal)?;
        }
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BCR {
        BCR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "actVal",
                |m: &BCR| { &m.actVal },
                |m: &mut BCR| { &mut m.actVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &BCR| { &m.q },
                |m: &mut BCR| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &BCR| { &m.t },
                |m: &mut BCR| { &mut m.t },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_UnitSymbolKind>>(
                "units",
                |m: &BCR| { &m.units },
                |m: &mut BCR| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BCR>(
                "BCR",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BCR {
        static instance: ::protobuf::rt::LazyV2<BCR> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BCR::new)
    }
}

impl ::protobuf::Clear for BCR {
    fn clear(&mut self) {
        self.actVal = 0;
        self.q.clear();
        self.t.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BCR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BCR {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusSPS {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: bool,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusSPS {
    fn default() -> &'a StatusSPS {
        <StatusSPS as ::protobuf::Message>::default_instance()
    }
}

impl StatusSPS {
    pub fn new() -> StatusSPS {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // bool stVal = 2;


    pub fn get_stVal(&self) -> bool {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = false;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: bool) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for StatusSPS {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stVal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != false {
            my_size += 2;
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != false {
            os.write_bool(2, self.stVal)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusSPS {
        StatusSPS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &StatusSPS| { &m.q },
                |m: &mut StatusSPS| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stVal",
                |m: &StatusSPS| { &m.stVal },
                |m: &mut StatusSPS| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &StatusSPS| { &m.t },
                |m: &mut StatusSPS| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusSPS>(
                "StatusSPS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusSPS {
        static instance: ::protobuf::rt::LazyV2<StatusSPS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusSPS::new)
    }
}

impl ::protobuf::Clear for StatusSPS {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = false;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusSPS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusSPS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BooleanStatusGGIO {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    Ind: ::protobuf::SingularPtrField<StatusSPS>,
    Phase: ::protobuf::SingularPtrField<Optional_PhaseCodeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BooleanStatusGGIO {
    fn default() -> &'a BooleanStatusGGIO {
        <BooleanStatusGGIO as ::protobuf::Message>::default_instance()
    }
}

impl BooleanStatusGGIO {
    pub fn new() -> BooleanStatusGGIO {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.StatusSPS Ind = 2;


    pub fn get_Ind(&self) -> &StatusSPS {
        self.Ind.as_ref().unwrap_or_else(|| <StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Ind(&mut self) {
        self.Ind.clear();
    }

    pub fn has_Ind(&self) -> bool {
        self.Ind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Ind(&mut self, v: StatusSPS) {
        self.Ind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Ind(&mut self) -> &mut StatusSPS {
        if self.Ind.is_none() {
            self.Ind.set_default();
        }
        self.Ind.as_mut().unwrap()
    }

    // Take field
    pub fn take_Ind(&mut self) -> StatusSPS {
        self.Ind.take().unwrap_or_else(|| StatusSPS::new())
    }

    // .commonmodule.Optional_PhaseCodeKind Phase = 3;


    pub fn get_Phase(&self) -> &Optional_PhaseCodeKind {
        self.Phase.as_ref().unwrap_or_else(|| <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Phase(&mut self) {
        self.Phase.clear();
    }

    pub fn has_Phase(&self) -> bool {
        self.Phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Phase(&mut self, v: Optional_PhaseCodeKind) {
        self.Phase = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Phase(&mut self) -> &mut Optional_PhaseCodeKind {
        if self.Phase.is_none() {
            self.Phase.set_default();
        }
        self.Phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_Phase(&mut self) -> Optional_PhaseCodeKind {
        self.Phase.take().unwrap_or_else(|| Optional_PhaseCodeKind::new())
    }
}

impl ::protobuf::Message for BooleanStatusGGIO {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Ind {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Phase {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Ind)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Phase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Ind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Ind.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BooleanStatusGGIO {
        BooleanStatusGGIO::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &BooleanStatusGGIO| { &m.logicalNode },
                |m: &mut BooleanStatusGGIO| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusSPS>>(
                "Ind",
                |m: &BooleanStatusGGIO| { &m.Ind },
                |m: &mut BooleanStatusGGIO| { &mut m.Ind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_PhaseCodeKind>>(
                "Phase",
                |m: &BooleanStatusGGIO| { &m.Phase },
                |m: &mut BooleanStatusGGIO| { &mut m.Phase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BooleanStatusGGIO>(
                "BooleanStatusGGIO",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BooleanStatusGGIO {
        static instance: ::protobuf::rt::LazyV2<BooleanStatusGGIO> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BooleanStatusGGIO::new)
    }
}

impl ::protobuf::Clear for BooleanStatusGGIO {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.Ind.clear();
        self.Phase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BooleanStatusGGIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BooleanStatusGGIO {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CheckConditions {
    // message fields
    interlockCheck: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    synchroCheck: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckConditions {
    fn default() -> &'a CheckConditions {
        <CheckConditions as ::protobuf::Message>::default_instance()
    }
}

impl CheckConditions {
    pub fn new() -> CheckConditions {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue interlockCheck = 1;


    pub fn get_interlockCheck(&self) -> &::protobuf::well_known_types::BoolValue {
        self.interlockCheck.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interlockCheck(&mut self) {
        self.interlockCheck.clear();
    }

    pub fn has_interlockCheck(&self) -> bool {
        self.interlockCheck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interlockCheck(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.interlockCheck = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interlockCheck(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.interlockCheck.is_none() {
            self.interlockCheck.set_default();
        }
        self.interlockCheck.as_mut().unwrap()
    }

    // Take field
    pub fn take_interlockCheck(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.interlockCheck.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.BoolValue synchroCheck = 2;


    pub fn get_synchroCheck(&self) -> &::protobuf::well_known_types::BoolValue {
        self.synchroCheck.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_synchroCheck(&mut self) {
        self.synchroCheck.clear();
    }

    pub fn has_synchroCheck(&self) -> bool {
        self.synchroCheck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_synchroCheck(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.synchroCheck = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_synchroCheck(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.synchroCheck.is_none() {
            self.synchroCheck.set_default();
        }
        self.synchroCheck.as_mut().unwrap()
    }

    // Take field
    pub fn take_synchroCheck(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.synchroCheck.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for CheckConditions {
    fn is_initialized(&self) -> bool {
        for v in &self.interlockCheck {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.synchroCheck {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interlockCheck)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.synchroCheck)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.interlockCheck.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.synchroCheck.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.interlockCheck.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.synchroCheck.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckConditions {
        CheckConditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "interlockCheck",
                |m: &CheckConditions| { &m.interlockCheck },
                |m: &mut CheckConditions| { &mut m.interlockCheck },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "synchroCheck",
                |m: &CheckConditions| { &m.synchroCheck },
                |m: &mut CheckConditions| { &mut m.synchroCheck },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckConditions>(
                "CheckConditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckConditions {
        static instance: ::protobuf::rt::LazyV2<CheckConditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckConditions::new)
    }
}

impl ::protobuf::Clear for CheckConditions {
    fn clear(&mut self) {
        self.interlockCheck.clear();
        self.synchroCheck.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckConditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Vector {
    // message fields
    ang: ::protobuf::SingularPtrField<AnalogueValue>,
    mag: ::protobuf::SingularPtrField<AnalogueValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector {
    fn default() -> &'a Vector {
        <Vector as ::protobuf::Message>::default_instance()
    }
}

impl Vector {
    pub fn new() -> Vector {
        ::std::default::Default::default()
    }

    // .commonmodule.AnalogueValue ang = 1;


    pub fn get_ang(&self) -> &AnalogueValue {
        self.ang.as_ref().unwrap_or_else(|| <AnalogueValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ang(&mut self) {
        self.ang.clear();
    }

    pub fn has_ang(&self) -> bool {
        self.ang.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang(&mut self, v: AnalogueValue) {
        self.ang = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ang(&mut self) -> &mut AnalogueValue {
        if self.ang.is_none() {
            self.ang.set_default();
        }
        self.ang.as_mut().unwrap()
    }

    // Take field
    pub fn take_ang(&mut self) -> AnalogueValue {
        self.ang.take().unwrap_or_else(|| AnalogueValue::new())
    }

    // .commonmodule.AnalogueValue mag = 2;


    pub fn get_mag(&self) -> &AnalogueValue {
        self.mag.as_ref().unwrap_or_else(|| <AnalogueValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mag(&mut self) {
        self.mag.clear();
    }

    pub fn has_mag(&self) -> bool {
        self.mag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mag(&mut self, v: AnalogueValue) {
        self.mag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mag(&mut self) -> &mut AnalogueValue {
        if self.mag.is_none() {
            self.mag.set_default();
        }
        self.mag.as_mut().unwrap()
    }

    // Take field
    pub fn take_mag(&mut self) -> AnalogueValue {
        self.mag.take().unwrap_or_else(|| AnalogueValue::new())
    }
}

impl ::protobuf::Message for Vector {
    fn is_initialized(&self) -> bool {
        for v in &self.ang {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ang)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ang.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ang.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mag.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector {
        Vector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogueValue>>(
                "ang",
                |m: &Vector| { &m.ang },
                |m: &mut Vector| { &mut m.ang },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogueValue>>(
                "mag",
                |m: &Vector| { &m.mag },
                |m: &mut Vector| { &mut m.mag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vector>(
                "Vector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vector {
        static instance: ::protobuf::rt::LazyV2<Vector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vector::new)
    }
}

impl ::protobuf::Clear for Vector {
    fn clear(&mut self) {
        self.ang.clear();
        self.mag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMV {
    // message fields
    cVal: ::protobuf::SingularPtrField<Vector>,
    q: ::protobuf::SingularPtrField<Quality>,
    t: ::protobuf::SingularPtrField<Timestamp>,
    units: ::protobuf::SingularPtrField<Unit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMV {
    fn default() -> &'a CMV {
        <CMV as ::protobuf::Message>::default_instance()
    }
}

impl CMV {
    pub fn new() -> CMV {
        ::std::default::Default::default()
    }

    // .commonmodule.Vector cVal = 1;


    pub fn get_cVal(&self) -> &Vector {
        self.cVal.as_ref().unwrap_or_else(|| <Vector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cVal(&mut self) {
        self.cVal.clear();
    }

    pub fn has_cVal(&self) -> bool {
        self.cVal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cVal(&mut self, v: Vector) {
        self.cVal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cVal(&mut self) -> &mut Vector {
        if self.cVal.is_none() {
            self.cVal.set_default();
        }
        self.cVal.as_mut().unwrap()
    }

    // Take field
    pub fn take_cVal(&mut self) -> Vector {
        self.cVal.take().unwrap_or_else(|| Vector::new())
    }

    // .commonmodule.Quality q = 2;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }

    // .commonmodule.Unit units = 4;


    pub fn get_units(&self) -> &Unit {
        self.units.as_ref().unwrap_or_else(|| <Unit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Unit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Unit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Unit {
        self.units.take().unwrap_or_else(|| Unit::new())
    }
}

impl ::protobuf::Message for CMV {
    fn is_initialized(&self) -> bool {
        for v in &self.cVal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cVal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cVal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cVal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMV {
        CMV::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector>>(
                "cVal",
                |m: &CMV| { &m.cVal },
                |m: &mut CMV| { &mut m.cVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &CMV| { &m.q },
                |m: &mut CMV| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &CMV| { &m.t },
                |m: &mut CMV| { &mut m.t },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &CMV| { &m.units },
                |m: &mut CMV| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMV>(
                "CMV",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMV {
        static instance: ::protobuf::rt::LazyV2<CMV> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMV::new)
    }
}

impl ::protobuf::Clear for CMV {
    fn clear(&mut self) {
        self.cVal.clear();
        self.q.clear();
        self.t.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMV {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConductingEquipment {
    // message fields
    namedObject: ::protobuf::SingularPtrField<NamedObject>,
    pub mRID: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConductingEquipment {
    fn default() -> &'a ConductingEquipment {
        <ConductingEquipment as ::protobuf::Message>::default_instance()
    }
}

impl ConductingEquipment {
    pub fn new() -> ConductingEquipment {
        ::std::default::Default::default()
    }

    // .commonmodule.NamedObject namedObject = 1;


    pub fn get_namedObject(&self) -> &NamedObject {
        self.namedObject.as_ref().unwrap_or_else(|| <NamedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namedObject(&mut self) {
        self.namedObject.clear();
    }

    pub fn has_namedObject(&self) -> bool {
        self.namedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namedObject(&mut self, v: NamedObject) {
        self.namedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namedObject(&mut self) -> &mut NamedObject {
        if self.namedObject.is_none() {
            self.namedObject.set_default();
        }
        self.namedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_namedObject(&mut self) -> NamedObject {
        self.namedObject.take().unwrap_or_else(|| NamedObject::new())
    }

    // string mRID = 2;


    pub fn get_mRID(&self) -> &str {
        &self.mRID
    }
    pub fn clear_mRID(&mut self) {
        self.mRID.clear();
    }

    // Param is passed by value, moved
    pub fn set_mRID(&mut self, v: ::std::string::String) {
        self.mRID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mRID(&mut self) -> &mut ::std::string::String {
        &mut self.mRID
    }

    // Take field
    pub fn take_mRID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mRID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConductingEquipment {
    fn is_initialized(&self) -> bool {
        for v in &self.namedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namedObject)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mRID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.mRID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mRID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.mRID.is_empty() {
            os.write_string(2, &self.mRID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConductingEquipment {
        ConductingEquipment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamedObject>>(
                "namedObject",
                |m: &ConductingEquipment| { &m.namedObject },
                |m: &mut ConductingEquipment| { &mut m.namedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mRID",
                |m: &ConductingEquipment| { &m.mRID },
                |m: &mut ConductingEquipment| { &mut m.mRID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConductingEquipment>(
                "ConductingEquipment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConductingEquipment {
        static instance: ::protobuf::rt::LazyV2<ConductingEquipment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConductingEquipment::new)
    }
}

impl ::protobuf::Clear for ConductingEquipment {
    fn clear(&mut self) {
        self.namedObject.clear();
        self.mRID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConductingEquipment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConductingEquipment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Terminal {
    // message fields
    aCDCTerminal: ::protobuf::SingularPtrField<ACDCTerminal>,
    phases: ::protobuf::SingularPtrField<Optional_PhaseCodeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Terminal {
    fn default() -> &'a Terminal {
        <Terminal as ::protobuf::Message>::default_instance()
    }
}

impl Terminal {
    pub fn new() -> Terminal {
        ::std::default::Default::default()
    }

    // .commonmodule.ACDCTerminal aCDCTerminal = 1;


    pub fn get_aCDCTerminal(&self) -> &ACDCTerminal {
        self.aCDCTerminal.as_ref().unwrap_or_else(|| <ACDCTerminal as ::protobuf::Message>::default_instance())
    }
    pub fn clear_aCDCTerminal(&mut self) {
        self.aCDCTerminal.clear();
    }

    pub fn has_aCDCTerminal(&self) -> bool {
        self.aCDCTerminal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aCDCTerminal(&mut self, v: ACDCTerminal) {
        self.aCDCTerminal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aCDCTerminal(&mut self) -> &mut ACDCTerminal {
        if self.aCDCTerminal.is_none() {
            self.aCDCTerminal.set_default();
        }
        self.aCDCTerminal.as_mut().unwrap()
    }

    // Take field
    pub fn take_aCDCTerminal(&mut self) -> ACDCTerminal {
        self.aCDCTerminal.take().unwrap_or_else(|| ACDCTerminal::new())
    }

    // .commonmodule.Optional_PhaseCodeKind phases = 2;


    pub fn get_phases(&self) -> &Optional_PhaseCodeKind {
        self.phases.as_ref().unwrap_or_else(|| <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phases(&mut self) {
        self.phases.clear();
    }

    pub fn has_phases(&self) -> bool {
        self.phases.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phases(&mut self, v: Optional_PhaseCodeKind) {
        self.phases = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phases(&mut self) -> &mut Optional_PhaseCodeKind {
        if self.phases.is_none() {
            self.phases.set_default();
        }
        self.phases.as_mut().unwrap()
    }

    // Take field
    pub fn take_phases(&mut self) -> Optional_PhaseCodeKind {
        self.phases.take().unwrap_or_else(|| Optional_PhaseCodeKind::new())
    }
}

impl ::protobuf::Message for Terminal {
    fn is_initialized(&self) -> bool {
        for v in &self.aCDCTerminal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aCDCTerminal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.aCDCTerminal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phases.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.aCDCTerminal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phases.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Terminal {
        Terminal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACDCTerminal>>(
                "aCDCTerminal",
                |m: &Terminal| { &m.aCDCTerminal },
                |m: &mut Terminal| { &mut m.aCDCTerminal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_PhaseCodeKind>>(
                "phases",
                |m: &Terminal| { &m.phases },
                |m: &mut Terminal| { &mut m.phases },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Terminal>(
                "Terminal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Terminal {
        static instance: ::protobuf::rt::LazyV2<Terminal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Terminal::new)
    }
}

impl ::protobuf::Clear for Terminal {
    fn clear(&mut self) {
        self.aCDCTerminal.clear();
        self.phases.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Terminal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Terminal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ConductingEquipmentTerminalReading {
    // message fields
    terminal: ::protobuf::SingularPtrField<Terminal>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConductingEquipmentTerminalReading {
    fn default() -> &'a ConductingEquipmentTerminalReading {
        <ConductingEquipmentTerminalReading as ::protobuf::Message>::default_instance()
    }
}

impl ConductingEquipmentTerminalReading {
    pub fn new() -> ConductingEquipmentTerminalReading {
        ::std::default::Default::default()
    }

    // .commonmodule.Terminal terminal = 1;


    pub fn get_terminal(&self) -> &Terminal {
        self.terminal.as_ref().unwrap_or_else(|| <Terminal as ::protobuf::Message>::default_instance())
    }
    pub fn clear_terminal(&mut self) {
        self.terminal.clear();
    }

    pub fn has_terminal(&self) -> bool {
        self.terminal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: Terminal) {
        self.terminal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminal(&mut self) -> &mut Terminal {
        if self.terminal.is_none() {
            self.terminal.set_default();
        }
        self.terminal.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminal(&mut self) -> Terminal {
        self.terminal.take().unwrap_or_else(|| Terminal::new())
    }
}

impl ::protobuf::Message for ConductingEquipmentTerminalReading {
    fn is_initialized(&self) -> bool {
        for v in &self.terminal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.terminal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.terminal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.terminal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConductingEquipmentTerminalReading {
        ConductingEquipmentTerminalReading::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Terminal>>(
                "terminal",
                |m: &ConductingEquipmentTerminalReading| { &m.terminal },
                |m: &mut ConductingEquipmentTerminalReading| { &mut m.terminal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConductingEquipmentTerminalReading>(
                "ConductingEquipmentTerminalReading",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConductingEquipmentTerminalReading {
        static instance: ::protobuf::rt::LazyV2<ConductingEquipmentTerminalReading> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConductingEquipmentTerminalReading::new)
    }
}

impl ::protobuf::Clear for ConductingEquipmentTerminalReading {
    fn clear(&mut self) {
        self.terminal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConductingEquipmentTerminalReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConductingEquipmentTerminalReading {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlDPC {
    // message fields
    pub ctlVal: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlDPC {
    fn default() -> &'a ControlDPC {
        <ControlDPC as ::protobuf::Message>::default_instance()
    }
}

impl ControlDPC {
    pub fn new() -> ControlDPC {
        ::std::default::Default::default()
    }

    // bool ctlVal = 1;


    pub fn get_ctlVal(&self) -> bool {
        self.ctlVal
    }
    pub fn clear_ctlVal(&mut self) {
        self.ctlVal = false;
    }

    // Param is passed by value, moved
    pub fn set_ctlVal(&mut self, v: bool) {
        self.ctlVal = v;
    }
}

impl ::protobuf::Message for ControlDPC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ctlVal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ctlVal != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ctlVal != false {
            os.write_bool(1, self.ctlVal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlDPC {
        ControlDPC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ctlVal",
                |m: &ControlDPC| { &m.ctlVal },
                |m: &mut ControlDPC| { &mut m.ctlVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlDPC>(
                "ControlDPC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlDPC {
        static instance: ::protobuf::rt::LazyV2<ControlDPC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlDPC::new)
    }
}

impl ::protobuf::Clear for ControlDPC {
    fn clear(&mut self) {
        self.ctlVal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlDPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlDPC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlTimestamp {
    // message fields
    pub fraction: u32,
    pub seconds: u64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlTimestamp {
    fn default() -> &'a ControlTimestamp {
        <ControlTimestamp as ::protobuf::Message>::default_instance()
    }
}

impl ControlTimestamp {
    pub fn new() -> ControlTimestamp {
        ::std::default::Default::default()
    }

    // uint32 fraction = 1;


    pub fn get_fraction(&self) -> u32 {
        self.fraction
    }
    pub fn clear_fraction(&mut self) {
        self.fraction = 0;
    }

    // Param is passed by value, moved
    pub fn set_fraction(&mut self, v: u32) {
        self.fraction = v;
    }

    // uint64 seconds = 2;


    pub fn get_seconds(&self) -> u64 {
        self.seconds
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u64) {
        self.seconds = v;
    }
}

impl ::protobuf::Message for ControlTimestamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fraction = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fraction != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fraction, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seconds != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fraction != 0 {
            os.write_uint32(1, self.fraction)?;
        }
        if self.seconds != 0 {
            os.write_uint64(2, self.seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlTimestamp {
        ControlTimestamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fraction",
                |m: &ControlTimestamp| { &m.fraction },
                |m: &mut ControlTimestamp| { &mut m.fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seconds",
                |m: &ControlTimestamp| { &m.seconds },
                |m: &mut ControlTimestamp| { &mut m.seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlTimestamp>(
                "ControlTimestamp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlTimestamp {
        static instance: ::protobuf::rt::LazyV2<ControlTimestamp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlTimestamp::new)
    }
}

impl ::protobuf::Clear for ControlTimestamp {
    fn clear(&mut self) {
        self.fraction = 0;
        self.seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlTimestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlTimestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_ScheduleParameterKind {
    // message fields
    pub value: ScheduleParameterKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_ScheduleParameterKind {
    fn default() -> &'a Optional_ScheduleParameterKind {
        <Optional_ScheduleParameterKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_ScheduleParameterKind {
    pub fn new() -> Optional_ScheduleParameterKind {
        ::std::default::Default::default()
    }

    // .commonmodule.ScheduleParameterKind value = 1;


    pub fn get_value(&self) -> ScheduleParameterKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = ScheduleParameterKind::ScheduleParameterKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ScheduleParameterKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_ScheduleParameterKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ScheduleParameterKind::ScheduleParameterKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != ScheduleParameterKind::ScheduleParameterKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_ScheduleParameterKind {
        Optional_ScheduleParameterKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ScheduleParameterKind>>(
                "value",
                |m: &Optional_ScheduleParameterKind| { &m.value },
                |m: &mut Optional_ScheduleParameterKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_ScheduleParameterKind>(
                "Optional_ScheduleParameterKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_ScheduleParameterKind {
        static instance: ::protobuf::rt::LazyV2<Optional_ScheduleParameterKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_ScheduleParameterKind::new)
    }
}

impl ::protobuf::Clear for Optional_ScheduleParameterKind {
    fn clear(&mut self) {
        self.value = ScheduleParameterKind::ScheduleParameterKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_ScheduleParameterKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_ScheduleParameterKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENG_ScheduleParameter {
    // message fields
    pub scheduleParameterType: ScheduleParameterKind,
    pub value: f32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENG_ScheduleParameter {
    fn default() -> &'a ENG_ScheduleParameter {
        <ENG_ScheduleParameter as ::protobuf::Message>::default_instance()
    }
}

impl ENG_ScheduleParameter {
    pub fn new() -> ENG_ScheduleParameter {
        ::std::default::Default::default()
    }

    // .commonmodule.ScheduleParameterKind scheduleParameterType = 1;


    pub fn get_scheduleParameterType(&self) -> ScheduleParameterKind {
        self.scheduleParameterType
    }
    pub fn clear_scheduleParameterType(&mut self) {
        self.scheduleParameterType = ScheduleParameterKind::ScheduleParameterKind_none;
    }

    // Param is passed by value, moved
    pub fn set_scheduleParameterType(&mut self, v: ScheduleParameterKind) {
        self.scheduleParameterType = v;
    }

    // float value = 2;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }
}

impl ::protobuf::Message for ENG_ScheduleParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.scheduleParameterType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.scheduleParameterType != ScheduleParameterKind::ScheduleParameterKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.scheduleParameterType);
        }
        if self.value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.scheduleParameterType != ScheduleParameterKind::ScheduleParameterKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.scheduleParameterType))?;
        }
        if self.value != 0. {
            os.write_float(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENG_ScheduleParameter {
        ENG_ScheduleParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ScheduleParameterKind>>(
                "scheduleParameterType",
                |m: &ENG_ScheduleParameter| { &m.scheduleParameterType },
                |m: &mut ENG_ScheduleParameter| { &mut m.scheduleParameterType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &ENG_ScheduleParameter| { &m.value },
                |m: &mut ENG_ScheduleParameter| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENG_ScheduleParameter>(
                "ENG_ScheduleParameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENG_ScheduleParameter {
        static instance: ::protobuf::rt::LazyV2<ENG_ScheduleParameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENG_ScheduleParameter::new)
    }
}

impl ::protobuf::Clear for ENG_ScheduleParameter {
    fn clear(&mut self) {
        self.scheduleParameterType = ScheduleParameterKind::ScheduleParameterKind_none;
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENG_ScheduleParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENG_ScheduleParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SchedulePoint {
    // message fields
    scheduleParameter: ::protobuf::RepeatedField<ENG_ScheduleParameter>,
    startTime: ::protobuf::SingularPtrField<ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchedulePoint {
    fn default() -> &'a SchedulePoint {
        <SchedulePoint as ::protobuf::Message>::default_instance()
    }
}

impl SchedulePoint {
    pub fn new() -> SchedulePoint {
        ::std::default::Default::default()
    }

    // repeated .commonmodule.ENG_ScheduleParameter scheduleParameter = 1;


    pub fn get_scheduleParameter(&self) -> &[ENG_ScheduleParameter] {
        &self.scheduleParameter
    }
    pub fn clear_scheduleParameter(&mut self) {
        self.scheduleParameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduleParameter(&mut self, v: ::protobuf::RepeatedField<ENG_ScheduleParameter>) {
        self.scheduleParameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scheduleParameter(&mut self) -> &mut ::protobuf::RepeatedField<ENG_ScheduleParameter> {
        &mut self.scheduleParameter
    }

    // Take field
    pub fn take_scheduleParameter(&mut self) -> ::protobuf::RepeatedField<ENG_ScheduleParameter> {
        ::std::mem::replace(&mut self.scheduleParameter, ::protobuf::RepeatedField::new())
    }

    // .commonmodule.ControlTimestamp startTime = 2;


    pub fn get_startTime(&self) -> &ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| ControlTimestamp::new())
    }
}

impl ::protobuf::Message for SchedulePoint {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduleParameter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scheduleParameter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.scheduleParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.scheduleParameter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchedulePoint {
        SchedulePoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_ScheduleParameter>>(
                "scheduleParameter",
                |m: &SchedulePoint| { &m.scheduleParameter },
                |m: &mut SchedulePoint| { &mut m.scheduleParameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlTimestamp>>(
                "startTime",
                |m: &SchedulePoint| { &m.startTime },
                |m: &mut SchedulePoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchedulePoint>(
                "SchedulePoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchedulePoint {
        static instance: ::protobuf::rt::LazyV2<SchedulePoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchedulePoint::new)
    }
}

impl ::protobuf::Clear for SchedulePoint {
    fn clear(&mut self) {
        self.scheduleParameter.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchedulePoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchedulePoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ScheduleCSG {
    // message fields
    schPts: ::protobuf::RepeatedField<SchedulePoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScheduleCSG {
    fn default() -> &'a ScheduleCSG {
        <ScheduleCSG as ::protobuf::Message>::default_instance()
    }
}

impl ScheduleCSG {
    pub fn new() -> ScheduleCSG {
        ::std::default::Default::default()
    }

    // repeated .commonmodule.SchedulePoint schPts = 1;


    pub fn get_schPts(&self) -> &[SchedulePoint] {
        &self.schPts
    }
    pub fn clear_schPts(&mut self) {
        self.schPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_schPts(&mut self, v: ::protobuf::RepeatedField<SchedulePoint>) {
        self.schPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_schPts(&mut self) -> &mut ::protobuf::RepeatedField<SchedulePoint> {
        &mut self.schPts
    }

    // Take field
    pub fn take_schPts(&mut self) -> ::protobuf::RepeatedField<SchedulePoint> {
        ::std::mem::replace(&mut self.schPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScheduleCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.schPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.schPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.schPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.schPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScheduleCSG {
        ScheduleCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchedulePoint>>(
                "schPts",
                |m: &ScheduleCSG| { &m.schPts },
                |m: &mut ScheduleCSG| { &mut m.schPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScheduleCSG>(
                "ScheduleCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScheduleCSG {
        static instance: ::protobuf::rt::LazyV2<ScheduleCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScheduleCSG::new)
    }
}

impl ::protobuf::Clear for ScheduleCSG {
    fn clear(&mut self) {
        self.schPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScheduleCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScheduleCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlScheduleFSCH {
    // message fields
    ValACSG: ::protobuf::SingularPtrField<ScheduleCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlScheduleFSCH {
    fn default() -> &'a ControlScheduleFSCH {
        <ControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl ControlScheduleFSCH {
    pub fn new() -> ControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .commonmodule.ScheduleCSG ValACSG = 1;


    pub fn get_ValACSG(&self) -> &ScheduleCSG {
        self.ValACSG.as_ref().unwrap_or_else(|| <ScheduleCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValACSG(&mut self) {
        self.ValACSG.clear();
    }

    pub fn has_ValACSG(&self) -> bool {
        self.ValACSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValACSG(&mut self, v: ScheduleCSG) {
        self.ValACSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValACSG(&mut self) -> &mut ScheduleCSG {
        if self.ValACSG.is_none() {
            self.ValACSG.set_default();
        }
        self.ValACSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValACSG(&mut self) -> ScheduleCSG {
        self.ValACSG.take().unwrap_or_else(|| ScheduleCSG::new())
    }
}

impl ::protobuf::Message for ControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValACSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValACSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValACSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValACSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlScheduleFSCH {
        ControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScheduleCSG>>(
                "ValACSG",
                |m: &ControlScheduleFSCH| { &m.ValACSG },
                |m: &mut ControlScheduleFSCH| { &mut m.ValACSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlScheduleFSCH>(
                "ControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<ControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for ControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValACSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LogicalNodeForControl {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogicalNodeForControl {
    fn default() -> &'a LogicalNodeForControl {
        <LogicalNodeForControl as ::protobuf::Message>::default_instance()
    }
}

impl LogicalNodeForControl {
    pub fn new() -> LogicalNodeForControl {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }
}

impl ::protobuf::Message for LogicalNodeForControl {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalNodeForControl {
        LogicalNodeForControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &LogicalNodeForControl| { &m.logicalNode },
                |m: &mut LogicalNodeForControl| { &mut m.logicalNode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogicalNodeForControl>(
                "LogicalNodeForControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogicalNodeForControl {
        static instance: ::protobuf::rt::LazyV2<LogicalNodeForControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogicalNodeForControl::new)
    }
}

impl ::protobuf::Clear for LogicalNodeForControl {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalNodeForControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalNodeForControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlFSCC {
    // message fields
    logicalNodeForControl: ::protobuf::SingularPtrField<LogicalNodeForControl>,
    controlScheduleFSCH: ::protobuf::SingularPtrField<ControlScheduleFSCH>,
    islandControlScheduleFSCH: ::protobuf::SingularPtrField<ControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlFSCC {
    fn default() -> &'a ControlFSCC {
        <ControlFSCC as ::protobuf::Message>::default_instance()
    }
}

impl ControlFSCC {
    pub fn new() -> ControlFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1;


    pub fn get_logicalNodeForControl(&self) -> &LogicalNodeForControl {
        self.logicalNodeForControl.as_ref().unwrap_or_else(|| <LogicalNodeForControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForControl(&mut self) {
        self.logicalNodeForControl.clear();
    }

    pub fn has_logicalNodeForControl(&self) -> bool {
        self.logicalNodeForControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForControl(&mut self, v: LogicalNodeForControl) {
        self.logicalNodeForControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForControl(&mut self) -> &mut LogicalNodeForControl {
        if self.logicalNodeForControl.is_none() {
            self.logicalNodeForControl.set_default();
        }
        self.logicalNodeForControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForControl(&mut self) -> LogicalNodeForControl {
        self.logicalNodeForControl.take().unwrap_or_else(|| LogicalNodeForControl::new())
    }

    // .commonmodule.ControlScheduleFSCH controlScheduleFSCH = 2;


    pub fn get_controlScheduleFSCH(&self) -> &ControlScheduleFSCH {
        self.controlScheduleFSCH.as_ref().unwrap_or_else(|| <ControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlScheduleFSCH(&mut self) {
        self.controlScheduleFSCH.clear();
    }

    pub fn has_controlScheduleFSCH(&self) -> bool {
        self.controlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlScheduleFSCH(&mut self, v: ControlScheduleFSCH) {
        self.controlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlScheduleFSCH(&mut self) -> &mut ControlScheduleFSCH {
        if self.controlScheduleFSCH.is_none() {
            self.controlScheduleFSCH.set_default();
        }
        self.controlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlScheduleFSCH(&mut self) -> ControlScheduleFSCH {
        self.controlScheduleFSCH.take().unwrap_or_else(|| ControlScheduleFSCH::new())
    }

    // .commonmodule.ControlScheduleFSCH islandControlScheduleFSCH = 3;


    pub fn get_islandControlScheduleFSCH(&self) -> &ControlScheduleFSCH {
        self.islandControlScheduleFSCH.as_ref().unwrap_or_else(|| <ControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_islandControlScheduleFSCH(&mut self) {
        self.islandControlScheduleFSCH.clear();
    }

    pub fn has_islandControlScheduleFSCH(&self) -> bool {
        self.islandControlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_islandControlScheduleFSCH(&mut self, v: ControlScheduleFSCH) {
        self.islandControlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_islandControlScheduleFSCH(&mut self) -> &mut ControlScheduleFSCH {
        if self.islandControlScheduleFSCH.is_none() {
            self.islandControlScheduleFSCH.set_default();
        }
        self.islandControlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_islandControlScheduleFSCH(&mut self) -> ControlScheduleFSCH {
        self.islandControlScheduleFSCH.take().unwrap_or_else(|| ControlScheduleFSCH::new())
    }
}

impl ::protobuf::Message for ControlFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.controlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.islandControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForControl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlScheduleFSCH)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.islandControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.controlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.islandControlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForControl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.controlScheduleFSCH.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.islandControlScheduleFSCH.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlFSCC {
        ControlFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNodeForControl>>(
                "logicalNodeForControl",
                |m: &ControlFSCC| { &m.logicalNodeForControl },
                |m: &mut ControlFSCC| { &mut m.logicalNodeForControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlScheduleFSCH>>(
                "controlScheduleFSCH",
                |m: &ControlFSCC| { &m.controlScheduleFSCH },
                |m: &mut ControlFSCC| { &mut m.controlScheduleFSCH },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlScheduleFSCH>>(
                "islandControlScheduleFSCH",
                |m: &ControlFSCC| { &m.islandControlScheduleFSCH },
                |m: &mut ControlFSCC| { &mut m.islandControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlFSCC>(
                "ControlFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlFSCC {
        static instance: ::protobuf::rt::LazyV2<ControlFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlFSCC::new)
    }
}

impl ::protobuf::Clear for ControlFSCC {
    fn clear(&mut self) {
        self.logicalNodeForControl.clear();
        self.controlScheduleFSCH.clear();
        self.islandControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlING {
    // message fields
    pub setVal: i32,
    units: ::protobuf::SingularPtrField<Unit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlING {
    fn default() -> &'a ControlING {
        <ControlING as ::protobuf::Message>::default_instance()
    }
}

impl ControlING {
    pub fn new() -> ControlING {
        ::std::default::Default::default()
    }

    // int32 setVal = 1;


    pub fn get_setVal(&self) -> i32 {
        self.setVal
    }
    pub fn clear_setVal(&mut self) {
        self.setVal = 0;
    }

    // Param is passed by value, moved
    pub fn set_setVal(&mut self, v: i32) {
        self.setVal = v;
    }

    // .commonmodule.Unit units = 2;


    pub fn get_units(&self) -> &Unit {
        self.units.as_ref().unwrap_or_else(|| <Unit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Unit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Unit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Unit {
        self.units.take().unwrap_or_else(|| Unit::new())
    }
}

impl ::protobuf::Message for ControlING {
    fn is_initialized(&self) -> bool {
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.setVal = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.setVal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.setVal, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.setVal != 0 {
            os.write_int32(1, self.setVal)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlING {
        ControlING::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "setVal",
                |m: &ControlING| { &m.setVal },
                |m: &mut ControlING| { &mut m.setVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &ControlING| { &m.units },
                |m: &mut ControlING| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlING>(
                "ControlING",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlING {
        static instance: ::protobuf::rt::LazyV2<ControlING> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlING::new)
    }
}

impl ::protobuf::Clear for ControlING {
    fn clear(&mut self) {
        self.setVal = 0;
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlING {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlING {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlISC {
    // message fields
    pub ctlVal: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlISC {
    fn default() -> &'a ControlISC {
        <ControlISC as ::protobuf::Message>::default_instance()
    }
}

impl ControlISC {
    pub fn new() -> ControlISC {
        ::std::default::Default::default()
    }

    // int32 ctlVal = 1;


    pub fn get_ctlVal(&self) -> i32 {
        self.ctlVal
    }
    pub fn clear_ctlVal(&mut self) {
        self.ctlVal = 0;
    }

    // Param is passed by value, moved
    pub fn set_ctlVal(&mut self, v: i32) {
        self.ctlVal = v;
    }
}

impl ::protobuf::Message for ControlISC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ctlVal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ctlVal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ctlVal, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ctlVal != 0 {
            os.write_int32(1, self.ctlVal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlISC {
        ControlISC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ctlVal",
                |m: &ControlISC| { &m.ctlVal },
                |m: &mut ControlISC| { &mut m.ctlVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlISC>(
                "ControlISC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlISC {
        static instance: ::protobuf::rt::LazyV2<ControlISC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlISC::new)
    }
}

impl ::protobuf::Clear for ControlISC {
    fn clear(&mut self) {
        self.ctlVal = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlISC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlISC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MessageInfo {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    messageTimeStamp: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageInfo {
    fn default() -> &'a MessageInfo {
        <MessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl MessageInfo {
    pub fn new() -> MessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }

    // .commonmodule.Timestamp messageTimeStamp = 2;


    pub fn get_messageTimeStamp(&self) -> &Timestamp {
        self.messageTimeStamp.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageTimeStamp(&mut self) {
        self.messageTimeStamp.clear();
    }

    pub fn has_messageTimeStamp(&self) -> bool {
        self.messageTimeStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimeStamp(&mut self, v: Timestamp) {
        self.messageTimeStamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageTimeStamp(&mut self) -> &mut Timestamp {
        if self.messageTimeStamp.is_none() {
            self.messageTimeStamp.set_default();
        }
        self.messageTimeStamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageTimeStamp(&mut self) -> Timestamp {
        self.messageTimeStamp.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for MessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.messageTimeStamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageTimeStamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.messageTimeStamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.messageTimeStamp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageInfo {
        MessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &MessageInfo| { &m.identifiedObject },
                |m: &mut MessageInfo| { &mut m.identifiedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "messageTimeStamp",
                |m: &MessageInfo| { &m.messageTimeStamp },
                |m: &mut MessageInfo| { &mut m.messageTimeStamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageInfo>(
                "MessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageInfo {
        static instance: ::protobuf::rt::LazyV2<MessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageInfo::new)
    }
}

impl ::protobuf::Clear for MessageInfo {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.messageTimeStamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlMessageInfo {
    // message fields
    messageInfo: ::protobuf::SingularPtrField<MessageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlMessageInfo {
    fn default() -> &'a ControlMessageInfo {
        <ControlMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl ControlMessageInfo {
    pub fn new() -> ControlMessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.MessageInfo messageInfo = 1;


    pub fn get_messageInfo(&self) -> &MessageInfo {
        self.messageInfo.as_ref().unwrap_or_else(|| <MessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageInfo(&mut self) {
        self.messageInfo.clear();
    }

    pub fn has_messageInfo(&self) -> bool {
        self.messageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageInfo(&mut self, v: MessageInfo) {
        self.messageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageInfo(&mut self) -> &mut MessageInfo {
        if self.messageInfo.is_none() {
            self.messageInfo.set_default();
        }
        self.messageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageInfo(&mut self) -> MessageInfo {
        self.messageInfo.take().unwrap_or_else(|| MessageInfo::new())
    }
}

impl ::protobuf::Message for ControlMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.messageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlMessageInfo {
        ControlMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageInfo>>(
                "messageInfo",
                |m: &ControlMessageInfo| { &m.messageInfo },
                |m: &mut ControlMessageInfo| { &mut m.messageInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlMessageInfo>(
                "ControlMessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlMessageInfo {
        static instance: ::protobuf::rt::LazyV2<ControlMessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlMessageInfo::new)
    }
}

impl ::protobuf::Clear for ControlMessageInfo {
    fn clear(&mut self) {
        self.messageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlSPC {
    // message fields
    pub ctlVal: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlSPC {
    fn default() -> &'a ControlSPC {
        <ControlSPC as ::protobuf::Message>::default_instance()
    }
}

impl ControlSPC {
    pub fn new() -> ControlSPC {
        ::std::default::Default::default()
    }

    // bool ctlVal = 1;


    pub fn get_ctlVal(&self) -> bool {
        self.ctlVal
    }
    pub fn clear_ctlVal(&mut self) {
        self.ctlVal = false;
    }

    // Param is passed by value, moved
    pub fn set_ctlVal(&mut self, v: bool) {
        self.ctlVal = v;
    }
}

impl ::protobuf::Message for ControlSPC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ctlVal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ctlVal != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ctlVal != false {
            os.write_bool(1, self.ctlVal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlSPC {
        ControlSPC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ctlVal",
                |m: &ControlSPC| { &m.ctlVal },
                |m: &mut ControlSPC| { &mut m.ctlVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlSPC>(
                "ControlSPC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlSPC {
        static instance: ::protobuf::rt::LazyV2<ControlSPC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlSPC::new)
    }
}

impl ::protobuf::Clear for ControlSPC {
    fn clear(&mut self) {
        self.ctlVal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlSPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlSPC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ControlValue {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    modBlk: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlValue {
    fn default() -> &'a ControlValue {
        <ControlValue as ::protobuf::Message>::default_instance()
    }
}

impl ControlValue {
    pub fn new() -> ControlValue {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }

    // .google.protobuf.BoolValue modBlk = 2;


    pub fn get_modBlk(&self) -> &::protobuf::well_known_types::BoolValue {
        self.modBlk.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modBlk(&mut self) {
        self.modBlk.clear();
    }

    pub fn has_modBlk(&self) -> bool {
        self.modBlk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modBlk(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.modBlk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modBlk(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.modBlk.is_none() {
            self.modBlk.set_default();
        }
        self.modBlk.as_mut().unwrap()
    }

    // Take field
    pub fn take_modBlk(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.modBlk.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for ControlValue {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modBlk {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modBlk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modBlk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modBlk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlValue {
        ControlValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &ControlValue| { &m.identifiedObject },
                |m: &mut ControlValue| { &mut m.identifiedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "modBlk",
                |m: &ControlValue| { &m.modBlk },
                |m: &mut ControlValue| { &mut m.modBlk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlValue>(
                "ControlValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlValue {
        static instance: ::protobuf::rt::LazyV2<ControlValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlValue::new)
    }
}

impl ::protobuf::Clear for ControlValue {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.modBlk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DateTimeInterval {
    // message fields
    end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DateTimeInterval {
    fn default() -> &'a DateTimeInterval {
        <DateTimeInterval as ::protobuf::Message>::default_instance()
    }
}

impl DateTimeInterval {
    pub fn new() -> DateTimeInterval {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value end = 1;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Int64Value {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value start = 2;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Int64Value {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }
}

impl ::protobuf::Message for DateTimeInterval {
    fn is_initialized(&self) -> bool {
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DateTimeInterval {
        DateTimeInterval::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "end",
                |m: &DateTimeInterval| { &m.end },
                |m: &mut DateTimeInterval| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "start",
                |m: &DateTimeInterval| { &m.start },
                |m: &mut DateTimeInterval| { &mut m.start },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DateTimeInterval>(
                "DateTimeInterval",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DateTimeInterval {
        static instance: ::protobuf::rt::LazyV2<DateTimeInterval> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DateTimeInterval::new)
    }
}

impl ::protobuf::Clear for DateTimeInterval {
    fn clear(&mut self) {
        self.end.clear();
        self.start.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DateTimeInterval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateTimeInterval {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DEL {
    // message fields
    phsAB: ::protobuf::SingularPtrField<CMV>,
    phsBC: ::protobuf::SingularPtrField<CMV>,
    phsCA: ::protobuf::SingularPtrField<CMV>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DEL {
    fn default() -> &'a DEL {
        <DEL as ::protobuf::Message>::default_instance()
    }
}

impl DEL {
    pub fn new() -> DEL {
        ::std::default::Default::default()
    }

    // .commonmodule.CMV phsAB = 1;


    pub fn get_phsAB(&self) -> &CMV {
        self.phsAB.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsAB(&mut self) {
        self.phsAB.clear();
    }

    pub fn has_phsAB(&self) -> bool {
        self.phsAB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsAB(&mut self, v: CMV) {
        self.phsAB = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsAB(&mut self) -> &mut CMV {
        if self.phsAB.is_none() {
            self.phsAB.set_default();
        }
        self.phsAB.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsAB(&mut self) -> CMV {
        self.phsAB.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV phsBC = 2;


    pub fn get_phsBC(&self) -> &CMV {
        self.phsBC.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsBC(&mut self) {
        self.phsBC.clear();
    }

    pub fn has_phsBC(&self) -> bool {
        self.phsBC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsBC(&mut self, v: CMV) {
        self.phsBC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsBC(&mut self) -> &mut CMV {
        if self.phsBC.is_none() {
            self.phsBC.set_default();
        }
        self.phsBC.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsBC(&mut self) -> CMV {
        self.phsBC.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV phsCA = 3;


    pub fn get_phsCA(&self) -> &CMV {
        self.phsCA.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsCA(&mut self) {
        self.phsCA.clear();
    }

    pub fn has_phsCA(&self) -> bool {
        self.phsCA.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsCA(&mut self, v: CMV) {
        self.phsCA = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsCA(&mut self) -> &mut CMV {
        if self.phsCA.is_none() {
            self.phsCA.set_default();
        }
        self.phsCA.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsCA(&mut self) -> CMV {
        self.phsCA.take().unwrap_or_else(|| CMV::new())
    }
}

impl ::protobuf::Message for DEL {
    fn is_initialized(&self) -> bool {
        for v in &self.phsAB {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsBC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsCA {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsAB)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsBC)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsCA)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phsAB.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsBC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsCA.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phsAB.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsBC.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsCA.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DEL {
        DEL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsAB",
                |m: &DEL| { &m.phsAB },
                |m: &mut DEL| { &mut m.phsAB },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsBC",
                |m: &DEL| { &m.phsBC },
                |m: &mut DEL| { &mut m.phsBC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsCA",
                |m: &DEL| { &m.phsCA },
                |m: &mut DEL| { &mut m.phsCA },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DEL>(
                "DEL",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DEL {
        static instance: ::protobuf::rt::LazyV2<DEL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DEL::new)
    }
}

impl ::protobuf::Clear for DEL {
    fn clear(&mut self) {
        self.phsAB.clear();
        self.phsBC.clear();
        self.phsCA.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DEL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DEL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EnergyConsumer {
    // message fields
    conductingEquipment: ::protobuf::SingularPtrField<ConductingEquipment>,
    operatingLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnergyConsumer {
    fn default() -> &'a EnergyConsumer {
        <EnergyConsumer as ::protobuf::Message>::default_instance()
    }
}

impl EnergyConsumer {
    pub fn new() -> EnergyConsumer {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipment conductingEquipment = 1;


    pub fn get_conductingEquipment(&self) -> &ConductingEquipment {
        self.conductingEquipment.as_ref().unwrap_or_else(|| <ConductingEquipment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipment(&mut self) {
        self.conductingEquipment.clear();
    }

    pub fn has_conductingEquipment(&self) -> bool {
        self.conductingEquipment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipment(&mut self, v: ConductingEquipment) {
        self.conductingEquipment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipment(&mut self) -> &mut ConductingEquipment {
        if self.conductingEquipment.is_none() {
            self.conductingEquipment.set_default();
        }
        self.conductingEquipment.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipment(&mut self) -> ConductingEquipment {
        self.conductingEquipment.take().unwrap_or_else(|| ConductingEquipment::new())
    }

    // .google.protobuf.StringValue operatingLimit = 2;


    pub fn get_operatingLimit(&self) -> &::protobuf::well_known_types::StringValue {
        self.operatingLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_operatingLimit(&mut self) {
        self.operatingLimit.clear();
    }

    pub fn has_operatingLimit(&self) -> bool {
        self.operatingLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operatingLimit(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.operatingLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operatingLimit(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.operatingLimit.is_none() {
            self.operatingLimit.set_default();
        }
        self.operatingLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_operatingLimit(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.operatingLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }
}

impl ::protobuf::Message for EnergyConsumer {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operatingLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operatingLimit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.operatingLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.operatingLimit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnergyConsumer {
        EnergyConsumer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConductingEquipment>>(
                "conductingEquipment",
                |m: &EnergyConsumer| { &m.conductingEquipment },
                |m: &mut EnergyConsumer| { &mut m.conductingEquipment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "operatingLimit",
                |m: &EnergyConsumer| { &m.operatingLimit },
                |m: &mut EnergyConsumer| { &mut m.operatingLimit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnergyConsumer>(
                "EnergyConsumer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnergyConsumer {
        static instance: ::protobuf::rt::LazyV2<EnergyConsumer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnergyConsumer::new)
    }
}

impl ::protobuf::Clear for EnergyConsumer {
    fn clear(&mut self) {
        self.conductingEquipment.clear();
        self.operatingLimit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnergyConsumer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnergyConsumer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_CalcMethodKind {
    // message fields
    pub value: CalcMethodKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_CalcMethodKind {
    fn default() -> &'a Optional_CalcMethodKind {
        <Optional_CalcMethodKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_CalcMethodKind {
    pub fn new() -> Optional_CalcMethodKind {
        ::std::default::Default::default()
    }

    // .commonmodule.CalcMethodKind value = 1;


    pub fn get_value(&self) -> CalcMethodKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = CalcMethodKind::CalcMethodKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CalcMethodKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_CalcMethodKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CalcMethodKind::CalcMethodKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != CalcMethodKind::CalcMethodKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_CalcMethodKind {
        Optional_CalcMethodKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalcMethodKind>>(
                "value",
                |m: &Optional_CalcMethodKind| { &m.value },
                |m: &mut Optional_CalcMethodKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_CalcMethodKind>(
                "Optional_CalcMethodKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_CalcMethodKind {
        static instance: ::protobuf::rt::LazyV2<Optional_CalcMethodKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_CalcMethodKind::new)
    }
}

impl ::protobuf::Clear for Optional_CalcMethodKind {
    fn clear(&mut self) {
        self.value = CalcMethodKind::CalcMethodKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_CalcMethodKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_CalcMethodKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENG_CalcMethodKind {
    // message fields
    pub setVal: CalcMethodKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENG_CalcMethodKind {
    fn default() -> &'a ENG_CalcMethodKind {
        <ENG_CalcMethodKind as ::protobuf::Message>::default_instance()
    }
}

impl ENG_CalcMethodKind {
    pub fn new() -> ENG_CalcMethodKind {
        ::std::default::Default::default()
    }

    // .commonmodule.CalcMethodKind setVal = 1;


    pub fn get_setVal(&self) -> CalcMethodKind {
        self.setVal
    }
    pub fn clear_setVal(&mut self) {
        self.setVal = CalcMethodKind::CalcMethodKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_setVal(&mut self, v: CalcMethodKind) {
        self.setVal = v;
    }
}

impl ::protobuf::Message for ENG_CalcMethodKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.setVal, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.setVal != CalcMethodKind::CalcMethodKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.setVal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.setVal != CalcMethodKind::CalcMethodKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.setVal))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENG_CalcMethodKind {
        ENG_CalcMethodKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalcMethodKind>>(
                "setVal",
                |m: &ENG_CalcMethodKind| { &m.setVal },
                |m: &mut ENG_CalcMethodKind| { &mut m.setVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENG_CalcMethodKind>(
                "ENG_CalcMethodKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENG_CalcMethodKind {
        static instance: ::protobuf::rt::LazyV2<ENG_CalcMethodKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENG_CalcMethodKind::new)
    }
}

impl ::protobuf::Clear for ENG_CalcMethodKind {
    fn clear(&mut self) {
        self.setVal = CalcMethodKind::CalcMethodKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENG_CalcMethodKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENG_CalcMethodKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_GridConnectModeKind {
    // message fields
    pub value: GridConnectModeKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_GridConnectModeKind {
    fn default() -> &'a Optional_GridConnectModeKind {
        <Optional_GridConnectModeKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_GridConnectModeKind {
    pub fn new() -> Optional_GridConnectModeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.GridConnectModeKind value = 1;


    pub fn get_value(&self) -> GridConnectModeKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GridConnectModeKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_GridConnectModeKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_GridConnectModeKind {
        Optional_GridConnectModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GridConnectModeKind>>(
                "value",
                |m: &Optional_GridConnectModeKind| { &m.value },
                |m: &mut Optional_GridConnectModeKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_GridConnectModeKind>(
                "Optional_GridConnectModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_GridConnectModeKind {
        static instance: ::protobuf::rt::LazyV2<Optional_GridConnectModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_GridConnectModeKind::new)
    }
}

impl ::protobuf::Clear for Optional_GridConnectModeKind {
    fn clear(&mut self) {
        self.value = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_GridConnectModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_GridConnectModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENG_GridConnectModeKind {
    // message fields
    pub setVal: GridConnectModeKind,
    setValExtension: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENG_GridConnectModeKind {
    fn default() -> &'a ENG_GridConnectModeKind {
        <ENG_GridConnectModeKind as ::protobuf::Message>::default_instance()
    }
}

impl ENG_GridConnectModeKind {
    pub fn new() -> ENG_GridConnectModeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.GridConnectModeKind setVal = 1;


    pub fn get_setVal(&self) -> GridConnectModeKind {
        self.setVal
    }
    pub fn clear_setVal(&mut self) {
        self.setVal = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_setVal(&mut self, v: GridConnectModeKind) {
        self.setVal = v;
    }

    // .google.protobuf.StringValue setValExtension = 2;


    pub fn get_setValExtension(&self) -> &::protobuf::well_known_types::StringValue {
        self.setValExtension.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_setValExtension(&mut self) {
        self.setValExtension.clear();
    }

    pub fn has_setValExtension(&self) -> bool {
        self.setValExtension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setValExtension(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.setValExtension = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setValExtension(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.setValExtension.is_none() {
            self.setValExtension.set_default();
        }
        self.setValExtension.as_mut().unwrap()
    }

    // Take field
    pub fn take_setValExtension(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.setValExtension.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }
}

impl ::protobuf::Message for ENG_GridConnectModeKind {
    fn is_initialized(&self) -> bool {
        for v in &self.setValExtension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.setVal, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.setValExtension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.setVal != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.setVal);
        }
        if let Some(ref v) = self.setValExtension.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.setVal != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.setVal))?;
        }
        if let Some(ref v) = self.setValExtension.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENG_GridConnectModeKind {
        ENG_GridConnectModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GridConnectModeKind>>(
                "setVal",
                |m: &ENG_GridConnectModeKind| { &m.setVal },
                |m: &mut ENG_GridConnectModeKind| { &mut m.setVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "setValExtension",
                |m: &ENG_GridConnectModeKind| { &m.setValExtension },
                |m: &mut ENG_GridConnectModeKind| { &mut m.setValExtension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENG_GridConnectModeKind>(
                "ENG_GridConnectModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENG_GridConnectModeKind {
        static instance: ::protobuf::rt::LazyV2<ENG_GridConnectModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENG_GridConnectModeKind::new)
    }
}

impl ::protobuf::Clear for ENG_GridConnectModeKind {
    fn clear(&mut self) {
        self.setVal = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
        self.setValExtension.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENG_GridConnectModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENG_GridConnectModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_PFSignKind {
    // message fields
    pub value: PFSignKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_PFSignKind {
    fn default() -> &'a Optional_PFSignKind {
        <Optional_PFSignKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_PFSignKind {
    pub fn new() -> Optional_PFSignKind {
        ::std::default::Default::default()
    }

    // .commonmodule.PFSignKind value = 1;


    pub fn get_value(&self) -> PFSignKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = PFSignKind::PFSignKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PFSignKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_PFSignKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PFSignKind::PFSignKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != PFSignKind::PFSignKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_PFSignKind {
        Optional_PFSignKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PFSignKind>>(
                "value",
                |m: &Optional_PFSignKind| { &m.value },
                |m: &mut Optional_PFSignKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_PFSignKind>(
                "Optional_PFSignKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_PFSignKind {
        static instance: ::protobuf::rt::LazyV2<Optional_PFSignKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_PFSignKind::new)
    }
}

impl ::protobuf::Clear for Optional_PFSignKind {
    fn clear(&mut self) {
        self.value = PFSignKind::PFSignKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_PFSignKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_PFSignKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENG_PFSignKind {
    // message fields
    pub setVal: PFSignKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENG_PFSignKind {
    fn default() -> &'a ENG_PFSignKind {
        <ENG_PFSignKind as ::protobuf::Message>::default_instance()
    }
}

impl ENG_PFSignKind {
    pub fn new() -> ENG_PFSignKind {
        ::std::default::Default::default()
    }

    // .commonmodule.PFSignKind setVal = 1;


    pub fn get_setVal(&self) -> PFSignKind {
        self.setVal
    }
    pub fn clear_setVal(&mut self) {
        self.setVal = PFSignKind::PFSignKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_setVal(&mut self, v: PFSignKind) {
        self.setVal = v;
    }
}

impl ::protobuf::Message for ENG_PFSignKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.setVal, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.setVal != PFSignKind::PFSignKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.setVal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.setVal != PFSignKind::PFSignKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.setVal))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENG_PFSignKind {
        ENG_PFSignKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PFSignKind>>(
                "setVal",
                |m: &ENG_PFSignKind| { &m.setVal },
                |m: &mut ENG_PFSignKind| { &mut m.setVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENG_PFSignKind>(
                "ENG_PFSignKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENG_PFSignKind {
        static instance: ::protobuf::rt::LazyV2<ENG_PFSignKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENG_PFSignKind::new)
    }
}

impl ::protobuf::Clear for ENG_PFSignKind {
    fn clear(&mut self) {
        self.setVal = PFSignKind::PFSignKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENG_PFSignKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENG_PFSignKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_BehaviourModeKind {
    // message fields
    pub value: BehaviourModeKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_BehaviourModeKind {
    fn default() -> &'a Optional_BehaviourModeKind {
        <Optional_BehaviourModeKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_BehaviourModeKind {
    pub fn new() -> Optional_BehaviourModeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.BehaviourModeKind value = 1;


    pub fn get_value(&self) -> BehaviourModeKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = BehaviourModeKind::BehaviourModeKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BehaviourModeKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_BehaviourModeKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != BehaviourModeKind::BehaviourModeKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != BehaviourModeKind::BehaviourModeKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_BehaviourModeKind {
        Optional_BehaviourModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BehaviourModeKind>>(
                "value",
                |m: &Optional_BehaviourModeKind| { &m.value },
                |m: &mut Optional_BehaviourModeKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_BehaviourModeKind>(
                "Optional_BehaviourModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_BehaviourModeKind {
        static instance: ::protobuf::rt::LazyV2<Optional_BehaviourModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_BehaviourModeKind::new)
    }
}

impl ::protobuf::Clear for Optional_BehaviourModeKind {
    fn clear(&mut self) {
        self.value = BehaviourModeKind::BehaviourModeKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_BehaviourModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_BehaviourModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENS_BehaviourModeKind {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: BehaviourModeKind,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENS_BehaviourModeKind {
    fn default() -> &'a ENS_BehaviourModeKind {
        <ENS_BehaviourModeKind as ::protobuf::Message>::default_instance()
    }
}

impl ENS_BehaviourModeKind {
    pub fn new() -> ENS_BehaviourModeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.BehaviourModeKind stVal = 2;


    pub fn get_stVal(&self) -> BehaviourModeKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = BehaviourModeKind::BehaviourModeKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: BehaviourModeKind) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for ENS_BehaviourModeKind {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != BehaviourModeKind::BehaviourModeKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(2, self.stVal);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != BehaviourModeKind::BehaviourModeKind_UNDEFINED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENS_BehaviourModeKind {
        ENS_BehaviourModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &ENS_BehaviourModeKind| { &m.q },
                |m: &mut ENS_BehaviourModeKind| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BehaviourModeKind>>(
                "stVal",
                |m: &ENS_BehaviourModeKind| { &m.stVal },
                |m: &mut ENS_BehaviourModeKind| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &ENS_BehaviourModeKind| { &m.t },
                |m: &mut ENS_BehaviourModeKind| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENS_BehaviourModeKind>(
                "ENS_BehaviourModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENS_BehaviourModeKind {
        static instance: ::protobuf::rt::LazyV2<ENS_BehaviourModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENS_BehaviourModeKind::new)
    }
}

impl ::protobuf::Clear for ENS_BehaviourModeKind {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = BehaviourModeKind::BehaviourModeKind_UNDEFINED;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENS_BehaviourModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENS_BehaviourModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_DERGeneratorStateKind {
    // message fields
    pub value: DERGeneratorStateKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_DERGeneratorStateKind {
    fn default() -> &'a Optional_DERGeneratorStateKind {
        <Optional_DERGeneratorStateKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_DERGeneratorStateKind {
    pub fn new() -> Optional_DERGeneratorStateKind {
        ::std::default::Default::default()
    }

    // .commonmodule.DERGeneratorStateKind value = 1;


    pub fn get_value(&self) -> DERGeneratorStateKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DERGeneratorStateKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_DERGeneratorStateKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_DERGeneratorStateKind {
        Optional_DERGeneratorStateKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DERGeneratorStateKind>>(
                "value",
                |m: &Optional_DERGeneratorStateKind| { &m.value },
                |m: &mut Optional_DERGeneratorStateKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_DERGeneratorStateKind>(
                "Optional_DERGeneratorStateKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_DERGeneratorStateKind {
        static instance: ::protobuf::rt::LazyV2<Optional_DERGeneratorStateKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_DERGeneratorStateKind::new)
    }
}

impl ::protobuf::Clear for Optional_DERGeneratorStateKind {
    fn clear(&mut self) {
        self.value = DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_DERGeneratorStateKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_DERGeneratorStateKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENS_DERGeneratorStateKind {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: DERGeneratorStateKind,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENS_DERGeneratorStateKind {
    fn default() -> &'a ENS_DERGeneratorStateKind {
        <ENS_DERGeneratorStateKind as ::protobuf::Message>::default_instance()
    }
}

impl ENS_DERGeneratorStateKind {
    pub fn new() -> ENS_DERGeneratorStateKind {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.DERGeneratorStateKind stVal = 2;


    pub fn get_stVal(&self) -> DERGeneratorStateKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: DERGeneratorStateKind) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for ENS_DERGeneratorStateKind {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(2, self.stVal);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENS_DERGeneratorStateKind {
        ENS_DERGeneratorStateKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &ENS_DERGeneratorStateKind| { &m.q },
                |m: &mut ENS_DERGeneratorStateKind| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DERGeneratorStateKind>>(
                "stVal",
                |m: &ENS_DERGeneratorStateKind| { &m.stVal },
                |m: &mut ENS_DERGeneratorStateKind| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &ENS_DERGeneratorStateKind| { &m.t },
                |m: &mut ENS_DERGeneratorStateKind| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENS_DERGeneratorStateKind>(
                "ENS_DERGeneratorStateKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENS_DERGeneratorStateKind {
        static instance: ::protobuf::rt::LazyV2<ENS_DERGeneratorStateKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENS_DERGeneratorStateKind::new)
    }
}

impl ::protobuf::Clear for ENS_DERGeneratorStateKind {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENS_DERGeneratorStateKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENS_DERGeneratorStateKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_DynamicTestKind {
    // message fields
    pub value: DynamicTestKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_DynamicTestKind {
    fn default() -> &'a Optional_DynamicTestKind {
        <Optional_DynamicTestKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_DynamicTestKind {
    pub fn new() -> Optional_DynamicTestKind {
        ::std::default::Default::default()
    }

    // .commonmodule.DynamicTestKind value = 1;


    pub fn get_value(&self) -> DynamicTestKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = DynamicTestKind::DynamicTestKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DynamicTestKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_DynamicTestKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DynamicTestKind::DynamicTestKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != DynamicTestKind::DynamicTestKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_DynamicTestKind {
        Optional_DynamicTestKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DynamicTestKind>>(
                "value",
                |m: &Optional_DynamicTestKind| { &m.value },
                |m: &mut Optional_DynamicTestKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_DynamicTestKind>(
                "Optional_DynamicTestKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_DynamicTestKind {
        static instance: ::protobuf::rt::LazyV2<Optional_DynamicTestKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_DynamicTestKind::new)
    }
}

impl ::protobuf::Clear for Optional_DynamicTestKind {
    fn clear(&mut self) {
        self.value = DynamicTestKind::DynamicTestKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_DynamicTestKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_DynamicTestKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENS_DynamicTestKind {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: DynamicTestKind,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENS_DynamicTestKind {
    fn default() -> &'a ENS_DynamicTestKind {
        <ENS_DynamicTestKind as ::protobuf::Message>::default_instance()
    }
}

impl ENS_DynamicTestKind {
    pub fn new() -> ENS_DynamicTestKind {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.DynamicTestKind stVal = 2;


    pub fn get_stVal(&self) -> DynamicTestKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = DynamicTestKind::DynamicTestKind_none;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: DynamicTestKind) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for ENS_DynamicTestKind {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != DynamicTestKind::DynamicTestKind_none {
            my_size += ::protobuf::rt::enum_size(2, self.stVal);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != DynamicTestKind::DynamicTestKind_none {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENS_DynamicTestKind {
        ENS_DynamicTestKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &ENS_DynamicTestKind| { &m.q },
                |m: &mut ENS_DynamicTestKind| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DynamicTestKind>>(
                "stVal",
                |m: &ENS_DynamicTestKind| { &m.stVal },
                |m: &mut ENS_DynamicTestKind| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &ENS_DynamicTestKind| { &m.t },
                |m: &mut ENS_DynamicTestKind| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENS_DynamicTestKind>(
                "ENS_DynamicTestKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENS_DynamicTestKind {
        static instance: ::protobuf::rt::LazyV2<ENS_DynamicTestKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENS_DynamicTestKind::new)
    }
}

impl ::protobuf::Clear for ENS_DynamicTestKind {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = DynamicTestKind::DynamicTestKind_none;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENS_DynamicTestKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENS_DynamicTestKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENS_GridConnectModeKind {
    // message fields
    pub stVal: GridConnectModeKind,
    pub stValExtension: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENS_GridConnectModeKind {
    fn default() -> &'a ENS_GridConnectModeKind {
        <ENS_GridConnectModeKind as ::protobuf::Message>::default_instance()
    }
}

impl ENS_GridConnectModeKind {
    pub fn new() -> ENS_GridConnectModeKind {
        ::std::default::Default::default()
    }

    // .commonmodule.GridConnectModeKind stVal = 1;


    pub fn get_stVal(&self) -> GridConnectModeKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: GridConnectModeKind) {
        self.stVal = v;
    }

    // string stValExtension = 2;


    pub fn get_stValExtension(&self) -> &str {
        &self.stValExtension
    }
    pub fn clear_stValExtension(&mut self) {
        self.stValExtension.clear();
    }

    // Param is passed by value, moved
    pub fn set_stValExtension(&mut self, v: ::std::string::String) {
        self.stValExtension = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stValExtension(&mut self) -> &mut ::std::string::String {
        &mut self.stValExtension
    }

    // Take field
    pub fn take_stValExtension(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stValExtension, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ENS_GridConnectModeKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stValExtension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.stVal != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            my_size += ::protobuf::rt::enum_size(1, self.stVal);
        }
        if !self.stValExtension.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stValExtension);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.stVal != GridConnectModeKind::GridConnectModeKind_UNDEFINED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        if !self.stValExtension.is_empty() {
            os.write_string(2, &self.stValExtension)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENS_GridConnectModeKind {
        ENS_GridConnectModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GridConnectModeKind>>(
                "stVal",
                |m: &ENS_GridConnectModeKind| { &m.stVal },
                |m: &mut ENS_GridConnectModeKind| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stValExtension",
                |m: &ENS_GridConnectModeKind| { &m.stValExtension },
                |m: &mut ENS_GridConnectModeKind| { &mut m.stValExtension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENS_GridConnectModeKind>(
                "ENS_GridConnectModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENS_GridConnectModeKind {
        static instance: ::protobuf::rt::LazyV2<ENS_GridConnectModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENS_GridConnectModeKind::new)
    }
}

impl ::protobuf::Clear for ENS_GridConnectModeKind {
    fn clear(&mut self) {
        self.stVal = GridConnectModeKind::GridConnectModeKind_UNDEFINED;
        self.stValExtension.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENS_GridConnectModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENS_GridConnectModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_HealthKind {
    // message fields
    pub value: HealthKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_HealthKind {
    fn default() -> &'a Optional_HealthKind {
        <Optional_HealthKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_HealthKind {
    pub fn new() -> Optional_HealthKind {
        ::std::default::Default::default()
    }

    // .commonmodule.HealthKind value = 1;


    pub fn get_value(&self) -> HealthKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = HealthKind::HealthKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: HealthKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_HealthKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != HealthKind::HealthKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != HealthKind::HealthKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_HealthKind {
        Optional_HealthKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthKind>>(
                "value",
                |m: &Optional_HealthKind| { &m.value },
                |m: &mut Optional_HealthKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_HealthKind>(
                "Optional_HealthKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_HealthKind {
        static instance: ::protobuf::rt::LazyV2<Optional_HealthKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_HealthKind::new)
    }
}

impl ::protobuf::Clear for Optional_HealthKind {
    fn clear(&mut self) {
        self.value = HealthKind::HealthKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_HealthKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_HealthKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENS_HealthKind {
    // message fields
    d: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub stVal: HealthKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENS_HealthKind {
    fn default() -> &'a ENS_HealthKind {
        <ENS_HealthKind as ::protobuf::Message>::default_instance()
    }
}

impl ENS_HealthKind {
    pub fn new() -> ENS_HealthKind {
        ::std::default::Default::default()
    }

    // .google.protobuf.StringValue d = 1;


    pub fn get_d(&self) -> &::protobuf::well_known_types::StringValue {
        self.d.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.d.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    // .commonmodule.HealthKind stVal = 2;


    pub fn get_stVal(&self) -> HealthKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = HealthKind::HealthKind_none;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: HealthKind) {
        self.stVal = v;
    }
}

impl ::protobuf::Message for ENS_HealthKind {
    fn is_initialized(&self) -> bool {
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != HealthKind::HealthKind_none {
            my_size += ::protobuf::rt::enum_size(2, self.stVal);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != HealthKind::HealthKind_none {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENS_HealthKind {
        ENS_HealthKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "d",
                |m: &ENS_HealthKind| { &m.d },
                |m: &mut ENS_HealthKind| { &mut m.d },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthKind>>(
                "stVal",
                |m: &ENS_HealthKind| { &m.stVal },
                |m: &mut ENS_HealthKind| { &mut m.stVal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENS_HealthKind>(
                "ENS_HealthKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENS_HealthKind {
        static instance: ::protobuf::rt::LazyV2<ENS_HealthKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENS_HealthKind::new)
    }
}

impl ::protobuf::Clear for ENS_HealthKind {
    fn clear(&mut self) {
        self.d.clear();
        self.stVal = HealthKind::HealthKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENS_HealthKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENS_HealthKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESS {
    // message fields
    conductingEquipment: ::protobuf::SingularPtrField<ConductingEquipment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESS {
    fn default() -> &'a ESS {
        <ESS as ::protobuf::Message>::default_instance()
    }
}

impl ESS {
    pub fn new() -> ESS {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipment conductingEquipment = 1;


    pub fn get_conductingEquipment(&self) -> &ConductingEquipment {
        self.conductingEquipment.as_ref().unwrap_or_else(|| <ConductingEquipment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipment(&mut self) {
        self.conductingEquipment.clear();
    }

    pub fn has_conductingEquipment(&self) -> bool {
        self.conductingEquipment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipment(&mut self, v: ConductingEquipment) {
        self.conductingEquipment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipment(&mut self) -> &mut ConductingEquipment {
        if self.conductingEquipment.is_none() {
            self.conductingEquipment.set_default();
        }
        self.conductingEquipment.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipment(&mut self) -> ConductingEquipment {
        self.conductingEquipment.take().unwrap_or_else(|| ConductingEquipment::new())
    }
}

impl ::protobuf::Message for ESS {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESS {
        ESS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConductingEquipment>>(
                "conductingEquipment",
                |m: &ESS| { &m.conductingEquipment },
                |m: &mut ESS| { &mut m.conductingEquipment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESS>(
                "ESS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESS {
        static instance: ::protobuf::rt::LazyV2<ESS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESS::new)
    }
}

impl ::protobuf::Clear for ESS {
    fn clear(&mut self) {
        self.conductingEquipment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EventMessageInfo {
    // message fields
    messageInfo: ::protobuf::SingularPtrField<MessageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventMessageInfo {
    fn default() -> &'a EventMessageInfo {
        <EventMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl EventMessageInfo {
    pub fn new() -> EventMessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.MessageInfo messageInfo = 1;


    pub fn get_messageInfo(&self) -> &MessageInfo {
        self.messageInfo.as_ref().unwrap_or_else(|| <MessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageInfo(&mut self) {
        self.messageInfo.clear();
    }

    pub fn has_messageInfo(&self) -> bool {
        self.messageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageInfo(&mut self, v: MessageInfo) {
        self.messageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageInfo(&mut self) -> &mut MessageInfo {
        if self.messageInfo.is_none() {
            self.messageInfo.set_default();
        }
        self.messageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageInfo(&mut self) -> MessageInfo {
        self.messageInfo.take().unwrap_or_else(|| MessageInfo::new())
    }
}

impl ::protobuf::Message for EventMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.messageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventMessageInfo {
        EventMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageInfo>>(
                "messageInfo",
                |m: &EventMessageInfo| { &m.messageInfo },
                |m: &mut EventMessageInfo| { &mut m.messageInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventMessageInfo>(
                "EventMessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventMessageInfo {
        static instance: ::protobuf::rt::LazyV2<EventMessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventMessageInfo::new)
    }
}

impl ::protobuf::Clear for EventMessageInfo {
    fn clear(&mut self) {
        self.messageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EventValue {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventValue {
    fn default() -> &'a EventValue {
        <EventValue as ::protobuf::Message>::default_instance()
    }
}

impl EventValue {
    pub fn new() -> EventValue {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for EventValue {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventValue {
        EventValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &EventValue| { &m.identifiedObject },
                |m: &mut EventValue| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventValue>(
                "EventValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventValue {
        static instance: ::protobuf::rt::LazyV2<EventValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventValue::new)
    }
}

impl ::protobuf::Clear for EventValue {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ForecastValueSource {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForecastValueSource {
    fn default() -> &'a ForecastValueSource {
        <ForecastValueSource as ::protobuf::Message>::default_instance()
    }
}

impl ForecastValueSource {
    pub fn new() -> ForecastValueSource {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for ForecastValueSource {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForecastValueSource {
        ForecastValueSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &ForecastValueSource| { &m.identifiedObject },
                |m: &mut ForecastValueSource| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForecastValueSource>(
                "ForecastValueSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForecastValueSource {
        static instance: ::protobuf::rt::LazyV2<ForecastValueSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForecastValueSource::new)
    }
}

impl ::protobuf::Clear for ForecastValueSource {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForecastValueSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForecastValueSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ForecastIED {
    // message fields
    forecastValueSource: ::protobuf::SingularPtrField<ForecastValueSource>,
    pub sourceApplicationID: ::std::string::String,
    pub sourceDateTime: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForecastIED {
    fn default() -> &'a ForecastIED {
        <ForecastIED as ::protobuf::Message>::default_instance()
    }
}

impl ForecastIED {
    pub fn new() -> ForecastIED {
        ::std::default::Default::default()
    }

    // .commonmodule.ForecastValueSource forecastValueSource = 1;


    pub fn get_forecastValueSource(&self) -> &ForecastValueSource {
        self.forecastValueSource.as_ref().unwrap_or_else(|| <ForecastValueSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_forecastValueSource(&mut self) {
        self.forecastValueSource.clear();
    }

    pub fn has_forecastValueSource(&self) -> bool {
        self.forecastValueSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forecastValueSource(&mut self, v: ForecastValueSource) {
        self.forecastValueSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forecastValueSource(&mut self) -> &mut ForecastValueSource {
        if self.forecastValueSource.is_none() {
            self.forecastValueSource.set_default();
        }
        self.forecastValueSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_forecastValueSource(&mut self) -> ForecastValueSource {
        self.forecastValueSource.take().unwrap_or_else(|| ForecastValueSource::new())
    }

    // string sourceApplicationID = 2;


    pub fn get_sourceApplicationID(&self) -> &str {
        &self.sourceApplicationID
    }
    pub fn clear_sourceApplicationID(&mut self) {
        self.sourceApplicationID.clear();
    }

    // Param is passed by value, moved
    pub fn set_sourceApplicationID(&mut self, v: ::std::string::String) {
        self.sourceApplicationID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceApplicationID(&mut self) -> &mut ::std::string::String {
        &mut self.sourceApplicationID
    }

    // Take field
    pub fn take_sourceApplicationID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sourceApplicationID, ::std::string::String::new())
    }

    // int64 sourceDateTime = 3;


    pub fn get_sourceDateTime(&self) -> i64 {
        self.sourceDateTime
    }
    pub fn clear_sourceDateTime(&mut self) {
        self.sourceDateTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_sourceDateTime(&mut self, v: i64) {
        self.sourceDateTime = v;
    }
}

impl ::protobuf::Message for ForecastIED {
    fn is_initialized(&self) -> bool {
        for v in &self.forecastValueSource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forecastValueSource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sourceApplicationID)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sourceDateTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.forecastValueSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sourceApplicationID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sourceApplicationID);
        }
        if self.sourceDateTime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sourceDateTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.forecastValueSource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sourceApplicationID.is_empty() {
            os.write_string(2, &self.sourceApplicationID)?;
        }
        if self.sourceDateTime != 0 {
            os.write_int64(3, self.sourceDateTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForecastIED {
        ForecastIED::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForecastValueSource>>(
                "forecastValueSource",
                |m: &ForecastIED| { &m.forecastValueSource },
                |m: &mut ForecastIED| { &mut m.forecastValueSource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceApplicationID",
                |m: &ForecastIED| { &m.sourceApplicationID },
                |m: &mut ForecastIED| { &mut m.sourceApplicationID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sourceDateTime",
                |m: &ForecastIED| { &m.sourceDateTime },
                |m: &mut ForecastIED| { &mut m.sourceDateTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForecastIED>(
                "ForecastIED",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForecastIED {
        static instance: ::protobuf::rt::LazyV2<ForecastIED> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForecastIED::new)
    }
}

impl ::protobuf::Clear for ForecastIED {
    fn clear(&mut self) {
        self.forecastValueSource.clear();
        self.sourceApplicationID.clear();
        self.sourceDateTime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForecastIED {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForecastIED {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ForecastValue {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForecastValue {
    fn default() -> &'a ForecastValue {
        <ForecastValue as ::protobuf::Message>::default_instance()
    }
}

impl ForecastValue {
    pub fn new() -> ForecastValue {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for ForecastValue {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForecastValue {
        ForecastValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &ForecastValue| { &m.identifiedObject },
                |m: &mut ForecastValue| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ForecastValue>(
                "ForecastValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ForecastValue {
        static instance: ::protobuf::rt::LazyV2<ForecastValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ForecastValue::new)
    }
}

impl ::protobuf::Clear for ForecastValue {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForecastValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForecastValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IED {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IED {
    fn default() -> &'a IED {
        <IED as ::protobuf::Message>::default_instance()
    }
}

impl IED {
    pub fn new() -> IED {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for IED {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IED {
        IED::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &IED| { &m.identifiedObject },
                |m: &mut IED| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IED>(
                "IED",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IED {
        static instance: ::protobuf::rt::LazyV2<IED> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IED::new)
    }
}

impl ::protobuf::Clear for IED {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IED {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IED {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusINS {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: i32,
    t: ::protobuf::SingularPtrField<Timestamp>,
    units: ::protobuf::SingularPtrField<Unit>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusINS {
    fn default() -> &'a StatusINS {
        <StatusINS as ::protobuf::Message>::default_instance()
    }
}

impl StatusINS {
    pub fn new() -> StatusINS {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // int32 stVal = 2;


    pub fn get_stVal(&self) -> i32 {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = 0;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: i32) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }

    // .commonmodule.Unit units = 4;


    pub fn get_units(&self) -> &Unit {
        self.units.as_ref().unwrap_or_else(|| <Unit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: Unit) {
        self.units = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_units(&mut self) -> &mut Unit {
        if self.units.is_none() {
            self.units.set_default();
        }
        self.units.as_mut().unwrap()
    }

    // Take field
    pub fn take_units(&mut self) -> Unit {
        self.units.take().unwrap_or_else(|| Unit::new())
    }
}

impl ::protobuf::Message for StatusINS {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.units {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stVal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.units)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stVal, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.units.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != 0 {
            os.write_int32(2, self.stVal)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.units.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusINS {
        StatusINS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &StatusINS| { &m.q },
                |m: &mut StatusINS| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stVal",
                |m: &StatusINS| { &m.stVal },
                |m: &mut StatusINS| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &StatusINS| { &m.t },
                |m: &mut StatusINS| { &mut m.t },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unit>>(
                "units",
                |m: &StatusINS| { &m.units },
                |m: &mut StatusINS| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusINS>(
                "StatusINS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusINS {
        static instance: ::protobuf::rt::LazyV2<StatusINS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusINS::new)
    }
}

impl ::protobuf::Clear for StatusINS {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = 0;
        self.t.clear();
        self.units.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusINS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusINS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IntegerStatusGGIO {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    IntIn: ::protobuf::SingularPtrField<StatusINS>,
    Phase: ::protobuf::SingularPtrField<Optional_PhaseCodeKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntegerStatusGGIO {
    fn default() -> &'a IntegerStatusGGIO {
        <IntegerStatusGGIO as ::protobuf::Message>::default_instance()
    }
}

impl IntegerStatusGGIO {
    pub fn new() -> IntegerStatusGGIO {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.StatusINS IntIn = 2;


    pub fn get_IntIn(&self) -> &StatusINS {
        self.IntIn.as_ref().unwrap_or_else(|| <StatusINS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_IntIn(&mut self) {
        self.IntIn.clear();
    }

    pub fn has_IntIn(&self) -> bool {
        self.IntIn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IntIn(&mut self, v: StatusINS) {
        self.IntIn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IntIn(&mut self) -> &mut StatusINS {
        if self.IntIn.is_none() {
            self.IntIn.set_default();
        }
        self.IntIn.as_mut().unwrap()
    }

    // Take field
    pub fn take_IntIn(&mut self) -> StatusINS {
        self.IntIn.take().unwrap_or_else(|| StatusINS::new())
    }

    // .commonmodule.Optional_PhaseCodeKind Phase = 3;


    pub fn get_Phase(&self) -> &Optional_PhaseCodeKind {
        self.Phase.as_ref().unwrap_or_else(|| <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Phase(&mut self) {
        self.Phase.clear();
    }

    pub fn has_Phase(&self) -> bool {
        self.Phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Phase(&mut self, v: Optional_PhaseCodeKind) {
        self.Phase = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Phase(&mut self) -> &mut Optional_PhaseCodeKind {
        if self.Phase.is_none() {
            self.Phase.set_default();
        }
        self.Phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_Phase(&mut self) -> Optional_PhaseCodeKind {
        self.Phase.take().unwrap_or_else(|| Optional_PhaseCodeKind::new())
    }
}

impl ::protobuf::Message for IntegerStatusGGIO {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.IntIn {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Phase {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.IntIn)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Phase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.IntIn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.IntIn.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntegerStatusGGIO {
        IntegerStatusGGIO::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &IntegerStatusGGIO| { &m.logicalNode },
                |m: &mut IntegerStatusGGIO| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusINS>>(
                "IntIn",
                |m: &IntegerStatusGGIO| { &m.IntIn },
                |m: &mut IntegerStatusGGIO| { &mut m.IntIn },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_PhaseCodeKind>>(
                "Phase",
                |m: &IntegerStatusGGIO| { &m.Phase },
                |m: &mut IntegerStatusGGIO| { &mut m.Phase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntegerStatusGGIO>(
                "IntegerStatusGGIO",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IntegerStatusGGIO {
        static instance: ::protobuf::rt::LazyV2<IntegerStatusGGIO> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntegerStatusGGIO::new)
    }
}

impl ::protobuf::Clear for IntegerStatusGGIO {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.IntIn.clear();
        self.Phase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntegerStatusGGIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegerStatusGGIO {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LogicalNodeForEventAndStatus {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    Beh: ::protobuf::SingularPtrField<ENS_BehaviourModeKind>,
    EEHealth: ::protobuf::SingularPtrField<ENS_HealthKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogicalNodeForEventAndStatus {
    fn default() -> &'a LogicalNodeForEventAndStatus {
        <LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance()
    }
}

impl LogicalNodeForEventAndStatus {
    pub fn new() -> LogicalNodeForEventAndStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.ENS_BehaviourModeKind Beh = 2;


    pub fn get_Beh(&self) -> &ENS_BehaviourModeKind {
        self.Beh.as_ref().unwrap_or_else(|| <ENS_BehaviourModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Beh(&mut self) {
        self.Beh.clear();
    }

    pub fn has_Beh(&self) -> bool {
        self.Beh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Beh(&mut self, v: ENS_BehaviourModeKind) {
        self.Beh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Beh(&mut self) -> &mut ENS_BehaviourModeKind {
        if self.Beh.is_none() {
            self.Beh.set_default();
        }
        self.Beh.as_mut().unwrap()
    }

    // Take field
    pub fn take_Beh(&mut self) -> ENS_BehaviourModeKind {
        self.Beh.take().unwrap_or_else(|| ENS_BehaviourModeKind::new())
    }

    // .commonmodule.ENS_HealthKind EEHealth = 3;


    pub fn get_EEHealth(&self) -> &ENS_HealthKind {
        self.EEHealth.as_ref().unwrap_or_else(|| <ENS_HealthKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_EEHealth(&mut self) {
        self.EEHealth.clear();
    }

    pub fn has_EEHealth(&self) -> bool {
        self.EEHealth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EEHealth(&mut self, v: ENS_HealthKind) {
        self.EEHealth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EEHealth(&mut self) -> &mut ENS_HealthKind {
        if self.EEHealth.is_none() {
            self.EEHealth.set_default();
        }
        self.EEHealth.as_mut().unwrap()
    }

    // Take field
    pub fn take_EEHealth(&mut self) -> ENS_HealthKind {
        self.EEHealth.take().unwrap_or_else(|| ENS_HealthKind::new())
    }
}

impl ::protobuf::Message for LogicalNodeForEventAndStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Beh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EEHealth {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Beh)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EEHealth)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Beh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EEHealth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Beh.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EEHealth.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalNodeForEventAndStatus {
        LogicalNodeForEventAndStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &LogicalNodeForEventAndStatus| { &m.logicalNode },
                |m: &mut LogicalNodeForEventAndStatus| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENS_BehaviourModeKind>>(
                "Beh",
                |m: &LogicalNodeForEventAndStatus| { &m.Beh },
                |m: &mut LogicalNodeForEventAndStatus| { &mut m.Beh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENS_HealthKind>>(
                "EEHealth",
                |m: &LogicalNodeForEventAndStatus| { &m.EEHealth },
                |m: &mut LogicalNodeForEventAndStatus| { &mut m.EEHealth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogicalNodeForEventAndStatus>(
                "LogicalNodeForEventAndStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogicalNodeForEventAndStatus {
        static instance: ::protobuf::rt::LazyV2<LogicalNodeForEventAndStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogicalNodeForEventAndStatus::new)
    }
}

impl ::protobuf::Clear for LogicalNodeForEventAndStatus {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.Beh.clear();
        self.EEHealth.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalNodeForEventAndStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalNodeForEventAndStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MeasurementValue {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MeasurementValue {
    fn default() -> &'a MeasurementValue {
        <MeasurementValue as ::protobuf::Message>::default_instance()
    }
}

impl MeasurementValue {
    pub fn new() -> MeasurementValue {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for MeasurementValue {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasurementValue {
        MeasurementValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &MeasurementValue| { &m.identifiedObject },
                |m: &mut MeasurementValue| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MeasurementValue>(
                "MeasurementValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MeasurementValue {
        static instance: ::protobuf::rt::LazyV2<MeasurementValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MeasurementValue::new)
    }
}

impl ::protobuf::Clear for MeasurementValue {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasurementValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasurementValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Meter {
    // message fields
    conductingEquipment: ::protobuf::SingularPtrField<ConductingEquipment>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Meter {
    fn default() -> &'a Meter {
        <Meter as ::protobuf::Message>::default_instance()
    }
}

impl Meter {
    pub fn new() -> Meter {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipment conductingEquipment = 1;


    pub fn get_conductingEquipment(&self) -> &ConductingEquipment {
        self.conductingEquipment.as_ref().unwrap_or_else(|| <ConductingEquipment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipment(&mut self) {
        self.conductingEquipment.clear();
    }

    pub fn has_conductingEquipment(&self) -> bool {
        self.conductingEquipment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipment(&mut self, v: ConductingEquipment) {
        self.conductingEquipment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipment(&mut self) -> &mut ConductingEquipment {
        if self.conductingEquipment.is_none() {
            self.conductingEquipment.set_default();
        }
        self.conductingEquipment.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipment(&mut self) -> ConductingEquipment {
        self.conductingEquipment.take().unwrap_or_else(|| ConductingEquipment::new())
    }
}

impl ::protobuf::Message for Meter {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Meter {
        Meter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConductingEquipment>>(
                "conductingEquipment",
                |m: &Meter| { &m.conductingEquipment },
                |m: &mut Meter| { &mut m.conductingEquipment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Meter>(
                "Meter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Meter {
        static instance: ::protobuf::rt::LazyV2<Meter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Meter::new)
    }
}

impl ::protobuf::Clear for Meter {
    fn clear(&mut self) {
        self.conductingEquipment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Meter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct OptimizationMessageInfo {
    // message fields
    messageInfo: ::protobuf::SingularPtrField<MessageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptimizationMessageInfo {
    fn default() -> &'a OptimizationMessageInfo {
        <OptimizationMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl OptimizationMessageInfo {
    pub fn new() -> OptimizationMessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.MessageInfo messageInfo = 1;


    pub fn get_messageInfo(&self) -> &MessageInfo {
        self.messageInfo.as_ref().unwrap_or_else(|| <MessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageInfo(&mut self) {
        self.messageInfo.clear();
    }

    pub fn has_messageInfo(&self) -> bool {
        self.messageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageInfo(&mut self, v: MessageInfo) {
        self.messageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageInfo(&mut self) -> &mut MessageInfo {
        if self.messageInfo.is_none() {
            self.messageInfo.set_default();
        }
        self.messageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageInfo(&mut self) -> MessageInfo {
        self.messageInfo.take().unwrap_or_else(|| MessageInfo::new())
    }
}

impl ::protobuf::Message for OptimizationMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.messageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OptimizationMessageInfo {
        OptimizationMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageInfo>>(
                "messageInfo",
                |m: &OptimizationMessageInfo| { &m.messageInfo },
                |m: &mut OptimizationMessageInfo| { &mut m.messageInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OptimizationMessageInfo>(
                "OptimizationMessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OptimizationMessageInfo {
        static instance: ::protobuf::rt::LazyV2<OptimizationMessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OptimizationMessageInfo::new)
    }
}

impl ::protobuf::Clear for OptimizationMessageInfo {
    fn clear(&mut self) {
        self.messageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptimizationMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizationMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReadingMMTN {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    DmdVAh: ::protobuf::SingularPtrField<BCR>,
    DmdVArh: ::protobuf::SingularPtrField<BCR>,
    DmdWh: ::protobuf::SingularPtrField<BCR>,
    SupVAh: ::protobuf::SingularPtrField<BCR>,
    SupVArh: ::protobuf::SingularPtrField<BCR>,
    SupWh: ::protobuf::SingularPtrField<BCR>,
    TotVAh: ::protobuf::SingularPtrField<BCR>,
    TotVArh: ::protobuf::SingularPtrField<BCR>,
    TotWh: ::protobuf::SingularPtrField<BCR>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadingMMTN {
    fn default() -> &'a ReadingMMTN {
        <ReadingMMTN as ::protobuf::Message>::default_instance()
    }
}

impl ReadingMMTN {
    pub fn new() -> ReadingMMTN {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.BCR DmdVAh = 2;


    pub fn get_DmdVAh(&self) -> &BCR {
        self.DmdVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdVAh(&mut self) {
        self.DmdVAh.clear();
    }

    pub fn has_DmdVAh(&self) -> bool {
        self.DmdVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdVAh(&mut self, v: BCR) {
        self.DmdVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdVAh(&mut self) -> &mut BCR {
        if self.DmdVAh.is_none() {
            self.DmdVAh.set_default();
        }
        self.DmdVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdVAh(&mut self) -> BCR {
        self.DmdVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR DmdVArh = 3;


    pub fn get_DmdVArh(&self) -> &BCR {
        self.DmdVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdVArh(&mut self) {
        self.DmdVArh.clear();
    }

    pub fn has_DmdVArh(&self) -> bool {
        self.DmdVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdVArh(&mut self, v: BCR) {
        self.DmdVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdVArh(&mut self) -> &mut BCR {
        if self.DmdVArh.is_none() {
            self.DmdVArh.set_default();
        }
        self.DmdVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdVArh(&mut self) -> BCR {
        self.DmdVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR DmdWh = 4;


    pub fn get_DmdWh(&self) -> &BCR {
        self.DmdWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdWh(&mut self) {
        self.DmdWh.clear();
    }

    pub fn has_DmdWh(&self) -> bool {
        self.DmdWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdWh(&mut self, v: BCR) {
        self.DmdWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdWh(&mut self) -> &mut BCR {
        if self.DmdWh.is_none() {
            self.DmdWh.set_default();
        }
        self.DmdWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdWh(&mut self) -> BCR {
        self.DmdWh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupVAh = 5;


    pub fn get_SupVAh(&self) -> &BCR {
        self.SupVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupVAh(&mut self) {
        self.SupVAh.clear();
    }

    pub fn has_SupVAh(&self) -> bool {
        self.SupVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupVAh(&mut self, v: BCR) {
        self.SupVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupVAh(&mut self) -> &mut BCR {
        if self.SupVAh.is_none() {
            self.SupVAh.set_default();
        }
        self.SupVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupVAh(&mut self) -> BCR {
        self.SupVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupVArh = 6;


    pub fn get_SupVArh(&self) -> &BCR {
        self.SupVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupVArh(&mut self) {
        self.SupVArh.clear();
    }

    pub fn has_SupVArh(&self) -> bool {
        self.SupVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupVArh(&mut self, v: BCR) {
        self.SupVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupVArh(&mut self) -> &mut BCR {
        if self.SupVArh.is_none() {
            self.SupVArh.set_default();
        }
        self.SupVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupVArh(&mut self) -> BCR {
        self.SupVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupWh = 7;


    pub fn get_SupWh(&self) -> &BCR {
        self.SupWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupWh(&mut self) {
        self.SupWh.clear();
    }

    pub fn has_SupWh(&self) -> bool {
        self.SupWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupWh(&mut self, v: BCR) {
        self.SupWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupWh(&mut self) -> &mut BCR {
        if self.SupWh.is_none() {
            self.SupWh.set_default();
        }
        self.SupWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupWh(&mut self) -> BCR {
        self.SupWh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotVAh = 8;


    pub fn get_TotVAh(&self) -> &BCR {
        self.TotVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotVAh(&mut self) {
        self.TotVAh.clear();
    }

    pub fn has_TotVAh(&self) -> bool {
        self.TotVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotVAh(&mut self, v: BCR) {
        self.TotVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotVAh(&mut self) -> &mut BCR {
        if self.TotVAh.is_none() {
            self.TotVAh.set_default();
        }
        self.TotVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotVAh(&mut self) -> BCR {
        self.TotVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotVArh = 9;


    pub fn get_TotVArh(&self) -> &BCR {
        self.TotVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotVArh(&mut self) {
        self.TotVArh.clear();
    }

    pub fn has_TotVArh(&self) -> bool {
        self.TotVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotVArh(&mut self, v: BCR) {
        self.TotVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotVArh(&mut self) -> &mut BCR {
        if self.TotVArh.is_none() {
            self.TotVArh.set_default();
        }
        self.TotVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotVArh(&mut self) -> BCR {
        self.TotVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotWh = 10;


    pub fn get_TotWh(&self) -> &BCR {
        self.TotWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotWh(&mut self) {
        self.TotWh.clear();
    }

    pub fn has_TotWh(&self) -> bool {
        self.TotWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotWh(&mut self, v: BCR) {
        self.TotWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotWh(&mut self) -> &mut BCR {
        if self.TotWh.is_none() {
            self.TotWh.set_default();
        }
        self.TotWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotWh(&mut self) -> BCR {
        self.TotWh.take().unwrap_or_else(|| BCR::new())
    }
}

impl ::protobuf::Message for ReadingMMTN {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdWh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupWh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotWh {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdVAh)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdVArh)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdWh)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupVAh)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupVArh)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupWh)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotVAh)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotVArh)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotWh)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdVAh.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdVArh.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdWh.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupVAh.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupVArh.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupWh.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotVAh.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotVArh.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotWh.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadingMMTN {
        ReadingMMTN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &ReadingMMTN| { &m.logicalNode },
                |m: &mut ReadingMMTN| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdVAh",
                |m: &ReadingMMTN| { &m.DmdVAh },
                |m: &mut ReadingMMTN| { &mut m.DmdVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdVArh",
                |m: &ReadingMMTN| { &m.DmdVArh },
                |m: &mut ReadingMMTN| { &mut m.DmdVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdWh",
                |m: &ReadingMMTN| { &m.DmdWh },
                |m: &mut ReadingMMTN| { &mut m.DmdWh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupVAh",
                |m: &ReadingMMTN| { &m.SupVAh },
                |m: &mut ReadingMMTN| { &mut m.SupVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupVArh",
                |m: &ReadingMMTN| { &m.SupVArh },
                |m: &mut ReadingMMTN| { &mut m.SupVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupWh",
                |m: &ReadingMMTN| { &m.SupWh },
                |m: &mut ReadingMMTN| { &mut m.SupWh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotVAh",
                |m: &ReadingMMTN| { &m.TotVAh },
                |m: &mut ReadingMMTN| { &mut m.TotVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotVArh",
                |m: &ReadingMMTN| { &m.TotVArh },
                |m: &mut ReadingMMTN| { &mut m.TotVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotWh",
                |m: &ReadingMMTN| { &m.TotWh },
                |m: &mut ReadingMMTN| { &mut m.TotWh },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadingMMTN>(
                "ReadingMMTN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadingMMTN {
        static instance: ::protobuf::rt::LazyV2<ReadingMMTN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadingMMTN::new)
    }
}

impl ::protobuf::Clear for ReadingMMTN {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.DmdVAh.clear();
        self.DmdVArh.clear();
        self.DmdWh.clear();
        self.SupVAh.clear();
        self.SupVArh.clear();
        self.SupWh.clear();
        self.TotVAh.clear();
        self.TotVArh.clear();
        self.TotWh.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadingMMTN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadingMMTN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PhaseMMTN {
    // message fields
    phsA: ::protobuf::SingularPtrField<ReadingMMTN>,
    phsAB: ::protobuf::SingularPtrField<ReadingMMTN>,
    phsB: ::protobuf::SingularPtrField<ReadingMMTN>,
    phsBC: ::protobuf::SingularPtrField<ReadingMMTN>,
    phsC: ::protobuf::SingularPtrField<ReadingMMTN>,
    phsCA: ::protobuf::SingularPtrField<ReadingMMTN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhaseMMTN {
    fn default() -> &'a PhaseMMTN {
        <PhaseMMTN as ::protobuf::Message>::default_instance()
    }
}

impl PhaseMMTN {
    pub fn new() -> PhaseMMTN {
        ::std::default::Default::default()
    }

    // .commonmodule.ReadingMMTN phsA = 1;


    pub fn get_phsA(&self) -> &ReadingMMTN {
        self.phsA.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsA(&mut self) {
        self.phsA.clear();
    }

    pub fn has_phsA(&self) -> bool {
        self.phsA.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsA(&mut self, v: ReadingMMTN) {
        self.phsA = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsA(&mut self) -> &mut ReadingMMTN {
        if self.phsA.is_none() {
            self.phsA.set_default();
        }
        self.phsA.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsA(&mut self) -> ReadingMMTN {
        self.phsA.take().unwrap_or_else(|| ReadingMMTN::new())
    }

    // .commonmodule.ReadingMMTN phsAB = 2;


    pub fn get_phsAB(&self) -> &ReadingMMTN {
        self.phsAB.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsAB(&mut self) {
        self.phsAB.clear();
    }

    pub fn has_phsAB(&self) -> bool {
        self.phsAB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsAB(&mut self, v: ReadingMMTN) {
        self.phsAB = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsAB(&mut self) -> &mut ReadingMMTN {
        if self.phsAB.is_none() {
            self.phsAB.set_default();
        }
        self.phsAB.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsAB(&mut self) -> ReadingMMTN {
        self.phsAB.take().unwrap_or_else(|| ReadingMMTN::new())
    }

    // .commonmodule.ReadingMMTN phsB = 3;


    pub fn get_phsB(&self) -> &ReadingMMTN {
        self.phsB.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsB(&mut self) {
        self.phsB.clear();
    }

    pub fn has_phsB(&self) -> bool {
        self.phsB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsB(&mut self, v: ReadingMMTN) {
        self.phsB = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsB(&mut self) -> &mut ReadingMMTN {
        if self.phsB.is_none() {
            self.phsB.set_default();
        }
        self.phsB.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsB(&mut self) -> ReadingMMTN {
        self.phsB.take().unwrap_or_else(|| ReadingMMTN::new())
    }

    // .commonmodule.ReadingMMTN phsBC = 4;


    pub fn get_phsBC(&self) -> &ReadingMMTN {
        self.phsBC.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsBC(&mut self) {
        self.phsBC.clear();
    }

    pub fn has_phsBC(&self) -> bool {
        self.phsBC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsBC(&mut self, v: ReadingMMTN) {
        self.phsBC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsBC(&mut self) -> &mut ReadingMMTN {
        if self.phsBC.is_none() {
            self.phsBC.set_default();
        }
        self.phsBC.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsBC(&mut self) -> ReadingMMTN {
        self.phsBC.take().unwrap_or_else(|| ReadingMMTN::new())
    }

    // .commonmodule.ReadingMMTN phsC = 5;


    pub fn get_phsC(&self) -> &ReadingMMTN {
        self.phsC.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsC(&mut self) {
        self.phsC.clear();
    }

    pub fn has_phsC(&self) -> bool {
        self.phsC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsC(&mut self, v: ReadingMMTN) {
        self.phsC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsC(&mut self) -> &mut ReadingMMTN {
        if self.phsC.is_none() {
            self.phsC.set_default();
        }
        self.phsC.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsC(&mut self) -> ReadingMMTN {
        self.phsC.take().unwrap_or_else(|| ReadingMMTN::new())
    }

    // .commonmodule.ReadingMMTN phsCA = 6;


    pub fn get_phsCA(&self) -> &ReadingMMTN {
        self.phsCA.as_ref().unwrap_or_else(|| <ReadingMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsCA(&mut self) {
        self.phsCA.clear();
    }

    pub fn has_phsCA(&self) -> bool {
        self.phsCA.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsCA(&mut self, v: ReadingMMTN) {
        self.phsCA = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsCA(&mut self) -> &mut ReadingMMTN {
        if self.phsCA.is_none() {
            self.phsCA.set_default();
        }
        self.phsCA.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsCA(&mut self) -> ReadingMMTN {
        self.phsCA.take().unwrap_or_else(|| ReadingMMTN::new())
    }
}

impl ::protobuf::Message for PhaseMMTN {
    fn is_initialized(&self) -> bool {
        for v in &self.phsA {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsAB {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsB {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsBC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsCA {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsA)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsAB)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsB)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsBC)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsC)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsCA)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phsA.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsAB.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsB.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsBC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsCA.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phsA.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsAB.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsB.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsBC.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsC.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsCA.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhaseMMTN {
        PhaseMMTN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsA",
                |m: &PhaseMMTN| { &m.phsA },
                |m: &mut PhaseMMTN| { &mut m.phsA },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsAB",
                |m: &PhaseMMTN| { &m.phsAB },
                |m: &mut PhaseMMTN| { &mut m.phsAB },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsB",
                |m: &PhaseMMTN| { &m.phsB },
                |m: &mut PhaseMMTN| { &mut m.phsB },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsBC",
                |m: &PhaseMMTN| { &m.phsBC },
                |m: &mut PhaseMMTN| { &mut m.phsBC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsC",
                |m: &PhaseMMTN| { &m.phsC },
                |m: &mut PhaseMMTN| { &mut m.phsC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadingMMTN>>(
                "phsCA",
                |m: &PhaseMMTN| { &m.phsCA },
                |m: &mut PhaseMMTN| { &mut m.phsCA },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhaseMMTN>(
                "PhaseMMTN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhaseMMTN {
        static instance: ::protobuf::rt::LazyV2<PhaseMMTN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhaseMMTN::new)
    }
}

impl ::protobuf::Clear for PhaseMMTN {
    fn clear(&mut self) {
        self.phsA.clear();
        self.phsAB.clear();
        self.phsB.clear();
        self.phsBC.clear();
        self.phsC.clear();
        self.phsCA.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhaseMMTN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhaseMMTN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RampRate {
    // message fields
    negativeReactivePowerKVArPerMin: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    negativeRealPowerKWPerMin: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    positiveReactivePowerKVArPerMin: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    positiveRealPowerKWPerMin: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RampRate {
    fn default() -> &'a RampRate {
        <RampRate as ::protobuf::Message>::default_instance()
    }
}

impl RampRate {
    pub fn new() -> RampRate {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue negativeReactivePowerKVArPerMin = 1;


    pub fn get_negativeReactivePowerKVArPerMin(&self) -> &::protobuf::well_known_types::FloatValue {
        self.negativeReactivePowerKVArPerMin.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_negativeReactivePowerKVArPerMin(&mut self) {
        self.negativeReactivePowerKVArPerMin.clear();
    }

    pub fn has_negativeReactivePowerKVArPerMin(&self) -> bool {
        self.negativeReactivePowerKVArPerMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negativeReactivePowerKVArPerMin(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.negativeReactivePowerKVArPerMin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_negativeReactivePowerKVArPerMin(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.negativeReactivePowerKVArPerMin.is_none() {
            self.negativeReactivePowerKVArPerMin.set_default();
        }
        self.negativeReactivePowerKVArPerMin.as_mut().unwrap()
    }

    // Take field
    pub fn take_negativeReactivePowerKVArPerMin(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.negativeReactivePowerKVArPerMin.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue negativeRealPowerKWPerMin = 2;


    pub fn get_negativeRealPowerKWPerMin(&self) -> &::protobuf::well_known_types::FloatValue {
        self.negativeRealPowerKWPerMin.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_negativeRealPowerKWPerMin(&mut self) {
        self.negativeRealPowerKWPerMin.clear();
    }

    pub fn has_negativeRealPowerKWPerMin(&self) -> bool {
        self.negativeRealPowerKWPerMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negativeRealPowerKWPerMin(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.negativeRealPowerKWPerMin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_negativeRealPowerKWPerMin(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.negativeRealPowerKWPerMin.is_none() {
            self.negativeRealPowerKWPerMin.set_default();
        }
        self.negativeRealPowerKWPerMin.as_mut().unwrap()
    }

    // Take field
    pub fn take_negativeRealPowerKWPerMin(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.negativeRealPowerKWPerMin.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue positiveReactivePowerKVArPerMin = 3;


    pub fn get_positiveReactivePowerKVArPerMin(&self) -> &::protobuf::well_known_types::FloatValue {
        self.positiveReactivePowerKVArPerMin.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_positiveReactivePowerKVArPerMin(&mut self) {
        self.positiveReactivePowerKVArPerMin.clear();
    }

    pub fn has_positiveReactivePowerKVArPerMin(&self) -> bool {
        self.positiveReactivePowerKVArPerMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positiveReactivePowerKVArPerMin(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.positiveReactivePowerKVArPerMin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_positiveReactivePowerKVArPerMin(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.positiveReactivePowerKVArPerMin.is_none() {
            self.positiveReactivePowerKVArPerMin.set_default();
        }
        self.positiveReactivePowerKVArPerMin.as_mut().unwrap()
    }

    // Take field
    pub fn take_positiveReactivePowerKVArPerMin(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.positiveReactivePowerKVArPerMin.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue positiveRealPowerKWPerMin = 4;


    pub fn get_positiveRealPowerKWPerMin(&self) -> &::protobuf::well_known_types::FloatValue {
        self.positiveRealPowerKWPerMin.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_positiveRealPowerKWPerMin(&mut self) {
        self.positiveRealPowerKWPerMin.clear();
    }

    pub fn has_positiveRealPowerKWPerMin(&self) -> bool {
        self.positiveRealPowerKWPerMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positiveRealPowerKWPerMin(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.positiveRealPowerKWPerMin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_positiveRealPowerKWPerMin(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.positiveRealPowerKWPerMin.is_none() {
            self.positiveRealPowerKWPerMin.set_default();
        }
        self.positiveRealPowerKWPerMin.as_mut().unwrap()
    }

    // Take field
    pub fn take_positiveRealPowerKWPerMin(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.positiveRealPowerKWPerMin.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for RampRate {
    fn is_initialized(&self) -> bool {
        for v in &self.negativeReactivePowerKVArPerMin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.negativeRealPowerKWPerMin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.positiveReactivePowerKVArPerMin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.positiveRealPowerKWPerMin {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.negativeReactivePowerKVArPerMin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.negativeRealPowerKWPerMin)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.positiveReactivePowerKVArPerMin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.positiveRealPowerKWPerMin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.negativeReactivePowerKVArPerMin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.negativeRealPowerKWPerMin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.positiveReactivePowerKVArPerMin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.positiveRealPowerKWPerMin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.negativeReactivePowerKVArPerMin.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.negativeRealPowerKWPerMin.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.positiveReactivePowerKVArPerMin.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.positiveRealPowerKWPerMin.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RampRate {
        RampRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "negativeReactivePowerKVArPerMin",
                |m: &RampRate| { &m.negativeReactivePowerKVArPerMin },
                |m: &mut RampRate| { &mut m.negativeReactivePowerKVArPerMin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "negativeRealPowerKWPerMin",
                |m: &RampRate| { &m.negativeRealPowerKWPerMin },
                |m: &mut RampRate| { &mut m.negativeRealPowerKWPerMin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "positiveReactivePowerKVArPerMin",
                |m: &RampRate| { &m.positiveReactivePowerKVArPerMin },
                |m: &mut RampRate| { &mut m.positiveReactivePowerKVArPerMin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "positiveRealPowerKWPerMin",
                |m: &RampRate| { &m.positiveRealPowerKWPerMin },
                |m: &mut RampRate| { &mut m.positiveRealPowerKWPerMin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RampRate>(
                "RampRate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RampRate {
        static instance: ::protobuf::rt::LazyV2<RampRate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RampRate::new)
    }
}

impl ::protobuf::Clear for RampRate {
    fn clear(&mut self) {
        self.negativeReactivePowerKVArPerMin.clear();
        self.negativeRealPowerKWPerMin.clear();
        self.positiveReactivePowerKVArPerMin.clear();
        self.positiveRealPowerKWPerMin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RampRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RampRate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReadingMessageInfo {
    // message fields
    messageInfo: ::protobuf::SingularPtrField<MessageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadingMessageInfo {
    fn default() -> &'a ReadingMessageInfo {
        <ReadingMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl ReadingMessageInfo {
    pub fn new() -> ReadingMessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.MessageInfo messageInfo = 1;


    pub fn get_messageInfo(&self) -> &MessageInfo {
        self.messageInfo.as_ref().unwrap_or_else(|| <MessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageInfo(&mut self) {
        self.messageInfo.clear();
    }

    pub fn has_messageInfo(&self) -> bool {
        self.messageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageInfo(&mut self, v: MessageInfo) {
        self.messageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageInfo(&mut self) -> &mut MessageInfo {
        if self.messageInfo.is_none() {
            self.messageInfo.set_default();
        }
        self.messageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageInfo(&mut self) -> MessageInfo {
        self.messageInfo.take().unwrap_or_else(|| MessageInfo::new())
    }
}

impl ::protobuf::Message for ReadingMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.messageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadingMessageInfo {
        ReadingMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageInfo>>(
                "messageInfo",
                |m: &ReadingMessageInfo| { &m.messageInfo },
                |m: &mut ReadingMessageInfo| { &mut m.messageInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadingMessageInfo>(
                "ReadingMessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadingMessageInfo {
        static instance: ::protobuf::rt::LazyV2<ReadingMessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadingMessageInfo::new)
    }
}

impl ::protobuf::Clear for ReadingMessageInfo {
    fn clear(&mut self) {
        self.messageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadingMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadingMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReadingMMTR {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    DmdVAh: ::protobuf::SingularPtrField<BCR>,
    DmdVArh: ::protobuf::SingularPtrField<BCR>,
    DmdWh: ::protobuf::SingularPtrField<BCR>,
    SupVAh: ::protobuf::SingularPtrField<BCR>,
    SupVArh: ::protobuf::SingularPtrField<BCR>,
    SupWh: ::protobuf::SingularPtrField<BCR>,
    TotVAh: ::protobuf::SingularPtrField<BCR>,
    TotVArh: ::protobuf::SingularPtrField<BCR>,
    TotWh: ::protobuf::SingularPtrField<BCR>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadingMMTR {
    fn default() -> &'a ReadingMMTR {
        <ReadingMMTR as ::protobuf::Message>::default_instance()
    }
}

impl ReadingMMTR {
    pub fn new() -> ReadingMMTR {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.BCR DmdVAh = 2;


    pub fn get_DmdVAh(&self) -> &BCR {
        self.DmdVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdVAh(&mut self) {
        self.DmdVAh.clear();
    }

    pub fn has_DmdVAh(&self) -> bool {
        self.DmdVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdVAh(&mut self, v: BCR) {
        self.DmdVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdVAh(&mut self) -> &mut BCR {
        if self.DmdVAh.is_none() {
            self.DmdVAh.set_default();
        }
        self.DmdVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdVAh(&mut self) -> BCR {
        self.DmdVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR DmdVArh = 3;


    pub fn get_DmdVArh(&self) -> &BCR {
        self.DmdVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdVArh(&mut self) {
        self.DmdVArh.clear();
    }

    pub fn has_DmdVArh(&self) -> bool {
        self.DmdVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdVArh(&mut self, v: BCR) {
        self.DmdVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdVArh(&mut self) -> &mut BCR {
        if self.DmdVArh.is_none() {
            self.DmdVArh.set_default();
        }
        self.DmdVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdVArh(&mut self) -> BCR {
        self.DmdVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR DmdWh = 4;


    pub fn get_DmdWh(&self) -> &BCR {
        self.DmdWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DmdWh(&mut self) {
        self.DmdWh.clear();
    }

    pub fn has_DmdWh(&self) -> bool {
        self.DmdWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DmdWh(&mut self, v: BCR) {
        self.DmdWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DmdWh(&mut self) -> &mut BCR {
        if self.DmdWh.is_none() {
            self.DmdWh.set_default();
        }
        self.DmdWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_DmdWh(&mut self) -> BCR {
        self.DmdWh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupVAh = 5;


    pub fn get_SupVAh(&self) -> &BCR {
        self.SupVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupVAh(&mut self) {
        self.SupVAh.clear();
    }

    pub fn has_SupVAh(&self) -> bool {
        self.SupVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupVAh(&mut self, v: BCR) {
        self.SupVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupVAh(&mut self) -> &mut BCR {
        if self.SupVAh.is_none() {
            self.SupVAh.set_default();
        }
        self.SupVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupVAh(&mut self) -> BCR {
        self.SupVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupVArh = 6;


    pub fn get_SupVArh(&self) -> &BCR {
        self.SupVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupVArh(&mut self) {
        self.SupVArh.clear();
    }

    pub fn has_SupVArh(&self) -> bool {
        self.SupVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupVArh(&mut self, v: BCR) {
        self.SupVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupVArh(&mut self) -> &mut BCR {
        if self.SupVArh.is_none() {
            self.SupVArh.set_default();
        }
        self.SupVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupVArh(&mut self) -> BCR {
        self.SupVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR SupWh = 7;


    pub fn get_SupWh(&self) -> &BCR {
        self.SupWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SupWh(&mut self) {
        self.SupWh.clear();
    }

    pub fn has_SupWh(&self) -> bool {
        self.SupWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SupWh(&mut self, v: BCR) {
        self.SupWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SupWh(&mut self) -> &mut BCR {
        if self.SupWh.is_none() {
            self.SupWh.set_default();
        }
        self.SupWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_SupWh(&mut self) -> BCR {
        self.SupWh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotVAh = 8;


    pub fn get_TotVAh(&self) -> &BCR {
        self.TotVAh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotVAh(&mut self) {
        self.TotVAh.clear();
    }

    pub fn has_TotVAh(&self) -> bool {
        self.TotVAh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotVAh(&mut self, v: BCR) {
        self.TotVAh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotVAh(&mut self) -> &mut BCR {
        if self.TotVAh.is_none() {
            self.TotVAh.set_default();
        }
        self.TotVAh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotVAh(&mut self) -> BCR {
        self.TotVAh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotVArh = 9;


    pub fn get_TotVArh(&self) -> &BCR {
        self.TotVArh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotVArh(&mut self) {
        self.TotVArh.clear();
    }

    pub fn has_TotVArh(&self) -> bool {
        self.TotVArh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotVArh(&mut self, v: BCR) {
        self.TotVArh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotVArh(&mut self) -> &mut BCR {
        if self.TotVArh.is_none() {
            self.TotVArh.set_default();
        }
        self.TotVArh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotVArh(&mut self) -> BCR {
        self.TotVArh.take().unwrap_or_else(|| BCR::new())
    }

    // .commonmodule.BCR TotWh = 10;


    pub fn get_TotWh(&self) -> &BCR {
        self.TotWh.as_ref().unwrap_or_else(|| <BCR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TotWh(&mut self) {
        self.TotWh.clear();
    }

    pub fn has_TotWh(&self) -> bool {
        self.TotWh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TotWh(&mut self, v: BCR) {
        self.TotWh = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TotWh(&mut self) -> &mut BCR {
        if self.TotWh.is_none() {
            self.TotWh.set_default();
        }
        self.TotWh.as_mut().unwrap()
    }

    // Take field
    pub fn take_TotWh(&mut self) -> BCR {
        self.TotWh.take().unwrap_or_else(|| BCR::new())
    }
}

impl ::protobuf::Message for ReadingMMTR {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DmdWh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SupWh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotVAh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotVArh {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TotWh {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdVAh)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdVArh)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DmdWh)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupVAh)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupVArh)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SupWh)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotVAh)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotVArh)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TotWh)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DmdWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SupWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotVAh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotVArh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TotWh.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdVAh.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdVArh.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DmdWh.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupVAh.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupVArh.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SupWh.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotVAh.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotVArh.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TotWh.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadingMMTR {
        ReadingMMTR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &ReadingMMTR| { &m.logicalNode },
                |m: &mut ReadingMMTR| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdVAh",
                |m: &ReadingMMTR| { &m.DmdVAh },
                |m: &mut ReadingMMTR| { &mut m.DmdVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdVArh",
                |m: &ReadingMMTR| { &m.DmdVArh },
                |m: &mut ReadingMMTR| { &mut m.DmdVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "DmdWh",
                |m: &ReadingMMTR| { &m.DmdWh },
                |m: &mut ReadingMMTR| { &mut m.DmdWh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupVAh",
                |m: &ReadingMMTR| { &m.SupVAh },
                |m: &mut ReadingMMTR| { &mut m.SupVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupVArh",
                |m: &ReadingMMTR| { &m.SupVArh },
                |m: &mut ReadingMMTR| { &mut m.SupVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "SupWh",
                |m: &ReadingMMTR| { &m.SupWh },
                |m: &mut ReadingMMTR| { &mut m.SupWh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotVAh",
                |m: &ReadingMMTR| { &m.TotVAh },
                |m: &mut ReadingMMTR| { &mut m.TotVAh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotVArh",
                |m: &ReadingMMTR| { &m.TotVArh },
                |m: &mut ReadingMMTR| { &mut m.TotVArh },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCR>>(
                "TotWh",
                |m: &ReadingMMTR| { &m.TotWh },
                |m: &mut ReadingMMTR| { &mut m.TotWh },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadingMMTR>(
                "ReadingMMTR",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadingMMTR {
        static instance: ::protobuf::rt::LazyV2<ReadingMMTR> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadingMMTR::new)
    }
}

impl ::protobuf::Clear for ReadingMMTR {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.DmdVAh.clear();
        self.DmdVArh.clear();
        self.DmdWh.clear();
        self.SupVAh.clear();
        self.SupVArh.clear();
        self.SupWh.clear();
        self.TotVAh.clear();
        self.TotVArh.clear();
        self.TotWh.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadingMMTR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadingMMTR {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WYE {
    // message fields
    net: ::protobuf::SingularPtrField<CMV>,
    neut: ::protobuf::SingularPtrField<CMV>,
    phsA: ::protobuf::SingularPtrField<CMV>,
    phsB: ::protobuf::SingularPtrField<CMV>,
    phsC: ::protobuf::SingularPtrField<CMV>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WYE {
    fn default() -> &'a WYE {
        <WYE as ::protobuf::Message>::default_instance()
    }
}

impl WYE {
    pub fn new() -> WYE {
        ::std::default::Default::default()
    }

    // .commonmodule.CMV net = 1;


    pub fn get_net(&self) -> &CMV {
        self.net.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_net(&mut self) {
        self.net.clear();
    }

    pub fn has_net(&self) -> bool {
        self.net.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net(&mut self, v: CMV) {
        self.net = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net(&mut self) -> &mut CMV {
        if self.net.is_none() {
            self.net.set_default();
        }
        self.net.as_mut().unwrap()
    }

    // Take field
    pub fn take_net(&mut self) -> CMV {
        self.net.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV neut = 2;


    pub fn get_neut(&self) -> &CMV {
        self.neut.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_neut(&mut self) {
        self.neut.clear();
    }

    pub fn has_neut(&self) -> bool {
        self.neut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neut(&mut self, v: CMV) {
        self.neut = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neut(&mut self) -> &mut CMV {
        if self.neut.is_none() {
            self.neut.set_default();
        }
        self.neut.as_mut().unwrap()
    }

    // Take field
    pub fn take_neut(&mut self) -> CMV {
        self.neut.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV phsA = 3;


    pub fn get_phsA(&self) -> &CMV {
        self.phsA.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsA(&mut self) {
        self.phsA.clear();
    }

    pub fn has_phsA(&self) -> bool {
        self.phsA.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsA(&mut self, v: CMV) {
        self.phsA = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsA(&mut self) -> &mut CMV {
        if self.phsA.is_none() {
            self.phsA.set_default();
        }
        self.phsA.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsA(&mut self) -> CMV {
        self.phsA.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV phsB = 4;


    pub fn get_phsB(&self) -> &CMV {
        self.phsB.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsB(&mut self) {
        self.phsB.clear();
    }

    pub fn has_phsB(&self) -> bool {
        self.phsB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsB(&mut self, v: CMV) {
        self.phsB = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsB(&mut self) -> &mut CMV {
        if self.phsB.is_none() {
            self.phsB.set_default();
        }
        self.phsB.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsB(&mut self) -> CMV {
        self.phsB.take().unwrap_or_else(|| CMV::new())
    }

    // .commonmodule.CMV phsC = 5;


    pub fn get_phsC(&self) -> &CMV {
        self.phsC.as_ref().unwrap_or_else(|| <CMV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phsC(&mut self) {
        self.phsC.clear();
    }

    pub fn has_phsC(&self) -> bool {
        self.phsC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phsC(&mut self, v: CMV) {
        self.phsC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phsC(&mut self) -> &mut CMV {
        if self.phsC.is_none() {
            self.phsC.set_default();
        }
        self.phsC.as_mut().unwrap()
    }

    // Take field
    pub fn take_phsC(&mut self) -> CMV {
        self.phsC.take().unwrap_or_else(|| CMV::new())
    }
}

impl ::protobuf::Message for WYE {
    fn is_initialized(&self) -> bool {
        for v in &self.net {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.neut {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsA {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsB {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phsC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.neut)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsA)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsB)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phsC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.net.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.neut.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsA.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsB.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phsC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.net.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.neut.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsA.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsB.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phsC.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WYE {
        WYE::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "net",
                |m: &WYE| { &m.net },
                |m: &mut WYE| { &mut m.net },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "neut",
                |m: &WYE| { &m.neut },
                |m: &mut WYE| { &mut m.neut },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsA",
                |m: &WYE| { &m.phsA },
                |m: &mut WYE| { &mut m.phsA },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsB",
                |m: &WYE| { &m.phsB },
                |m: &mut WYE| { &mut m.phsB },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMV>>(
                "phsC",
                |m: &WYE| { &m.phsC },
                |m: &mut WYE| { &mut m.phsC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WYE>(
                "WYE",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WYE {
        static instance: ::protobuf::rt::LazyV2<WYE> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WYE::new)
    }
}

impl ::protobuf::Clear for WYE {
    fn clear(&mut self) {
        self.net.clear();
        self.neut.clear();
        self.phsA.clear();
        self.phsB.clear();
        self.phsC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WYE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WYE {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReadingMMXU {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    A: ::protobuf::SingularPtrField<WYE>,
    ClcMth: ::protobuf::SingularPtrField<ENG_CalcMethodKind>,
    Hz: ::protobuf::SingularPtrField<MV>,
    PF: ::protobuf::SingularPtrField<WYE>,
    PFSign: ::protobuf::SingularPtrField<ENG_PFSignKind>,
    PhV: ::protobuf::SingularPtrField<WYE>,
    PPV: ::protobuf::SingularPtrField<DEL>,
    VA: ::protobuf::SingularPtrField<WYE>,
    VAr: ::protobuf::SingularPtrField<WYE>,
    W: ::protobuf::SingularPtrField<WYE>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadingMMXU {
    fn default() -> &'a ReadingMMXU {
        <ReadingMMXU as ::protobuf::Message>::default_instance()
    }
}

impl ReadingMMXU {
    pub fn new() -> ReadingMMXU {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.WYE A = 2;


    pub fn get_A(&self) -> &WYE {
        self.A.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_A(&mut self) {
        self.A.clear();
    }

    pub fn has_A(&self) -> bool {
        self.A.is_some()
    }

    // Param is passed by value, moved
    pub fn set_A(&mut self, v: WYE) {
        self.A = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_A(&mut self) -> &mut WYE {
        if self.A.is_none() {
            self.A.set_default();
        }
        self.A.as_mut().unwrap()
    }

    // Take field
    pub fn take_A(&mut self) -> WYE {
        self.A.take().unwrap_or_else(|| WYE::new())
    }

    // .commonmodule.ENG_CalcMethodKind ClcMth = 3;


    pub fn get_ClcMth(&self) -> &ENG_CalcMethodKind {
        self.ClcMth.as_ref().unwrap_or_else(|| <ENG_CalcMethodKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClcMth(&mut self) {
        self.ClcMth.clear();
    }

    pub fn has_ClcMth(&self) -> bool {
        self.ClcMth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClcMth(&mut self, v: ENG_CalcMethodKind) {
        self.ClcMth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClcMth(&mut self) -> &mut ENG_CalcMethodKind {
        if self.ClcMth.is_none() {
            self.ClcMth.set_default();
        }
        self.ClcMth.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClcMth(&mut self) -> ENG_CalcMethodKind {
        self.ClcMth.take().unwrap_or_else(|| ENG_CalcMethodKind::new())
    }

    // .commonmodule.MV Hz = 4;


    pub fn get_Hz(&self) -> &MV {
        self.Hz.as_ref().unwrap_or_else(|| <MV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Hz(&mut self) {
        self.Hz.clear();
    }

    pub fn has_Hz(&self) -> bool {
        self.Hz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Hz(&mut self, v: MV) {
        self.Hz = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Hz(&mut self) -> &mut MV {
        if self.Hz.is_none() {
            self.Hz.set_default();
        }
        self.Hz.as_mut().unwrap()
    }

    // Take field
    pub fn take_Hz(&mut self) -> MV {
        self.Hz.take().unwrap_or_else(|| MV::new())
    }

    // .commonmodule.WYE PF = 5;


    pub fn get_PF(&self) -> &WYE {
        self.PF.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PF(&mut self) {
        self.PF.clear();
    }

    pub fn has_PF(&self) -> bool {
        self.PF.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PF(&mut self, v: WYE) {
        self.PF = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PF(&mut self) -> &mut WYE {
        if self.PF.is_none() {
            self.PF.set_default();
        }
        self.PF.as_mut().unwrap()
    }

    // Take field
    pub fn take_PF(&mut self) -> WYE {
        self.PF.take().unwrap_or_else(|| WYE::new())
    }

    // .commonmodule.ENG_PFSignKind PFSign = 6;


    pub fn get_PFSign(&self) -> &ENG_PFSignKind {
        self.PFSign.as_ref().unwrap_or_else(|| <ENG_PFSignKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PFSign(&mut self) {
        self.PFSign.clear();
    }

    pub fn has_PFSign(&self) -> bool {
        self.PFSign.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PFSign(&mut self, v: ENG_PFSignKind) {
        self.PFSign = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PFSign(&mut self) -> &mut ENG_PFSignKind {
        if self.PFSign.is_none() {
            self.PFSign.set_default();
        }
        self.PFSign.as_mut().unwrap()
    }

    // Take field
    pub fn take_PFSign(&mut self) -> ENG_PFSignKind {
        self.PFSign.take().unwrap_or_else(|| ENG_PFSignKind::new())
    }

    // .commonmodule.WYE PhV = 7;


    pub fn get_PhV(&self) -> &WYE {
        self.PhV.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PhV(&mut self) {
        self.PhV.clear();
    }

    pub fn has_PhV(&self) -> bool {
        self.PhV.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PhV(&mut self, v: WYE) {
        self.PhV = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PhV(&mut self) -> &mut WYE {
        if self.PhV.is_none() {
            self.PhV.set_default();
        }
        self.PhV.as_mut().unwrap()
    }

    // Take field
    pub fn take_PhV(&mut self) -> WYE {
        self.PhV.take().unwrap_or_else(|| WYE::new())
    }

    // .commonmodule.DEL PPV = 8;


    pub fn get_PPV(&self) -> &DEL {
        self.PPV.as_ref().unwrap_or_else(|| <DEL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PPV(&mut self) {
        self.PPV.clear();
    }

    pub fn has_PPV(&self) -> bool {
        self.PPV.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PPV(&mut self, v: DEL) {
        self.PPV = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PPV(&mut self) -> &mut DEL {
        if self.PPV.is_none() {
            self.PPV.set_default();
        }
        self.PPV.as_mut().unwrap()
    }

    // Take field
    pub fn take_PPV(&mut self) -> DEL {
        self.PPV.take().unwrap_or_else(|| DEL::new())
    }

    // .commonmodule.WYE VA = 9;


    pub fn get_VA(&self) -> &WYE {
        self.VA.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_VA(&mut self) {
        self.VA.clear();
    }

    pub fn has_VA(&self) -> bool {
        self.VA.is_some()
    }

    // Param is passed by value, moved
    pub fn set_VA(&mut self, v: WYE) {
        self.VA = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_VA(&mut self) -> &mut WYE {
        if self.VA.is_none() {
            self.VA.set_default();
        }
        self.VA.as_mut().unwrap()
    }

    // Take field
    pub fn take_VA(&mut self) -> WYE {
        self.VA.take().unwrap_or_else(|| WYE::new())
    }

    // .commonmodule.WYE VAr = 10;


    pub fn get_VAr(&self) -> &WYE {
        self.VAr.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_VAr(&mut self) {
        self.VAr.clear();
    }

    pub fn has_VAr(&self) -> bool {
        self.VAr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_VAr(&mut self, v: WYE) {
        self.VAr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_VAr(&mut self) -> &mut WYE {
        if self.VAr.is_none() {
            self.VAr.set_default();
        }
        self.VAr.as_mut().unwrap()
    }

    // Take field
    pub fn take_VAr(&mut self) -> WYE {
        self.VAr.take().unwrap_or_else(|| WYE::new())
    }

    // .commonmodule.WYE W = 11;


    pub fn get_W(&self) -> &WYE {
        self.W.as_ref().unwrap_or_else(|| <WYE as ::protobuf::Message>::default_instance())
    }
    pub fn clear_W(&mut self) {
        self.W.clear();
    }

    pub fn has_W(&self) -> bool {
        self.W.is_some()
    }

    // Param is passed by value, moved
    pub fn set_W(&mut self, v: WYE) {
        self.W = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_W(&mut self) -> &mut WYE {
        if self.W.is_none() {
            self.W.set_default();
        }
        self.W.as_mut().unwrap()
    }

    // Take field
    pub fn take_W(&mut self) -> WYE {
        self.W.take().unwrap_or_else(|| WYE::new())
    }
}

impl ::protobuf::Message for ReadingMMXU {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.A {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ClcMth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Hz {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PF {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PFSign {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PhV {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PPV {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.VA {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.VAr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.W {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.A)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClcMth)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Hz)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PF)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PFSign)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PhV)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PPV)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.VA)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.VAr)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.W)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.A.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ClcMth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Hz.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PF.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PFSign.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PhV.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PPV.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.VA.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.VAr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.W.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.A.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ClcMth.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Hz.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PF.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PFSign.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PhV.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PPV.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.VA.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.VAr.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.W.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadingMMXU {
        ReadingMMXU::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &ReadingMMXU| { &m.logicalNode },
                |m: &mut ReadingMMXU| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "A",
                |m: &ReadingMMXU| { &m.A },
                |m: &mut ReadingMMXU| { &mut m.A },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_CalcMethodKind>>(
                "ClcMth",
                |m: &ReadingMMXU| { &m.ClcMth },
                |m: &mut ReadingMMXU| { &mut m.ClcMth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MV>>(
                "Hz",
                |m: &ReadingMMXU| { &m.Hz },
                |m: &mut ReadingMMXU| { &mut m.Hz },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "PF",
                |m: &ReadingMMXU| { &m.PF },
                |m: &mut ReadingMMXU| { &mut m.PF },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_PFSignKind>>(
                "PFSign",
                |m: &ReadingMMXU| { &m.PFSign },
                |m: &mut ReadingMMXU| { &mut m.PFSign },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "PhV",
                |m: &ReadingMMXU| { &m.PhV },
                |m: &mut ReadingMMXU| { &mut m.PhV },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DEL>>(
                "PPV",
                |m: &ReadingMMXU| { &m.PPV },
                |m: &mut ReadingMMXU| { &mut m.PPV },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "VA",
                |m: &ReadingMMXU| { &m.VA },
                |m: &mut ReadingMMXU| { &mut m.VA },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "VAr",
                |m: &ReadingMMXU| { &m.VAr },
                |m: &mut ReadingMMXU| { &mut m.VAr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WYE>>(
                "W",
                |m: &ReadingMMXU| { &m.W },
                |m: &mut ReadingMMXU| { &mut m.W },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadingMMXU>(
                "ReadingMMXU",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadingMMXU {
        static instance: ::protobuf::rt::LazyV2<ReadingMMXU> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadingMMXU::new)
    }
}

impl ::protobuf::Clear for ReadingMMXU {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.A.clear();
        self.ClcMth.clear();
        self.Hz.clear();
        self.PF.clear();
        self.PFSign.clear();
        self.PhV.clear();
        self.PPV.clear();
        self.VA.clear();
        self.VAr.clear();
        self.W.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadingMMXU {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadingMMXU {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_DbPosKind {
    // message fields
    pub value: DbPosKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_DbPosKind {
    fn default() -> &'a Optional_DbPosKind {
        <Optional_DbPosKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_DbPosKind {
    pub fn new() -> Optional_DbPosKind {
        ::std::default::Default::default()
    }

    // .commonmodule.DbPosKind value = 1;


    pub fn get_value(&self) -> DbPosKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = DbPosKind::DbPosKind_transient;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DbPosKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_DbPosKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DbPosKind::DbPosKind_transient {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != DbPosKind::DbPosKind_transient {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_DbPosKind {
        Optional_DbPosKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DbPosKind>>(
                "value",
                |m: &Optional_DbPosKind| { &m.value },
                |m: &mut Optional_DbPosKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_DbPosKind>(
                "Optional_DbPosKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_DbPosKind {
        static instance: ::protobuf::rt::LazyV2<Optional_DbPosKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_DbPosKind::new)
    }
}

impl ::protobuf::Clear for Optional_DbPosKind {
    fn clear(&mut self) {
        self.value = DbPosKind::DbPosKind_transient;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_DbPosKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_DbPosKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusDPS {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: DbPosKind,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusDPS {
    fn default() -> &'a StatusDPS {
        <StatusDPS as ::protobuf::Message>::default_instance()
    }
}

impl StatusDPS {
    pub fn new() -> StatusDPS {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // .commonmodule.DbPosKind stVal = 2;


    pub fn get_stVal(&self) -> DbPosKind {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = DbPosKind::DbPosKind_transient;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: DbPosKind) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for StatusDPS {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stVal, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != DbPosKind::DbPosKind_transient {
            my_size += ::protobuf::rt::enum_size(2, self.stVal);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != DbPosKind::DbPosKind_transient {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.stVal))?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusDPS {
        StatusDPS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &StatusDPS| { &m.q },
                |m: &mut StatusDPS| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DbPosKind>>(
                "stVal",
                |m: &StatusDPS| { &m.stVal },
                |m: &mut StatusDPS| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &StatusDPS| { &m.t },
                |m: &mut StatusDPS| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusDPS>(
                "StatusDPS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusDPS {
        static instance: ::protobuf::rt::LazyV2<StatusDPS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusDPS::new)
    }
}

impl ::protobuf::Clear for StatusDPS {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = DbPosKind::DbPosKind_transient;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusDPS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusDPS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusAndEventXCBR {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<LogicalNodeForEventAndStatus>,
    DynamicTest: ::protobuf::SingularPtrField<ENS_DynamicTestKind>,
    Pos: ::protobuf::SingularPtrField<StatusDPS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusAndEventXCBR {
    fn default() -> &'a StatusAndEventXCBR {
        <StatusAndEventXCBR as ::protobuf::Message>::default_instance()
    }
}

impl StatusAndEventXCBR {
    pub fn new() -> StatusAndEventXCBR {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;


    pub fn get_DynamicTest(&self) -> &ENS_DynamicTestKind {
        self.DynamicTest.as_ref().unwrap_or_else(|| <ENS_DynamicTestKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DynamicTest(&mut self) {
        self.DynamicTest.clear();
    }

    pub fn has_DynamicTest(&self) -> bool {
        self.DynamicTest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DynamicTest(&mut self, v: ENS_DynamicTestKind) {
        self.DynamicTest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DynamicTest(&mut self) -> &mut ENS_DynamicTestKind {
        if self.DynamicTest.is_none() {
            self.DynamicTest.set_default();
        }
        self.DynamicTest.as_mut().unwrap()
    }

    // Take field
    pub fn take_DynamicTest(&mut self) -> ENS_DynamicTestKind {
        self.DynamicTest.take().unwrap_or_else(|| ENS_DynamicTestKind::new())
    }

    // .commonmodule.StatusDPS Pos = 3;


    pub fn get_Pos(&self) -> &StatusDPS {
        self.Pos.as_ref().unwrap_or_else(|| <StatusDPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Pos(&mut self) {
        self.Pos.clear();
    }

    pub fn has_Pos(&self) -> bool {
        self.Pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Pos(&mut self, v: StatusDPS) {
        self.Pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pos(&mut self) -> &mut StatusDPS {
        if self.Pos.is_none() {
            self.Pos.set_default();
        }
        self.Pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_Pos(&mut self) -> StatusDPS {
        self.Pos.take().unwrap_or_else(|| StatusDPS::new())
    }
}

impl ::protobuf::Message for StatusAndEventXCBR {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DynamicTest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DynamicTest)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Pos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Pos.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusAndEventXCBR {
        StatusAndEventXCBR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &StatusAndEventXCBR| { &m.logicalNodeForEventAndStatus },
                |m: &mut StatusAndEventXCBR| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENS_DynamicTestKind>>(
                "DynamicTest",
                |m: &StatusAndEventXCBR| { &m.DynamicTest },
                |m: &mut StatusAndEventXCBR| { &mut m.DynamicTest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusDPS>>(
                "Pos",
                |m: &StatusAndEventXCBR| { &m.Pos },
                |m: &mut StatusAndEventXCBR| { &mut m.Pos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusAndEventXCBR>(
                "StatusAndEventXCBR",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusAndEventXCBR {
        static instance: ::protobuf::rt::LazyV2<StatusAndEventXCBR> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusAndEventXCBR::new)
    }
}

impl ::protobuf::Clear for StatusAndEventXCBR {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.DynamicTest.clear();
        self.Pos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusAndEventXCBR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusAndEventXCBR {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusISC {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: i32,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusISC {
    fn default() -> &'a StatusISC {
        <StatusISC as ::protobuf::Message>::default_instance()
    }
}

impl StatusISC {
    pub fn new() -> StatusISC {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // int32 stVal = 2;


    pub fn get_stVal(&self) -> i32 {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = 0;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: i32) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for StatusISC {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stVal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stVal, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != 0 {
            os.write_int32(2, self.stVal)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusISC {
        StatusISC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &StatusISC| { &m.q },
                |m: &mut StatusISC| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stVal",
                |m: &StatusISC| { &m.stVal },
                |m: &mut StatusISC| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &StatusISC| { &m.t },
                |m: &mut StatusISC| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusISC>(
                "StatusISC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusISC {
        static instance: ::protobuf::rt::LazyV2<StatusISC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusISC::new)
    }
}

impl ::protobuf::Clear for StatusISC {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = 0;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusISC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusISC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusMessageInfo {
    // message fields
    messageInfo: ::protobuf::SingularPtrField<MessageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusMessageInfo {
    fn default() -> &'a StatusMessageInfo {
        <StatusMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl StatusMessageInfo {
    pub fn new() -> StatusMessageInfo {
        ::std::default::Default::default()
    }

    // .commonmodule.MessageInfo messageInfo = 1;


    pub fn get_messageInfo(&self) -> &MessageInfo {
        self.messageInfo.as_ref().unwrap_or_else(|| <MessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_messageInfo(&mut self) {
        self.messageInfo.clear();
    }

    pub fn has_messageInfo(&self) -> bool {
        self.messageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageInfo(&mut self, v: MessageInfo) {
        self.messageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageInfo(&mut self) -> &mut MessageInfo {
        if self.messageInfo.is_none() {
            self.messageInfo.set_default();
        }
        self.messageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageInfo(&mut self) -> MessageInfo {
        self.messageInfo.take().unwrap_or_else(|| MessageInfo::new())
    }
}

impl ::protobuf::Message for StatusMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.messageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.messageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.messageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusMessageInfo {
        StatusMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageInfo>>(
                "messageInfo",
                |m: &StatusMessageInfo| { &m.messageInfo },
                |m: &mut StatusMessageInfo| { &mut m.messageInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusMessageInfo>(
                "StatusMessageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusMessageInfo {
        static instance: ::protobuf::rt::LazyV2<StatusMessageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusMessageInfo::new)
    }
}

impl ::protobuf::Clear for StatusMessageInfo {
    fn clear(&mut self) {
        self.messageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusSPC {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: bool,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusSPC {
    fn default() -> &'a StatusSPC {
        <StatusSPC as ::protobuf::Message>::default_instance()
    }
}

impl StatusSPC {
    pub fn new() -> StatusSPC {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // bool stVal = 2;


    pub fn get_stVal(&self) -> bool {
        self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal = false;
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: bool) {
        self.stVal = v;
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for StatusSPC {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stVal = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stVal != false {
            my_size += 2;
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stVal != false {
            os.write_bool(2, self.stVal)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusSPC {
        StatusSPC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &StatusSPC| { &m.q },
                |m: &mut StatusSPC| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stVal",
                |m: &StatusSPC| { &m.stVal },
                |m: &mut StatusSPC| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &StatusSPC| { &m.t },
                |m: &mut StatusSPC| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusSPC>(
                "StatusSPC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusSPC {
        static instance: ::protobuf::rt::LazyV2<StatusSPC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusSPC::new)
    }
}

impl ::protobuf::Clear for StatusSPC {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal = false;
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusSPC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusSPC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StatusValue {
    // message fields
    identifiedObject: ::protobuf::SingularPtrField<IdentifiedObject>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusValue {
    fn default() -> &'a StatusValue {
        <StatusValue as ::protobuf::Message>::default_instance()
    }
}

impl StatusValue {
    pub fn new() -> StatusValue {
        ::std::default::Default::default()
    }

    // .commonmodule.IdentifiedObject identifiedObject = 1;


    pub fn get_identifiedObject(&self) -> &IdentifiedObject {
        self.identifiedObject.as_ref().unwrap_or_else(|| <IdentifiedObject as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifiedObject(&mut self) {
        self.identifiedObject.clear();
    }

    pub fn has_identifiedObject(&self) -> bool {
        self.identifiedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifiedObject(&mut self, v: IdentifiedObject) {
        self.identifiedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifiedObject(&mut self) -> &mut IdentifiedObject {
        if self.identifiedObject.is_none() {
            self.identifiedObject.set_default();
        }
        self.identifiedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifiedObject(&mut self) -> IdentifiedObject {
        self.identifiedObject.take().unwrap_or_else(|| IdentifiedObject::new())
    }
}

impl ::protobuf::Message for StatusValue {
    fn is_initialized(&self) -> bool {
        for v in &self.identifiedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifiedObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifiedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifiedObject.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusValue {
        StatusValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifiedObject>>(
                "identifiedObject",
                |m: &StatusValue| { &m.identifiedObject },
                |m: &mut StatusValue| { &mut m.identifiedObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusValue>(
                "StatusValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusValue {
        static instance: ::protobuf::rt::LazyV2<StatusValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusValue::new)
    }
}

impl ::protobuf::Clear for StatusValue {
    fn clear(&mut self) {
        self.identifiedObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VSS {
    // message fields
    q: ::protobuf::SingularPtrField<Quality>,
    pub stVal: ::std::string::String,
    t: ::protobuf::SingularPtrField<Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VSS {
    fn default() -> &'a VSS {
        <VSS as ::protobuf::Message>::default_instance()
    }
}

impl VSS {
    pub fn new() -> VSS {
        ::std::default::Default::default()
    }

    // .commonmodule.Quality q = 1;


    pub fn get_q(&self) -> &Quality {
        self.q.as_ref().unwrap_or_else(|| <Quality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quality) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quality {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quality {
        self.q.take().unwrap_or_else(|| Quality::new())
    }

    // string stVal = 2;


    pub fn get_stVal(&self) -> &str {
        &self.stVal
    }
    pub fn clear_stVal(&mut self) {
        self.stVal.clear();
    }

    // Param is passed by value, moved
    pub fn set_stVal(&mut self, v: ::std::string::String) {
        self.stVal = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stVal(&mut self) -> &mut ::std::string::String {
        &mut self.stVal
    }

    // Take field
    pub fn take_stVal(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stVal, ::std::string::String::new())
    }

    // .commonmodule.Timestamp t = 3;


    pub fn get_t(&self) -> &Timestamp {
        self.t.as_ref().unwrap_or_else(|| <Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: Timestamp) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut Timestamp {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> Timestamp {
        self.t.take().unwrap_or_else(|| Timestamp::new())
    }
}

impl ::protobuf::Message for VSS {
    fn is_initialized(&self) -> bool {
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stVal)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.stVal.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stVal);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.stVal.is_empty() {
            os.write_string(2, &self.stVal)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VSS {
        VSS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quality>>(
                "q",
                |m: &VSS| { &m.q },
                |m: &mut VSS| { &mut m.q },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stVal",
                |m: &VSS| { &m.stVal },
                |m: &mut VSS| { &mut m.stVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timestamp>>(
                "t",
                |m: &VSS| { &m.t },
                |m: &mut VSS| { &mut m.t },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VSS>(
                "VSS",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VSS {
        static instance: ::protobuf::rt::LazyV2<VSS> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VSS::new)
    }
}

impl ::protobuf::Clear for VSS {
    fn clear(&mut self) {
        self.q.clear();
        self.stVal.clear();
        self.t.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VSS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VSS {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct StringStatusGGIO {
    // message fields
    logicalNode: ::protobuf::SingularPtrField<LogicalNode>,
    Phase: ::protobuf::SingularPtrField<Optional_PhaseCodeKind>,
    StrIn: ::protobuf::SingularPtrField<VSS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringStatusGGIO {
    fn default() -> &'a StringStatusGGIO {
        <StringStatusGGIO as ::protobuf::Message>::default_instance()
    }
}

impl StringStatusGGIO {
    pub fn new() -> StringStatusGGIO {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNode logicalNode = 1;


    pub fn get_logicalNode(&self) -> &LogicalNode {
        self.logicalNode.as_ref().unwrap_or_else(|| <LogicalNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNode(&mut self) {
        self.logicalNode.clear();
    }

    pub fn has_logicalNode(&self) -> bool {
        self.logicalNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNode(&mut self, v: LogicalNode) {
        self.logicalNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNode(&mut self) -> &mut LogicalNode {
        if self.logicalNode.is_none() {
            self.logicalNode.set_default();
        }
        self.logicalNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNode(&mut self) -> LogicalNode {
        self.logicalNode.take().unwrap_or_else(|| LogicalNode::new())
    }

    // .commonmodule.Optional_PhaseCodeKind Phase = 2;


    pub fn get_Phase(&self) -> &Optional_PhaseCodeKind {
        self.Phase.as_ref().unwrap_or_else(|| <Optional_PhaseCodeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Phase(&mut self) {
        self.Phase.clear();
    }

    pub fn has_Phase(&self) -> bool {
        self.Phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Phase(&mut self, v: Optional_PhaseCodeKind) {
        self.Phase = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Phase(&mut self) -> &mut Optional_PhaseCodeKind {
        if self.Phase.is_none() {
            self.Phase.set_default();
        }
        self.Phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_Phase(&mut self) -> Optional_PhaseCodeKind {
        self.Phase.take().unwrap_or_else(|| Optional_PhaseCodeKind::new())
    }

    // .commonmodule.VSS StrIn = 3;


    pub fn get_StrIn(&self) -> &VSS {
        self.StrIn.as_ref().unwrap_or_else(|| <VSS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_StrIn(&mut self) {
        self.StrIn.clear();
    }

    pub fn has_StrIn(&self) -> bool {
        self.StrIn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_StrIn(&mut self, v: VSS) {
        self.StrIn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_StrIn(&mut self) -> &mut VSS {
        if self.StrIn.is_none() {
            self.StrIn.set_default();
        }
        self.StrIn.as_mut().unwrap()
    }

    // Take field
    pub fn take_StrIn(&mut self) -> VSS {
        self.StrIn.take().unwrap_or_else(|| VSS::new())
    }
}

impl ::protobuf::Message for StringStatusGGIO {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Phase {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.StrIn {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Phase)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.StrIn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.StrIn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNode.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Phase.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.StrIn.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStatusGGIO {
        StringStatusGGIO::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalNode>>(
                "logicalNode",
                |m: &StringStatusGGIO| { &m.logicalNode },
                |m: &mut StringStatusGGIO| { &mut m.logicalNode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Optional_PhaseCodeKind>>(
                "Phase",
                |m: &StringStatusGGIO| { &m.Phase },
                |m: &mut StringStatusGGIO| { &mut m.Phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VSS>>(
                "StrIn",
                |m: &StringStatusGGIO| { &m.StrIn },
                |m: &mut StringStatusGGIO| { &mut m.StrIn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringStatusGGIO>(
                "StringStatusGGIO",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringStatusGGIO {
        static instance: ::protobuf::rt::LazyV2<StringStatusGGIO> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringStatusGGIO::new)
    }
}

impl ::protobuf::Clear for StringStatusGGIO {
    fn clear(&mut self) {
        self.logicalNode.clear();
        self.Phase.clear();
        self.StrIn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringStatusGGIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStatusGGIO {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SwitchPoint {
    // message fields
    Pos: ::protobuf::SingularPtrField<ControlDPC>,
    startTime: ::protobuf::SingularPtrField<ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchPoint {
    fn default() -> &'a SwitchPoint {
        <SwitchPoint as ::protobuf::Message>::default_instance()
    }
}

impl SwitchPoint {
    pub fn new() -> SwitchPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC Pos = 1;


    pub fn get_Pos(&self) -> &ControlDPC {
        self.Pos.as_ref().unwrap_or_else(|| <ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Pos(&mut self) {
        self.Pos.clear();
    }

    pub fn has_Pos(&self) -> bool {
        self.Pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Pos(&mut self, v: ControlDPC) {
        self.Pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Pos(&mut self) -> &mut ControlDPC {
        if self.Pos.is_none() {
            self.Pos.set_default();
        }
        self.Pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_Pos(&mut self) -> ControlDPC {
        self.Pos.take().unwrap_or_else(|| ControlDPC::new())
    }

    // .commonmodule.ControlTimestamp startTime = 2;


    pub fn get_startTime(&self) -> &ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| ControlTimestamp::new())
    }
}

impl ::protobuf::Message for SwitchPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.Pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Pos)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Pos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchPoint {
        SwitchPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlDPC>>(
                "Pos",
                |m: &SwitchPoint| { &m.Pos },
                |m: &mut SwitchPoint| { &mut m.Pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ControlTimestamp>>(
                "startTime",
                |m: &SwitchPoint| { &m.startTime },
                |m: &mut SwitchPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchPoint>(
                "SwitchPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchPoint {
        static instance: ::protobuf::rt::LazyV2<SwitchPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchPoint::new)
    }
}

impl ::protobuf::Clear for SwitchPoint {
    fn clear(&mut self) {
        self.Pos.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SwitchCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<SwitchPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchCSG {
    fn default() -> &'a SwitchCSG {
        <SwitchCSG as ::protobuf::Message>::default_instance()
    }
}

impl SwitchCSG {
    pub fn new() -> SwitchCSG {
        ::std::default::Default::default()
    }

    // repeated .commonmodule.SwitchPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[SwitchPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<SwitchPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<SwitchPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<SwitchPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SwitchCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchCSG {
        SwitchCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SwitchPoint>>(
                "crvPts",
                |m: &SwitchCSG| { &m.crvPts },
                |m: &mut SwitchCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchCSG>(
                "SwitchCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchCSG {
        static instance: ::protobuf::rt::LazyV2<SwitchCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchCSG::new)
    }
}

impl ::protobuf::Clear for SwitchCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SwitchControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<SwitchCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchControlScheduleFSCH {
    fn default() -> &'a SwitchControlScheduleFSCH {
        <SwitchControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl SwitchControlScheduleFSCH {
    pub fn new() -> SwitchControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .commonmodule.SwitchCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &SwitchCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <SwitchCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: SwitchCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut SwitchCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> SwitchCSG {
        self.ValDCSG.take().unwrap_or_else(|| SwitchCSG::new())
    }
}

impl ::protobuf::Message for SwitchControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchControlScheduleFSCH {
        SwitchControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SwitchCSG>>(
                "ValDCSG",
                |m: &SwitchControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut SwitchControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchControlScheduleFSCH>(
                "SwitchControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<SwitchControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for SwitchControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_StateKind {
    // message fields
    pub value: StateKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_StateKind {
    fn default() -> &'a Optional_StateKind {
        <Optional_StateKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_StateKind {
    pub fn new() -> Optional_StateKind {
        ::std::default::Default::default()
    }

    // .commonmodule.StateKind value = 1;


    pub fn get_value(&self) -> StateKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = StateKind::StateKind_off;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StateKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_StateKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StateKind::StateKind_off {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != StateKind::StateKind_off {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_StateKind {
        Optional_StateKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StateKind>>(
                "value",
                |m: &Optional_StateKind| { &m.value },
                |m: &mut Optional_StateKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_StateKind>(
                "Optional_StateKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_StateKind {
        static instance: ::protobuf::rt::LazyV2<Optional_StateKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_StateKind::new)
    }
}

impl ::protobuf::Clear for Optional_StateKind {
    fn clear(&mut self) {
        self.value = StateKind::StateKind_off;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_StateKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_StateKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum UnitSymbolKind {
    UnitSymbolKind_none = 0,
    UnitSymbolKind_meter = 2,
    UnitSymbolKind_gram = 3,
    UnitSymbolKind_Amp = 5,
    UnitSymbolKind_deg = 9,
    UnitSymbolKind_rad = 10,
    UnitSymbolKind_degC = 23,
    UnitSymbolKind_Farad = 25,
    UnitSymbolKind_sec = 27,
    UnitSymbolKind_Henry = 28,
    UnitSymbolKind_V = 29,
    UnitSymbolKind_ohm = 30,
    UnitSymbolKind_Joule = 31,
    UnitSymbolKind_Newton = 32,
    UnitSymbolKind_Hz = 33,
    UnitSymbolKind_W = 38,
    UnitSymbolKind_Pa = 39,
    UnitSymbolKind_m2 = 41,
    UnitSymbolKind_Siemens = 53,
    UnitSymbolKind_VA = 61,
    UnitSymbolKind_VAr = 63,
    UnitSymbolKind_wPerVA = 65,
    UnitSymbolKind_VAh = 71,
    UnitSymbolKind_Wh = 72,
    UnitSymbolKind_VArh = 73,
    UnitSymbolKind_hzPerS = 75,
    UnitSymbolKind_wPerS = 81,
    UnitSymbolKind_other = 100,
    UnitSymbolKind_Ah = 106,
    UnitSymbolKind_min = 159,
    UnitSymbolKind_hour = 160,
    UnitSymbolKind_m3 = 166,
    UnitSymbolKind_wPerM2 = 179,
    UnitSymbolKind_degF = 279,
    UnitSymbolKind_mph = 500,
}

impl ::protobuf::ProtobufEnum for UnitSymbolKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UnitSymbolKind> {
        match value {
            0 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_none),
            2 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_meter),
            3 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_gram),
            5 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Amp),
            9 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_deg),
            10 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_rad),
            23 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_degC),
            25 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Farad),
            27 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_sec),
            28 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Henry),
            29 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_V),
            30 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_ohm),
            31 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Joule),
            32 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Newton),
            33 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Hz),
            38 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_W),
            39 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Pa),
            41 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_m2),
            53 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Siemens),
            61 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_VA),
            63 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_VAr),
            65 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_wPerVA),
            71 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_VAh),
            72 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Wh),
            73 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_VArh),
            75 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_hzPerS),
            81 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_wPerS),
            100 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_other),
            106 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_Ah),
            159 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_min),
            160 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_hour),
            166 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_m3),
            179 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_wPerM2),
            279 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_degF),
            500 => ::std::option::Option::Some(UnitSymbolKind::UnitSymbolKind_mph),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UnitSymbolKind] = &[
            UnitSymbolKind::UnitSymbolKind_none,
            UnitSymbolKind::UnitSymbolKind_meter,
            UnitSymbolKind::UnitSymbolKind_gram,
            UnitSymbolKind::UnitSymbolKind_Amp,
            UnitSymbolKind::UnitSymbolKind_deg,
            UnitSymbolKind::UnitSymbolKind_rad,
            UnitSymbolKind::UnitSymbolKind_degC,
            UnitSymbolKind::UnitSymbolKind_Farad,
            UnitSymbolKind::UnitSymbolKind_sec,
            UnitSymbolKind::UnitSymbolKind_Henry,
            UnitSymbolKind::UnitSymbolKind_V,
            UnitSymbolKind::UnitSymbolKind_ohm,
            UnitSymbolKind::UnitSymbolKind_Joule,
            UnitSymbolKind::UnitSymbolKind_Newton,
            UnitSymbolKind::UnitSymbolKind_Hz,
            UnitSymbolKind::UnitSymbolKind_W,
            UnitSymbolKind::UnitSymbolKind_Pa,
            UnitSymbolKind::UnitSymbolKind_m2,
            UnitSymbolKind::UnitSymbolKind_Siemens,
            UnitSymbolKind::UnitSymbolKind_VA,
            UnitSymbolKind::UnitSymbolKind_VAr,
            UnitSymbolKind::UnitSymbolKind_wPerVA,
            UnitSymbolKind::UnitSymbolKind_VAh,
            UnitSymbolKind::UnitSymbolKind_Wh,
            UnitSymbolKind::UnitSymbolKind_VArh,
            UnitSymbolKind::UnitSymbolKind_hzPerS,
            UnitSymbolKind::UnitSymbolKind_wPerS,
            UnitSymbolKind::UnitSymbolKind_other,
            UnitSymbolKind::UnitSymbolKind_Ah,
            UnitSymbolKind::UnitSymbolKind_min,
            UnitSymbolKind::UnitSymbolKind_hour,
            UnitSymbolKind::UnitSymbolKind_m3,
            UnitSymbolKind::UnitSymbolKind_wPerM2,
            UnitSymbolKind::UnitSymbolKind_degF,
            UnitSymbolKind::UnitSymbolKind_mph,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UnitSymbolKind>("UnitSymbolKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UnitSymbolKind {
}

impl ::std::default::Default for UnitSymbolKind {
    fn default() -> Self {
        UnitSymbolKind::UnitSymbolKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitSymbolKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum UnitMultiplierKind {
    UnitMultiplierKind_none = 0,
    UnitMultiplierKind_other = 1,
    UnitMultiplierKind_centi = 2,
    UnitMultiplierKind_deci = 3,
    UnitMultiplierKind_Giga = 4,
    UnitMultiplierKind_kilo = 5,
    UnitMultiplierKind_Mega = 6,
    UnitMultiplierKind_micro = 7,
    UnitMultiplierKind_milli = 8,
    UnitMultiplierKind_nano = 9,
    UnitMultiplierKind_pico = 10,
    UnitMultiplierKind_Tera = 11,
}

impl ::protobuf::ProtobufEnum for UnitMultiplierKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UnitMultiplierKind> {
        match value {
            0 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_none),
            1 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_other),
            2 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_centi),
            3 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_deci),
            4 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_Giga),
            5 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_kilo),
            6 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_Mega),
            7 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_micro),
            8 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_milli),
            9 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_nano),
            10 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_pico),
            11 => ::std::option::Option::Some(UnitMultiplierKind::UnitMultiplierKind_Tera),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UnitMultiplierKind] = &[
            UnitMultiplierKind::UnitMultiplierKind_none,
            UnitMultiplierKind::UnitMultiplierKind_other,
            UnitMultiplierKind::UnitMultiplierKind_centi,
            UnitMultiplierKind::UnitMultiplierKind_deci,
            UnitMultiplierKind::UnitMultiplierKind_Giga,
            UnitMultiplierKind::UnitMultiplierKind_kilo,
            UnitMultiplierKind::UnitMultiplierKind_Mega,
            UnitMultiplierKind::UnitMultiplierKind_micro,
            UnitMultiplierKind::UnitMultiplierKind_milli,
            UnitMultiplierKind::UnitMultiplierKind_nano,
            UnitMultiplierKind::UnitMultiplierKind_pico,
            UnitMultiplierKind::UnitMultiplierKind_Tera,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UnitMultiplierKind>("UnitMultiplierKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UnitMultiplierKind {
}

impl ::std::default::Default for UnitMultiplierKind {
    fn default() -> Self {
        UnitMultiplierKind::UnitMultiplierKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitMultiplierKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum PhaseCodeKind {
    PhaseCodeKind_none = 0,
    PhaseCodeKind_other = 1,
    PhaseCodeKind_N = 16,
    PhaseCodeKind_C = 32,
    PhaseCodeKind_CN = 33,
    PhaseCodeKind_AC = 40,
    PhaseCodeKind_ACN = 41,
    PhaseCodeKind_B = 64,
    PhaseCodeKind_BN = 65,
    PhaseCodeKind_BC = 66,
    PhaseCodeKind_BCN = 97,
    PhaseCodeKind_A = 128,
    PhaseCodeKind_AN = 129,
    PhaseCodeKind_AB = 132,
    PhaseCodeKind_ABN = 193,
    PhaseCodeKind_ABC = 224,
    PhaseCodeKind_ABCN = 225,
    PhaseCodeKind_s2 = 256,
    PhaseCodeKind_s2N = 257,
    PhaseCodeKind_s1 = 512,
    PhaseCodeKind_s1N = 513,
    PhaseCodeKind_s12 = 768,
    PhaseCodeKind_s12N = 769,
}

impl ::protobuf::ProtobufEnum for PhaseCodeKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhaseCodeKind> {
        match value {
            0 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_none),
            1 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_other),
            16 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_N),
            32 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_C),
            33 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_CN),
            40 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_AC),
            41 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_ACN),
            64 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_B),
            65 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_BN),
            66 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_BC),
            97 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_BCN),
            128 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_A),
            129 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_AN),
            132 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_AB),
            193 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_ABN),
            224 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_ABC),
            225 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_ABCN),
            256 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s2),
            257 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s2N),
            512 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s1),
            513 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s1N),
            768 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s12),
            769 => ::std::option::Option::Some(PhaseCodeKind::PhaseCodeKind_s12N),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PhaseCodeKind] = &[
            PhaseCodeKind::PhaseCodeKind_none,
            PhaseCodeKind::PhaseCodeKind_other,
            PhaseCodeKind::PhaseCodeKind_N,
            PhaseCodeKind::PhaseCodeKind_C,
            PhaseCodeKind::PhaseCodeKind_CN,
            PhaseCodeKind::PhaseCodeKind_AC,
            PhaseCodeKind::PhaseCodeKind_ACN,
            PhaseCodeKind::PhaseCodeKind_B,
            PhaseCodeKind::PhaseCodeKind_BN,
            PhaseCodeKind::PhaseCodeKind_BC,
            PhaseCodeKind::PhaseCodeKind_BCN,
            PhaseCodeKind::PhaseCodeKind_A,
            PhaseCodeKind::PhaseCodeKind_AN,
            PhaseCodeKind::PhaseCodeKind_AB,
            PhaseCodeKind::PhaseCodeKind_ABN,
            PhaseCodeKind::PhaseCodeKind_ABC,
            PhaseCodeKind::PhaseCodeKind_ABCN,
            PhaseCodeKind::PhaseCodeKind_s2,
            PhaseCodeKind::PhaseCodeKind_s2N,
            PhaseCodeKind::PhaseCodeKind_s1,
            PhaseCodeKind::PhaseCodeKind_s1N,
            PhaseCodeKind::PhaseCodeKind_s12,
            PhaseCodeKind::PhaseCodeKind_s12N,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PhaseCodeKind>("PhaseCodeKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PhaseCodeKind {
}

impl ::std::default::Default for PhaseCodeKind {
    fn default() -> Self {
        PhaseCodeKind::PhaseCodeKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for PhaseCodeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ValidityKind {
    ValidityKind_good = 0,
    ValidityKind_invalid = 1,
    ValidityKind_reserved = 2,
    ValidityKind_questionable = 3,
}

impl ::protobuf::ProtobufEnum for ValidityKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValidityKind> {
        match value {
            0 => ::std::option::Option::Some(ValidityKind::ValidityKind_good),
            1 => ::std::option::Option::Some(ValidityKind::ValidityKind_invalid),
            2 => ::std::option::Option::Some(ValidityKind::ValidityKind_reserved),
            3 => ::std::option::Option::Some(ValidityKind::ValidityKind_questionable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ValidityKind] = &[
            ValidityKind::ValidityKind_good,
            ValidityKind::ValidityKind_invalid,
            ValidityKind::ValidityKind_reserved,
            ValidityKind::ValidityKind_questionable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ValidityKind>("ValidityKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ValidityKind {
}

impl ::std::default::Default for ValidityKind {
    fn default() -> Self {
        ValidityKind::ValidityKind_good
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidityKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SourceKind {
    SourceKind_process = 0,
    SourceKind_substituted = 1,
}

impl ::protobuf::ProtobufEnum for SourceKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SourceKind> {
        match value {
            0 => ::std::option::Option::Some(SourceKind::SourceKind_process),
            1 => ::std::option::Option::Some(SourceKind::SourceKind_substituted),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SourceKind] = &[
            SourceKind::SourceKind_process,
            SourceKind::SourceKind_substituted,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SourceKind>("SourceKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SourceKind {
}

impl ::std::default::Default for SourceKind {
    fn default() -> Self {
        SourceKind::SourceKind_process
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TimeAccuracyKind {
    TimeAccuracyKind_UNDEFINED = 0,
    TimeAccuracyKind_T0 = 7,
    TimeAccuracyKind_T1 = 10,
    TimeAccuracyKind_T2 = 14,
    TimeAccuracyKind_T3 = 16,
    TimeAccuracyKind_T4 = 18,
    TimeAccuracyKind_T5 = 20,
    TimeAccuracyKind_unspecified = 31,
}

impl ::protobuf::ProtobufEnum for TimeAccuracyKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TimeAccuracyKind> {
        match value {
            0 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_UNDEFINED),
            7 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T0),
            10 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T1),
            14 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T2),
            16 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T3),
            18 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T4),
            20 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_T5),
            31 => ::std::option::Option::Some(TimeAccuracyKind::TimeAccuracyKind_unspecified),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TimeAccuracyKind] = &[
            TimeAccuracyKind::TimeAccuracyKind_UNDEFINED,
            TimeAccuracyKind::TimeAccuracyKind_T0,
            TimeAccuracyKind::TimeAccuracyKind_T1,
            TimeAccuracyKind::TimeAccuracyKind_T2,
            TimeAccuracyKind::TimeAccuracyKind_T3,
            TimeAccuracyKind::TimeAccuracyKind_T4,
            TimeAccuracyKind::TimeAccuracyKind_T5,
            TimeAccuracyKind::TimeAccuracyKind_unspecified,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TimeAccuracyKind>("TimeAccuracyKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TimeAccuracyKind {
}

impl ::std::default::Default for TimeAccuracyKind {
    fn default() -> Self {
        TimeAccuracyKind::TimeAccuracyKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeAccuracyKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ScheduleParameterKind {
    ScheduleParameterKind_none = 0,
    ScheduleParameterKind_other = 1,
    ScheduleParameterKind_A_net_mag = 2,
    ScheduleParameterKind_A_neut_mag = 3,
    ScheduleParameterKind_A_phsA_mag = 4,
    ScheduleParameterKind_A_phsB_mag = 5,
    ScheduleParameterKind_A_phsC_mag = 6,
    ScheduleParameterKind_Hz_mag = 7,
    ScheduleParameterKind_PF_net_mag = 8,
    ScheduleParameterKind_PF_neut_mag = 9,
    ScheduleParameterKind_PF_phsA_mag = 10,
    ScheduleParameterKind_PF_phsB_mag = 11,
    ScheduleParameterKind_PF_phsC_mag = 12,
    ScheduleParameterKind_PhV_net_ang = 13,
    ScheduleParameterKind_PhV_net_mag = 14,
    ScheduleParameterKind_PhV_neut_ang = 15,
    ScheduleParameterKind_PhV_neut_mag = 16,
    ScheduleParameterKind_PhV_phsA_ang = 17,
    ScheduleParameterKind_PhV_phsA_mag = 18,
    ScheduleParameterKind_PhV_phsB_ang = 19,
    ScheduleParameterKind_PhV_phsB_mag = 20,
    ScheduleParameterKind_PhV_phsC_ang = 21,
    ScheduleParameterKind_PhV_phsC_mag = 22,
    ScheduleParameterKind_PPV_phsAB_ang = 23,
    ScheduleParameterKind_PPV_phsAB_mag = 24,
    ScheduleParameterKind_PPV_phsBC_ang = 25,
    ScheduleParameterKind_PPV_phsBC_mag = 26,
    ScheduleParameterKind_PPV_phsCA_ang = 27,
    ScheduleParameterKind_PPV_phsCA_mag = 28,
    ScheduleParameterKind_VA_net_mag = 29,
    ScheduleParameterKind_VA_neut_mag = 30,
    ScheduleParameterKind_VA_phsA_mag = 31,
    ScheduleParameterKind_VA_phsB_mag = 32,
    ScheduleParameterKind_VA_phsC_mag = 33,
    ScheduleParameterKind_VAr_net_mag = 34,
    ScheduleParameterKind_VAr_neut_mag = 35,
    ScheduleParameterKind_VAr_phsA_mag = 36,
    ScheduleParameterKind_VAr_phsB_mag = 37,
    ScheduleParameterKind_VAr_phsC_mag = 38,
    ScheduleParameterKind_W_net_mag = 39,
    ScheduleParameterKind_W_neut_mag = 40,
    ScheduleParameterKind_W_phsA_mag = 41,
    ScheduleParameterKind_W_phsB_mag = 42,
    ScheduleParameterKind_W_phsC_mag = 43,
}

impl ::protobuf::ProtobufEnum for ScheduleParameterKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScheduleParameterKind> {
        match value {
            0 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_none),
            1 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_other),
            2 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_A_net_mag),
            3 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_A_neut_mag),
            4 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_A_phsA_mag),
            5 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_A_phsB_mag),
            6 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_A_phsC_mag),
            7 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_Hz_mag),
            8 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PF_net_mag),
            9 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PF_neut_mag),
            10 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PF_phsA_mag),
            11 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PF_phsB_mag),
            12 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PF_phsC_mag),
            13 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_net_ang),
            14 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_net_mag),
            15 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_neut_ang),
            16 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_neut_mag),
            17 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsA_ang),
            18 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsA_mag),
            19 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsB_ang),
            20 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsB_mag),
            21 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsC_ang),
            22 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PhV_phsC_mag),
            23 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsAB_ang),
            24 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsAB_mag),
            25 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsBC_ang),
            26 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsBC_mag),
            27 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsCA_ang),
            28 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_PPV_phsCA_mag),
            29 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VA_net_mag),
            30 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VA_neut_mag),
            31 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VA_phsA_mag),
            32 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VA_phsB_mag),
            33 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VA_phsC_mag),
            34 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VAr_net_mag),
            35 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VAr_neut_mag),
            36 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VAr_phsA_mag),
            37 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VAr_phsB_mag),
            38 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_VAr_phsC_mag),
            39 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_W_net_mag),
            40 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_W_neut_mag),
            41 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_W_phsA_mag),
            42 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_W_phsB_mag),
            43 => ::std::option::Option::Some(ScheduleParameterKind::ScheduleParameterKind_W_phsC_mag),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ScheduleParameterKind] = &[
            ScheduleParameterKind::ScheduleParameterKind_none,
            ScheduleParameterKind::ScheduleParameterKind_other,
            ScheduleParameterKind::ScheduleParameterKind_A_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_A_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_A_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_A_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_A_phsC_mag,
            ScheduleParameterKind::ScheduleParameterKind_Hz_mag,
            ScheduleParameterKind::ScheduleParameterKind_PF_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_PF_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_PF_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_PF_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_PF_phsC_mag,
            ScheduleParameterKind::ScheduleParameterKind_PhV_net_ang,
            ScheduleParameterKind::ScheduleParameterKind_PhV_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_PhV_neut_ang,
            ScheduleParameterKind::ScheduleParameterKind_PhV_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsA_ang,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsB_ang,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsC_ang,
            ScheduleParameterKind::ScheduleParameterKind_PhV_phsC_mag,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsAB_ang,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsAB_mag,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsBC_ang,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsBC_mag,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsCA_ang,
            ScheduleParameterKind::ScheduleParameterKind_PPV_phsCA_mag,
            ScheduleParameterKind::ScheduleParameterKind_VA_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_VA_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_VA_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_VA_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_VA_phsC_mag,
            ScheduleParameterKind::ScheduleParameterKind_VAr_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_VAr_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_VAr_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_VAr_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_VAr_phsC_mag,
            ScheduleParameterKind::ScheduleParameterKind_W_net_mag,
            ScheduleParameterKind::ScheduleParameterKind_W_neut_mag,
            ScheduleParameterKind::ScheduleParameterKind_W_phsA_mag,
            ScheduleParameterKind::ScheduleParameterKind_W_phsB_mag,
            ScheduleParameterKind::ScheduleParameterKind_W_phsC_mag,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ScheduleParameterKind>("ScheduleParameterKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ScheduleParameterKind {
}

impl ::std::default::Default for ScheduleParameterKind {
    fn default() -> Self {
        ScheduleParameterKind::ScheduleParameterKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for ScheduleParameterKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CalcMethodKind {
    CalcMethodKind_UNDEFINED = 0,
    CalcMethodKind_P_CLASS = 11,
    CalcMethodKind_M_CLASS = 12,
    CalcMethodKind_DIFF = 13,
}

impl ::protobuf::ProtobufEnum for CalcMethodKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalcMethodKind> {
        match value {
            0 => ::std::option::Option::Some(CalcMethodKind::CalcMethodKind_UNDEFINED),
            11 => ::std::option::Option::Some(CalcMethodKind::CalcMethodKind_P_CLASS),
            12 => ::std::option::Option::Some(CalcMethodKind::CalcMethodKind_M_CLASS),
            13 => ::std::option::Option::Some(CalcMethodKind::CalcMethodKind_DIFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CalcMethodKind] = &[
            CalcMethodKind::CalcMethodKind_UNDEFINED,
            CalcMethodKind::CalcMethodKind_P_CLASS,
            CalcMethodKind::CalcMethodKind_M_CLASS,
            CalcMethodKind::CalcMethodKind_DIFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CalcMethodKind>("CalcMethodKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CalcMethodKind {
}

impl ::std::default::Default for CalcMethodKind {
    fn default() -> Self {
        CalcMethodKind::CalcMethodKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for CalcMethodKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum GridConnectModeKind {
    GridConnectModeKind_UNDEFINED = 0,
    GridConnectModeKind_CSI = 1,
    GridConnectModeKind_VC_VSI = 2,
    GridConnectModeKind_CC_VSI = 3,
    GridConnectModeKind_none = 98,
    GridConnectModeKind_other = 99,
    GridConnectModeKind_VSI_PQ = 2000,
    GridConnectModeKind_VSI_VF = 2001,
    GridConnectModeKind_VSI_ISO = 2002,
}

impl ::protobuf::ProtobufEnum for GridConnectModeKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GridConnectModeKind> {
        match value {
            0 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_UNDEFINED),
            1 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_CSI),
            2 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_VC_VSI),
            3 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_CC_VSI),
            98 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_none),
            99 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_other),
            2000 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_VSI_PQ),
            2001 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_VSI_VF),
            2002 => ::std::option::Option::Some(GridConnectModeKind::GridConnectModeKind_VSI_ISO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GridConnectModeKind] = &[
            GridConnectModeKind::GridConnectModeKind_UNDEFINED,
            GridConnectModeKind::GridConnectModeKind_CSI,
            GridConnectModeKind::GridConnectModeKind_VC_VSI,
            GridConnectModeKind::GridConnectModeKind_CC_VSI,
            GridConnectModeKind::GridConnectModeKind_none,
            GridConnectModeKind::GridConnectModeKind_other,
            GridConnectModeKind::GridConnectModeKind_VSI_PQ,
            GridConnectModeKind::GridConnectModeKind_VSI_VF,
            GridConnectModeKind::GridConnectModeKind_VSI_ISO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GridConnectModeKind>("GridConnectModeKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GridConnectModeKind {
}

impl ::std::default::Default for GridConnectModeKind {
    fn default() -> Self {
        GridConnectModeKind::GridConnectModeKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for GridConnectModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum PFSignKind {
    PFSignKind_UNDEFINED = 0,
    PFSignKind_IEC = 1,
    PFSignKind_EEI = 2,
}

impl ::protobuf::ProtobufEnum for PFSignKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PFSignKind> {
        match value {
            0 => ::std::option::Option::Some(PFSignKind::PFSignKind_UNDEFINED),
            1 => ::std::option::Option::Some(PFSignKind::PFSignKind_IEC),
            2 => ::std::option::Option::Some(PFSignKind::PFSignKind_EEI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PFSignKind] = &[
            PFSignKind::PFSignKind_UNDEFINED,
            PFSignKind::PFSignKind_IEC,
            PFSignKind::PFSignKind_EEI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PFSignKind>("PFSignKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PFSignKind {
}

impl ::std::default::Default for PFSignKind {
    fn default() -> Self {
        PFSignKind::PFSignKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for PFSignKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum BehaviourModeKind {
    BehaviourModeKind_UNDEFINED = 0,
    BehaviourModeKind_on = 1,
    BehaviourModeKind_blocked = 2,
    BehaviourModeKind_test = 3,
    BehaviourModeKind_test_blocked = 4,
    BehaviourModeKind_off = 5,
}

impl ::protobuf::ProtobufEnum for BehaviourModeKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BehaviourModeKind> {
        match value {
            0 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_UNDEFINED),
            1 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_on),
            2 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_blocked),
            3 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_test),
            4 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_test_blocked),
            5 => ::std::option::Option::Some(BehaviourModeKind::BehaviourModeKind_off),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BehaviourModeKind] = &[
            BehaviourModeKind::BehaviourModeKind_UNDEFINED,
            BehaviourModeKind::BehaviourModeKind_on,
            BehaviourModeKind::BehaviourModeKind_blocked,
            BehaviourModeKind::BehaviourModeKind_test,
            BehaviourModeKind::BehaviourModeKind_test_blocked,
            BehaviourModeKind::BehaviourModeKind_off,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BehaviourModeKind>("BehaviourModeKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BehaviourModeKind {
}

impl ::std::default::Default for BehaviourModeKind {
    fn default() -> Self {
        BehaviourModeKind::BehaviourModeKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for BehaviourModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum DERGeneratorStateKind {
    DERGeneratorStateKind_UNDEFINED = 0,
    DERGeneratorStateKind_Not_operating = 1,
    DERGeneratorStateKind_Operating = 2,
    DERGeneratorStateKind_Starting_up = 3,
    DERGeneratorStateKind_Shutting_down = 4,
    DERGeneratorStateKind_At_disconnect_level = 5,
    DERGeneratorStateKind_Ramping_in_power = 6,
    DERGeneratorStateKind_Ramping_in_reactive_power = 7,
    DERGeneratorStateKind_Standby = 8,
    DERGeneratorStateKind_Not_applicable_Unknown = 98,
    DERGeneratorStateKind_Other = 99,
}

impl ::protobuf::ProtobufEnum for DERGeneratorStateKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DERGeneratorStateKind> {
        match value {
            0 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED),
            1 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Not_operating),
            2 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Operating),
            3 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Starting_up),
            4 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Shutting_down),
            5 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_At_disconnect_level),
            6 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Ramping_in_power),
            7 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Ramping_in_reactive_power),
            8 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Standby),
            98 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Not_applicable_Unknown),
            99 => ::std::option::Option::Some(DERGeneratorStateKind::DERGeneratorStateKind_Other),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DERGeneratorStateKind] = &[
            DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED,
            DERGeneratorStateKind::DERGeneratorStateKind_Not_operating,
            DERGeneratorStateKind::DERGeneratorStateKind_Operating,
            DERGeneratorStateKind::DERGeneratorStateKind_Starting_up,
            DERGeneratorStateKind::DERGeneratorStateKind_Shutting_down,
            DERGeneratorStateKind::DERGeneratorStateKind_At_disconnect_level,
            DERGeneratorStateKind::DERGeneratorStateKind_Ramping_in_power,
            DERGeneratorStateKind::DERGeneratorStateKind_Ramping_in_reactive_power,
            DERGeneratorStateKind::DERGeneratorStateKind_Standby,
            DERGeneratorStateKind::DERGeneratorStateKind_Not_applicable_Unknown,
            DERGeneratorStateKind::DERGeneratorStateKind_Other,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DERGeneratorStateKind>("DERGeneratorStateKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DERGeneratorStateKind {
}

impl ::std::default::Default for DERGeneratorStateKind {
    fn default() -> Self {
        DERGeneratorStateKind::DERGeneratorStateKind_UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for DERGeneratorStateKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum DynamicTestKind {
    DynamicTestKind_none = 0,
    DynamicTestKind_testing = 1,
    DynamicTestKind_operating = 2,
    DynamicTestKind_failed = 3,
}

impl ::protobuf::ProtobufEnum for DynamicTestKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DynamicTestKind> {
        match value {
            0 => ::std::option::Option::Some(DynamicTestKind::DynamicTestKind_none),
            1 => ::std::option::Option::Some(DynamicTestKind::DynamicTestKind_testing),
            2 => ::std::option::Option::Some(DynamicTestKind::DynamicTestKind_operating),
            3 => ::std::option::Option::Some(DynamicTestKind::DynamicTestKind_failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DynamicTestKind] = &[
            DynamicTestKind::DynamicTestKind_none,
            DynamicTestKind::DynamicTestKind_testing,
            DynamicTestKind::DynamicTestKind_operating,
            DynamicTestKind::DynamicTestKind_failed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DynamicTestKind>("DynamicTestKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DynamicTestKind {
}

impl ::std::default::Default for DynamicTestKind {
    fn default() -> Self {
        DynamicTestKind::DynamicTestKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicTestKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum HealthKind {
    HealthKind_none = 0,
    HealthKind_OK = 1,
    HealthKind_Warning = 2,
    HealthKind_Alarm = 3,
}

impl ::protobuf::ProtobufEnum for HealthKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HealthKind> {
        match value {
            0 => ::std::option::Option::Some(HealthKind::HealthKind_none),
            1 => ::std::option::Option::Some(HealthKind::HealthKind_OK),
            2 => ::std::option::Option::Some(HealthKind::HealthKind_Warning),
            3 => ::std::option::Option::Some(HealthKind::HealthKind_Alarm),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HealthKind] = &[
            HealthKind::HealthKind_none,
            HealthKind::HealthKind_OK,
            HealthKind::HealthKind_Warning,
            HealthKind::HealthKind_Alarm,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HealthKind>("HealthKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HealthKind {
}

impl ::std::default::Default for HealthKind {
    fn default() -> Self {
        HealthKind::HealthKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum DbPosKind {
    DbPosKind_transient = 0,
    DbPosKind_closed = 1,
    DbPosKind_open = 2,
    DbPosKind_invalid = 3,
}

impl ::protobuf::ProtobufEnum for DbPosKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DbPosKind> {
        match value {
            0 => ::std::option::Option::Some(DbPosKind::DbPosKind_transient),
            1 => ::std::option::Option::Some(DbPosKind::DbPosKind_closed),
            2 => ::std::option::Option::Some(DbPosKind::DbPosKind_open),
            3 => ::std::option::Option::Some(DbPosKind::DbPosKind_invalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DbPosKind] = &[
            DbPosKind::DbPosKind_transient,
            DbPosKind::DbPosKind_closed,
            DbPosKind::DbPosKind_open,
            DbPosKind::DbPosKind_invalid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DbPosKind>("DbPosKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DbPosKind {
}

impl ::std::default::Default for DbPosKind {
    fn default() -> Self {
        DbPosKind::DbPosKind_transient
    }
}

impl ::protobuf::reflect::ProtobufValue for DbPosKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum StateKind {
    StateKind_off = 0,
    StateKind_on = 1,
    StateKind_standby = 2,
}

impl ::protobuf::ProtobufEnum for StateKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StateKind> {
        match value {
            0 => ::std::option::Option::Some(StateKind::StateKind_off),
            1 => ::std::option::Option::Some(StateKind::StateKind_on),
            2 => ::std::option::Option::Some(StateKind::StateKind_standby),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StateKind] = &[
            StateKind::StateKind_off,
            StateKind::StateKind_on,
            StateKind::StateKind_standby,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StateKind>("StateKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StateKind {
}

impl ::std::default::Default for StateKind {
    fn default() -> Self {
        StateKind::StateKind_off
    }
}

impl ::protobuf::reflect::ProtobufValue for StateKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fcommonmodule/commonmodule.proto\x12\x0ccommonmodule\"\xc2\x01\n\
    \x10IdentifiedObject\x12@\n\x0bdescription\x18\x01\x20\x01(\x0b2\x1c.goo\
    gle.protobuf.StringValueR\x0bdescriptionB\0\x126\n\x04mRID\x18\x02\x20\
    \x01(\x0b2\x1c.google.protobuf.StringValueR\x04mRIDB\x04\xa0\xb5\x18\x01\
    \x122\n\x04name\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\
    \x04nameB\0:\0\"\xe5\x01\n\x0cACDCTerminal\x12P\n\x10identifiedObject\
    \x18\x01\x20\x01(\x0b2\x1e.commonmodule.IdentifiedObjectR\x10identifiedO\
    bjectB\x04\x80\xb5\x18\x01\x12:\n\tconnected\x18\x02\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.BoolValueR\tconnectedB\0\x12E\n\x0esequenceNumber\x18\x03\
    \x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x0esequenceNumberB\0:\0\"\
    Q\n\x17Optional_UnitSymbolKind\x124\n\x05value\x18\x01\x20\x01(\x0e2\x1c\
    .commonmodule.UnitSymbolKindR\x05valueB\0:\0\"Y\n\x1bOptional_UnitMultip\
    lierKind\x128\n\x05value\x18\x01\x20\x01(\x0e2\x20.commonmodule.UnitMult\
    iplierKindR\x05valueB\0:\0\"\xce\x01\n\x0bActivePower\x12K\n\nmultiplier\
    \x18\x01\x20\x01(\x0b2).commonmodule.Optional_UnitMultiplierKindR\nmulti\
    plierB\0\x12;\n\x04unit\x18\x02\x20\x01(\x0b2%.commonmodule.Optional_Uni\
    tSymbolKindR\x04unitB\0\x123\n\x05value\x18\x03\x20\x01(\x0b2\x1b.google\
    .protobuf.FloatValueR\x05valueB\0:\0\"O\n\x16Optional_PhaseCodeKind\x123\
    \n\x05value\x18\x01\x20\x01(\x0e2\x1b.commonmodule.PhaseCodeKindR\x05val\
    ueB\0:\0\"k\n\rAnalogueValue\x12+\n\x01f\x18\x01\x20\x01(\x0b2\x1b.googl\
    e.protobuf.FloatValueR\x01fB\0\x12+\n\x01i\x18\x02\x20\x01(\x0b2\x1b.goo\
    gle.protobuf.Int32ValueR\x01iB\0:\0\"M\n\x15Optional_ValidityKind\x122\n\
    \x05value\x18\x01\x20\x01(\x0e2\x1a.commonmodule.ValidityKindR\x05valueB\
    \0:\0\"\xd8\x02\n\nDetailQual\x12,\n\x0cbadReference\x18\x01\x20\x01(\
    \x08R\x0cbadReferenceB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12\"\n\x07fa\
    ilure\x18\x02\x20\x01(\x08R\x07failureB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12(\n\ninaccurate\x18\x03\x20\x01(\x08R\ninaccurateB\x08\x90\xb5\
    \x18\x01\x88\xb5\x18\x01\x12,\n\x0cinconsistent\x18\x04\x20\x01(\x08R\
    \x0cinconsistentB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12\"\n\x07oldData\
    \x18\x05\x20\x01(\x08R\x07oldDataB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    \x12*\n\x0boscillatory\x18\x06\x20\x01(\x08R\x0boscillatoryB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01\x12(\n\noutOfRange\x18\x07\x20\x01(\x08R\noutOf\
    RangeB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12$\n\x08overflow\x18\x08\
    \x20\x01(\x08R\x08overflowB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\0\"I\n\
    \x13Optional_SourceKind\x120\n\x05value\x18\x01\x20\x01(\x0e2\x18.common\
    module.SourceKindR\x05valueB\0:\0\"\x9f\x02\n\x07Quality\x12B\n\ndetailQ\
    ual\x18\x01\x20\x01(\x0b2\x18.commonmodule.DetailQualR\ndetailQualB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x122\n\x0foperatorBlocked\x18\x02\x20\
    \x01(\x08R\x0foperatorBlockedB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12:\
    \n\x06source\x18\x03\x20\x01(\x0e2\x18.commonmodule.SourceKindR\x06sourc\
    eB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12\x1c\n\x04test\x18\x04\x20\x01\
    (\x08R\x04testB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12@\n\x08validity\
    \x18\x05\x20\x01(\x0e2\x1a.commonmodule.ValidityKindR\x08validityB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"U\n\x19Optional_TimeAccuracyKind\
    \x126\n\x05value\x18\x01\x20\x01(\x0e2\x1e.commonmodule.TimeAccuracyKind\
    R\x05valueB\0:\0\"\xff\x01\n\x0bTimeQuality\x12,\n\x0cclockFailure\x18\
    \x01\x20\x01(\x08R\x0cclockFailureB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    \x12<\n\x14clockNotSynchronized\x18\x02\x20\x01(\x08R\x14clockNotSynchro\
    nizedB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x124\n\x10leapSecondsKnown\
    \x18\x03\x20\x01(\x08R\x10leapSecondsKnownB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01\x12L\n\x0ctimeAccuracy\x18\x04\x20\x01(\x0e2\x1e.commonmodule.T\
    imeAccuracyKindR\x0ctimeAccuracyB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\
    \"\x84\x01\n\tTimestamp\x12$\n\x08fraction\x18\x01\x20\x01(\rR\x08fracti\
    onB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12\"\n\x07seconds\x18\x02\x20\
    \x01(\x04R\x07secondsB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12+\n\x02tq\
    \x18\x03\x20\x01(\x0b2\x19.commonmodule.TimeQualityR\x02tqB\0:\0\"\x95\
    \x01\n\x04Unit\x12K\n\nmultiplier\x18\x01\x20\x01(\x0b2).commonmodule.Op\
    tional_UnitMultiplierKindR\nmultiplierB\0\x12>\n\x06SIUnit\x18\x02\x20\
    \x01(\x0e2\x1c.commonmodule.UnitSymbolKindR\x06SIUnitB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01:\0\"\xcb\x01\n\x02MV\x127\n\x03mag\x18\x01\x20\x01(\
    \x0b2\x1b.commonmodule.AnalogueValueR\x03magB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01\x12-\n\x01q\x18\x02\x20\x01(\x0b2\x15.commonmodule.QualityR\
    \x01qB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12/\n\x01t\x18\x03\x20\x01(\
    \x0b2\x17.commonmodule.TimestampR\x01tB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12*\n\x05units\x18\x04\x20\x01(\x0b2\x12.commonmodule.UnitR\x05uni\
    tsB\0:\0\"a\n\x0bLogicalNode\x12P\n\x10identifiedObject\x18\x01\x20\x01(\
    \x0b2\x1e.commonmodule.IdentifiedObjectR\x10identifiedObjectB\x04\x80\
    \xb5\x18\x01:\0\"\xc5\x01\n\x10AnalogStatusGGIO\x12A\n\x0blogicalNode\
    \x18\x01\x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0blogicalNodeB\x04\
    \x80\xb5\x18\x01\x12.\n\x04AnIn\x18\x02\x20\x01(\x0b2\x10.commonmodule.M\
    VR\x04AnInB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12<\n\x05Phase\x18\x03\
    \x20\x01(\x0b2$.commonmodule.Optional_PhaseCodeKindR\x05PhaseB\0:\0\"n\n\
    \x10AnalogueValueCtl\x12+\n\x01f\x18\x01\x20\x01(\x0b2\x1b.google.protob\
    uf.FloatValueR\x01fB\0\x12+\n\x01i\x18\x02\x20\x01(\x0b2\x1b.google.prot\
    obuf.Int32ValueR\x01iB\0:\0\"\x85\x01\n\x0bNamedObject\x12@\n\x0bdescrip\
    tion\x18\x01\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\x0bdescripti\
    onB\0\x122\n\x04name\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.StringVal\
    ueR\x04nameB\0:\0\"z\n\x11ApplicationSystem\x12A\n\x0bnamedObject\x18\
    \x01\x20\x01(\x0b2\x19.commonmodule.NamedObjectR\x0bnamedObjectB\x04\x80\
    \xb5\x18\x01\x12\x20\n\x04mRID\x18\x02\x20\x01(\tR\x04mRIDB\x0c\x88\xb5\
    \x18\x01\xa0\xb5\x18\x01\x90\xb5\x18\x01:\0\"u\n\x03ASG\x12@\n\x06setMag\
    \x18\x01\x20\x01(\x0b2\x1e.commonmodule.AnalogueValueCtlR\x06setMagB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x12*\n\x05units\x18\x02\x20\x01(\x0b2\
    \x12.commonmodule.UnitR\x05unitsB\0:\0\"\xc8\x01\n\x03BCR\x12\x20\n\x06a\
    ctVal\x18\x01\x20\x01(\x03R\x06actValB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12-\n\x01q\x18\x02\x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\
    \x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12/\n\x01t\x18\x03\x20\x01(\x0b2\
    \x17.commonmodule.TimestampR\x01tB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    \x12=\n\x05units\x18\x04\x20\x01(\x0b2%.commonmodule.Optional_UnitSymbol\
    KindR\x05unitsB\0:\0\"}\n\tStatusSPS\x12%\n\x01q\x18\x01\x20\x01(\x0b2\
    \x15.commonmodule.QualityR\x01qB\0\x12\x1e\n\x05stVal\x18\x02\x20\x01(\
    \x08R\x05stValB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12'\n\x01t\x18\x03\
    \x20\x01(\x0b2\x17.commonmodule.TimestampR\x01tB\0:\0\"\xcb\x01\n\x11Boo\
    leanStatusGGIO\x12A\n\x0blogicalNode\x18\x01\x20\x01(\x0b2\x19.commonmod\
    ule.LogicalNodeR\x0blogicalNodeB\x04\x80\xb5\x18\x01\x123\n\x03Ind\x18\
    \x02\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x03IndB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01\x12<\n\x05Phase\x18\x03\x20\x01(\x0b2$.commonmodule\
    .Optional_PhaseCodeKindR\x05PhaseB\0:\0\"\x9b\x01\n\x0fCheckConditions\
    \x12D\n\x0einterlockCheck\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Bool\
    ValueR\x0einterlockCheckB\0\x12@\n\x0csynchroCheck\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x0csynchroCheckB\0:\0\"t\n\x06Vector\x12\
    /\n\x03ang\x18\x01\x20\x01(\x0b2\x1b.commonmodule.AnalogueValueR\x03angB\
    \0\x127\n\x03mag\x18\x02\x20\x01(\x0b2\x1b.commonmodule.AnalogueValueR\
    \x03magB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\0\"\xc7\x01\n\x03CMV\x122\
    \n\x04cVal\x18\x01\x20\x01(\x0b2\x14.commonmodule.VectorR\x04cValB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x01q\x18\x02\x20\x01(\x0b2\x15.c\
    ommonmodule.QualityR\x01qB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12/\n\
    \x01t\x18\x03\x20\x01(\x0b2\x17.commonmodule.TimestampR\x01tB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01\x12*\n\x05units\x18\x04\x20\x01(\x0b2\x12.c\
    ommonmodule.UnitR\x05unitsB\0:\0\"\x80\x01\n\x13ConductingEquipment\x12A\
    \n\x0bnamedObject\x18\x01\x20\x01(\x0b2\x19.commonmodule.NamedObjectR\
    \x0bnamedObjectB\x04\x80\xb5\x18\x01\x12$\n\x04mRID\x18\x02\x20\x01(\tR\
    \x04mRIDB\x10\x88\xb5\x18\x01\xa8\xb5\x18\x01\x90\xb5\x18\x01\xa0\xb5\
    \x18\x01:\0\"\x92\x01\n\x08Terminal\x12D\n\x0caCDCTerminal\x18\x01\x20\
    \x01(\x0b2\x1a.commonmodule.ACDCTerminalR\x0caCDCTerminalB\x04\x80\xb5\
    \x18\x01\x12>\n\x06phases\x18\x02\x20\x01(\x0b2$.commonmodule.Optional_P\
    haseCodeKindR\x06phasesB\0:\0\"d\n\"ConductingEquipmentTerminalReading\
    \x12<\n\x08terminal\x18\x01\x20\x01(\x0b2\x16.commonmodule.TerminalR\x08\
    terminalB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\0\"0\n\nControlDPC\x12\
    \x20\n\x06ctlVal\x18\x01\x20\x01(\x08R\x06ctlValB\x08\x90\xb5\x18\x01\
    \x88\xb5\x18\x01:\0\"^\n\x10ControlTimestamp\x12$\n\x08fraction\x18\x01\
    \x20\x01(\rR\x08fractionB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12\"\n\
    \x07seconds\x18\x02\x20\x01(\x04R\x07secondsB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01:\0\"_\n\x1eOptional_ScheduleParameterKind\x12;\n\x05value\
    \x18\x01\x20\x01(\x0e2#.commonmodule.ScheduleParameterKindR\x05valueB\0:\
    \0\"\x9e\x01\n\x15ENG_ScheduleParameter\x12c\n\x15scheduleParameterType\
    \x18\x01\x20\x01(\x0e2#.commonmodule.ScheduleParameterKindR\x15scheduleP\
    arameterTypeB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12\x1e\n\x05value\x18\
    \x02\x20\x01(\x02R\x05valueB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\
    \xb6\x01\n\rSchedulePoint\x12[\n\x11scheduleParameter\x18\x01\x20\x03(\
    \x0b2#.commonmodule.ENG_ScheduleParameterR\x11scheduleParameterB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01\x12F\n\tstartTime\x18\x02\x20\x01(\x0b2\x1e\
    .commonmodule.ControlTimestampR\tstartTimeB\x08\x88\xb5\x18\x01\x90\xb5\
    \x18\x01:\0\"N\n\x0bScheduleCSG\x12=\n\x06schPts\x18\x01\x20\x03(\x0b2\
    \x1b.commonmodule.SchedulePointR\x06schPtsB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01:\0\"V\n\x13ControlScheduleFSCH\x12=\n\x07ValACSG\x18\x01\x20\
    \x01(\x0b2\x19.commonmodule.ScheduleCSGR\x07ValACSGB\x08\x88\xb5\x18\x01\
    \x90\xb5\x18\x01:\0\"\\\n\x15LogicalNodeForControl\x12A\n\x0blogicalNode\
    \x18\x01\x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0blogicalNodeB\x04\
    \x80\xb5\x18\x01:\0\"\xaa\x02\n\x0bControlFSCC\x12_\n\x15logicalNodeForC\
    ontrol\x18\x01\x20\x01(\x0b2#.commonmodule.LogicalNodeForControlR\x15log\
    icalNodeForControlB\x04\x80\xb5\x18\x01\x12U\n\x13controlScheduleFSCH\
    \x18\x02\x20\x01(\x0b2!.commonmodule.ControlScheduleFSCHR\x13controlSche\
    duleFSCHB\0\x12a\n\x19islandControlScheduleFSCH\x18\x03\x20\x01(\x0b2!.c\
    ommonmodule.ControlScheduleFSCHR\x19islandControlScheduleFSCHB\0:\0\"\\\
    \n\nControlING\x12\x20\n\x06setVal\x18\x01\x20\x01(\x05R\x06setValB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x12*\n\x05units\x18\x02\x20\x01(\x0b2\
    \x12.commonmodule.UnitR\x05unitsB\0:\0\"0\n\nControlISC\x12\x20\n\x06ctl\
    Val\x18\x01\x20\x01(\x05R\x06ctlValB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    :\0\"\xb0\x01\n\x0bMessageInfo\x12P\n\x10identifiedObject\x18\x01\x20\
    \x01(\x0b2\x1e.commonmodule.IdentifiedObjectR\x10identifiedObjectB\x04\
    \x80\xb5\x18\x01\x12M\n\x10messageTimeStamp\x18\x02\x20\x01(\x0b2\x17.co\
    mmonmodule.TimestampR\x10messageTimeStampB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01:\0\"Y\n\x12ControlMessageInfo\x12A\n\x0bmessageInfo\x18\x01\x20\
    \x01(\x0b2\x19.commonmodule.MessageInfoR\x0bmessageInfoB\x04\x80\xb5\x18\
    \x01:\0\"0\n\nControlSPC\x12\x20\n\x06ctlVal\x18\x01\x20\x01(\x08R\x06ct\
    lValB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\x98\x01\n\x0cControlValue\
    \x12P\n\x10identifiedObject\x18\x01\x20\x01(\x0b2\x1e.commonmodule.Ident\
    ifiedObjectR\x10identifiedObjectB\x04\x80\xb5\x18\x01\x124\n\x06modBlk\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x06modBlkB\0:\0\"z\
    \n\x10DateTimeInterval\x12/\n\x03end\x18\x01\x20\x01(\x0b2\x1b.google.pr\
    otobuf.Int64ValueR\x03endB\0\x123\n\x05start\x18\x02\x20\x01(\x0b2\x1b.g\
    oogle.protobuf.Int64ValueR\x05startB\0:\0\"\x88\x01\n\x03DEL\x12)\n\x05p\
    hsAB\x18\x01\x20\x01(\x0b2\x11.commonmodule.CMVR\x05phsABB\0\x12)\n\x05p\
    hsBC\x18\x02\x20\x01(\x0b2\x11.commonmodule.CMVR\x05phsBCB\0\x12)\n\x05p\
    hsCA\x18\x03\x20\x01(\x0b2\x11.commonmodule.CMVR\x05phsCAB\0:\0\"\xb5\
    \x01\n\x0eEnergyConsumer\x12Y\n\x13conductingEquipment\x18\x01\x20\x01(\
    \x0b2!.commonmodule.ConductingEquipmentR\x13conductingEquipmentB\x04\x80\
    \xb5\x18\x01\x12F\n\x0eoperatingLimit\x18\x02\x20\x01(\x0b2\x1c.google.p\
    rotobuf.StringValueR\x0eoperatingLimitB\0:\0\"Q\n\x17Optional_CalcMethod\
    Kind\x124\n\x05value\x18\x01\x20\x01(\x0e2\x1c.commonmodule.CalcMethodKi\
    ndR\x05valueB\0:\0\"V\n\x12ENG_CalcMethodKind\x12>\n\x06setVal\x18\x01\
    \x20\x01(\x0e2\x1c.commonmodule.CalcMethodKindR\x06setValB\x08\x90\xb5\
    \x18\x01\x88\xb5\x18\x01:\0\"[\n\x1cOptional_GridConnectModeKind\x129\n\
    \x05value\x18\x01\x20\x01(\x0e2!.commonmodule.GridConnectModeKindR\x05va\
    lueB\0:\0\"\xaa\x01\n\x17ENG_GridConnectModeKind\x12C\n\x06setVal\x18\
    \x01\x20\x01(\x0e2!.commonmodule.GridConnectModeKindR\x06setValB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01\x12H\n\x0fsetValExtension\x18\x02\x20\x01(\
    \x0b2\x1c.google.protobuf.StringValueR\x0fsetValExtensionB\0:\0\"I\n\x13\
    Optional_PFSignKind\x120\n\x05value\x18\x01\x20\x01(\x0e2\x18.commonmodu\
    le.PFSignKindR\x05valueB\0:\0\"N\n\x0eENG_PFSignKind\x12:\n\x06setVal\
    \x18\x01\x20\x01(\x0e2\x18.commonmodule.PFSignKindR\x06setValB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01:\0\"W\n\x1aOptional_BehaviourModeKind\x127\
    \n\x05value\x18\x01\x20\x01(\x0e2\x1f.commonmodule.BehaviourModeKindR\
    \x05valueB\0:\0\"\xba\x01\n\x15ENS_BehaviourModeKind\x12-\n\x01q\x18\x01\
    \x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01\x12?\n\x05stVal\x18\x02\x20\x01(\x0e2\x1f.commonmodule.Beha\
    viourModeKindR\x05stValB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12/\n\x01t\
    \x18\x03\x20\x01(\x0b2\x17.commonmodule.TimestampR\x01tB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01:\0\"_\n\x1eOptional_DERGeneratorStateKind\x12;\n\
    \x05value\x18\x01\x20\x01(\x0e2#.commonmodule.DERGeneratorStateKindR\x05\
    valueB\0:\0\"\xc2\x01\n\x19ENS_DERGeneratorStateKind\x12-\n\x01q\x18\x01\
    \x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01\x12C\n\x05stVal\x18\x02\x20\x01(\x0e2#.commonmodule.DERGene\
    ratorStateKindR\x05stValB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12/\n\x01\
    t\x18\x03\x20\x01(\x0b2\x17.commonmodule.TimestampR\x01tB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"S\n\x18Optional_DynamicTestKind\x125\n\x05v\
    alue\x18\x01\x20\x01(\x0e2\x1d.commonmodule.DynamicTestKindR\x05valueB\0\
    :\0\"\xb6\x01\n\x13ENS_DynamicTestKind\x12-\n\x01q\x18\x01\x20\x01(\x0b2\
    \x15.commonmodule.QualityR\x01qB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12\
    =\n\x05stVal\x18\x02\x20\x01(\x0e2\x1d.commonmodule.DynamicTestKindR\x05\
    stValB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12/\n\x01t\x18\x03\x20\x01(\
    \x0b2\x17.commonmodule.TimestampR\x01tB\x08\x90\xb5\x18\x01\x88\xb5\x18\
    \x01:\0\"\x90\x01\n\x17ENS_GridConnectModeKind\x12A\n\x05stVal\x18\x01\
    \x20\x01(\x0e2!.commonmodule.GridConnectModeKindR\x05stValB\x08\x90\xb5\
    \x18\x01\x88\xb5\x18\x01\x120\n\x0estValExtension\x18\x02\x20\x01(\tR\
    \x0estValExtensionB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"I\n\x13Optio\
    nal_HealthKind\x120\n\x05value\x18\x01\x20\x01(\x0e2\x18.commonmodule.He\
    althKindR\x05valueB\0:\0\"z\n\x0eENS_HealthKind\x12,\n\x01d\x18\x01\x20\
    \x01(\x0b2\x1c.google.protobuf.StringValueR\x01dB\0\x128\n\x05stVal\x18\
    \x02\x20\x01(\x0e2\x18.commonmodule.HealthKindR\x05stValB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"b\n\x03ESS\x12Y\n\x13conductingEquipment\
    \x18\x01\x20\x01(\x0b2!.commonmodule.ConductingEquipmentR\x13conductingE\
    quipmentB\x04\x80\xb5\x18\x01:\0\"W\n\x10EventMessageInfo\x12A\n\x0bmess\
    ageInfo\x18\x01\x20\x01(\x0b2\x19.commonmodule.MessageInfoR\x0bmessageIn\
    foB\x04\x80\xb5\x18\x01:\0\"`\n\nEventValue\x12P\n\x10identifiedObject\
    \x18\x01\x20\x01(\x0b2\x1e.commonmodule.IdentifiedObjectR\x10identifiedO\
    bjectB\x04\x80\xb5\x18\x01:\0\"i\n\x13ForecastValueSource\x12P\n\x10iden\
    tifiedObject\x18\x01\x20\x01(\x0b2\x1e.commonmodule.IdentifiedObjectR\
    \x10identifiedObjectB\x04\x80\xb5\x18\x01:\0\"\xd8\x01\n\x0bForecastIED\
    \x12Y\n\x13forecastValueSource\x18\x01\x20\x01(\x0b2!.commonmodule.Forec\
    astValueSourceR\x13forecastValueSourceB\x04\x80\xb5\x18\x01\x12:\n\x13so\
    urceApplicationID\x18\x02\x20\x01(\tR\x13sourceApplicationIDB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01\x120\n\x0esourceDateTime\x18\x03\x20\x01(\
    \x03R\x0esourceDateTimeB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"c\n\rFo\
    recastValue\x12P\n\x10identifiedObject\x18\x01\x20\x01(\x0b2\x1e.commonm\
    odule.IdentifiedObjectR\x10identifiedObjectB\x04\x80\xb5\x18\x01:\0\"Y\n\
    \x03IED\x12P\n\x10identifiedObject\x18\x01\x20\x01(\x0b2\x1e.commonmodul\
    e.IdentifiedObjectR\x10identifiedObjectB\x04\x80\xb5\x18\x01:\0\"\xa9\
    \x01\n\tStatusINS\x12%\n\x01q\x18\x01\x20\x01(\x0b2\x15.commonmodule.Qua\
    lityR\x01qB\0\x12\x1e\n\x05stVal\x18\x02\x20\x01(\x05R\x05stValB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01\x12'\n\x01t\x18\x03\x20\x01(\x0b2\x17.commo\
    nmodule.TimestampR\x01tB\0\x12*\n\x05units\x18\x04\x20\x01(\x0b2\x12.com\
    monmodule.UnitR\x05unitsB\0:\0\"\xcf\x01\n\x11IntegerStatusGGIO\x12A\n\
    \x0blogicalNode\x18\x01\x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0bl\
    ogicalNodeB\x04\x80\xb5\x18\x01\x127\n\x05IntIn\x18\x02\x20\x01(\x0b2\
    \x17.commonmodule.StatusINSR\x05IntInB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12<\n\x05Phase\x18\x03\x20\x01(\x0b2$.commonmodule.Optional_PhaseC\
    odeKindR\x05PhaseB\0:\0\"\xd8\x01\n\x1cLogicalNodeForEventAndStatus\x12A\
    \n\x0blogicalNode\x18\x01\x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\
    \x0blogicalNodeB\x04\x80\xb5\x18\x01\x127\n\x03Beh\x18\x02\x20\x01(\x0b2\
    #.commonmodule.ENS_BehaviourModeKindR\x03BehB\0\x12:\n\x08EEHealth\x18\
    \x03\x20\x01(\x0b2\x1c.commonmodule.ENS_HealthKindR\x08EEHealthB\0:\0\"f\
    \n\x10MeasurementValue\x12P\n\x10identifiedObject\x18\x01\x20\x01(\x0b2\
    \x1e.commonmodule.IdentifiedObjectR\x10identifiedObjectB\x04\x80\xb5\x18\
    \x01:\0\"d\n\x05Meter\x12Y\n\x13conductingEquipment\x18\x01\x20\x01(\x0b\
    2!.commonmodule.ConductingEquipmentR\x13conductingEquipmentB\x04\x80\xb5\
    \x18\x01:\0\"^\n\x17OptimizationMessageInfo\x12A\n\x0bmessageInfo\x18\
    \x01\x20\x01(\x0b2\x19.commonmodule.MessageInfoR\x0bmessageInfoB\x04\x80\
    \xb5\x18\x01:\0\"\xe7\x03\n\x0bReadingMMTN\x12A\n\x0blogicalNode\x18\x01\
    \x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0blogicalNodeB\x04\x80\xb5\
    \x18\x01\x12+\n\x06DmdVAh\x18\x02\x20\x01(\x0b2\x11.commonmodule.BCRR\
    \x06DmdVAhB\0\x12-\n\x07DmdVArh\x18\x03\x20\x01(\x0b2\x11.commonmodule.B\
    CRR\x07DmdVArhB\0\x12)\n\x05DmdWh\x18\x04\x20\x01(\x0b2\x11.commonmodule\
    .BCRR\x05DmdWhB\0\x12+\n\x06SupVAh\x18\x05\x20\x01(\x0b2\x11.commonmodul\
    e.BCRR\x06SupVAhB\0\x12-\n\x07SupVArh\x18\x06\x20\x01(\x0b2\x11.commonmo\
    dule.BCRR\x07SupVArhB\0\x12)\n\x05SupWh\x18\x07\x20\x01(\x0b2\x11.common\
    module.BCRR\x05SupWhB\0\x12+\n\x06TotVAh\x18\x08\x20\x01(\x0b2\x11.commo\
    nmodule.BCRR\x06TotVAhB\0\x12-\n\x07TotVArh\x18\t\x20\x01(\x0b2\x11.comm\
    onmodule.BCRR\x07TotVArhB\0\x12)\n\x05TotWh\x18\n\x20\x01(\x0b2\x11.comm\
    onmodule.BCRR\x05TotWhB\0:\0\"\xb9\x02\n\tPhaseMMTN\x12/\n\x04phsA\x18\
    \x01\x20\x01(\x0b2\x19.commonmodule.ReadingMMTNR\x04phsAB\0\x121\n\x05ph\
    sAB\x18\x02\x20\x01(\x0b2\x19.commonmodule.ReadingMMTNR\x05phsABB\0\x12/\
    \n\x04phsB\x18\x03\x20\x01(\x0b2\x19.commonmodule.ReadingMMTNR\x04phsBB\
    \0\x121\n\x05phsBC\x18\x04\x20\x01(\x0b2\x19.commonmodule.ReadingMMTNR\
    \x05phsBCB\0\x12/\n\x04phsC\x18\x05\x20\x01(\x0b2\x19.commonmodule.Readi\
    ngMMTNR\x04phsCB\0\x121\n\x05phsCA\x18\x06\x20\x01(\x0b2\x19.commonmodul\
    e.ReadingMMTNR\x05phsCAB\0:\0\"\x98\x03\n\x08RampRate\x12g\n\x1fnegative\
    ReactivePowerKVArPerMin\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.FloatV\
    alueR\x1fnegativeReactivePowerKVArPerMinB\0\x12[\n\x19negativeRealPowerK\
    WPerMin\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x19negativ\
    eRealPowerKWPerMinB\0\x12g\n\x1fpositiveReactivePowerKVArPerMin\x18\x03\
    \x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x1fpositiveReactivePowerK\
    VArPerMinB\0\x12[\n\x19positiveRealPowerKWPerMin\x18\x04\x20\x01(\x0b2\
    \x1b.google.protobuf.FloatValueR\x19positiveRealPowerKWPerMinB\0:\0\"Y\n\
    \x12ReadingMessageInfo\x12A\n\x0bmessageInfo\x18\x01\x20\x01(\x0b2\x19.c\
    ommonmodule.MessageInfoR\x0bmessageInfoB\x04\x80\xb5\x18\x01:\0\"\xe7\
    \x03\n\x0bReadingMMTR\x12A\n\x0blogicalNode\x18\x01\x20\x01(\x0b2\x19.co\
    mmonmodule.LogicalNodeR\x0blogicalNodeB\x04\x80\xb5\x18\x01\x12+\n\x06Dm\
    dVAh\x18\x02\x20\x01(\x0b2\x11.commonmodule.BCRR\x06DmdVAhB\0\x12-\n\x07\
    DmdVArh\x18\x03\x20\x01(\x0b2\x11.commonmodule.BCRR\x07DmdVArhB\0\x12)\n\
    \x05DmdWh\x18\x04\x20\x01(\x0b2\x11.commonmodule.BCRR\x05DmdWhB\0\x12+\n\
    \x06SupVAh\x18\x05\x20\x01(\x0b2\x11.commonmodule.BCRR\x06SupVAhB\0\x12-\
    \n\x07SupVArh\x18\x06\x20\x01(\x0b2\x11.commonmodule.BCRR\x07SupVArhB\0\
    \x12)\n\x05SupWh\x18\x07\x20\x01(\x0b2\x11.commonmodule.BCRR\x05SupWhB\0\
    \x12+\n\x06TotVAh\x18\x08\x20\x01(\x0b2\x11.commonmodule.BCRR\x06TotVAhB\
    \0\x12-\n\x07TotVArh\x18\t\x20\x01(\x0b2\x11.commonmodule.BCRR\x07TotVAr\
    hB\0\x12)\n\x05TotWh\x18\n\x20\x01(\x0b2\x11.commonmodule.BCRR\x05TotWhB\
    \0:\0\"\xd2\x01\n\x03WYE\x12%\n\x03net\x18\x01\x20\x01(\x0b2\x11.commonm\
    odule.CMVR\x03netB\0\x12'\n\x04neut\x18\x02\x20\x01(\x0b2\x11.commonmodu\
    le.CMVR\x04neutB\0\x12'\n\x04phsA\x18\x03\x20\x01(\x0b2\x11.commonmodule\
    .CMVR\x04phsAB\0\x12'\n\x04phsB\x18\x04\x20\x01(\x0b2\x11.commonmodule.C\
    MVR\x04phsBB\0\x12'\n\x04phsC\x18\x05\x20\x01(\x0b2\x11.commonmodule.CMV\
    R\x04phsCB\0:\0\"\xef\x03\n\x0bReadingMMXU\x12A\n\x0blogicalNode\x18\x01\
    \x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0blogicalNodeB\x04\x80\xb5\
    \x18\x01\x12!\n\x01A\x18\x02\x20\x01(\x0b2\x11.commonmodule.WYER\x01AB\0\
    \x12:\n\x06ClcMth\x18\x03\x20\x01(\x0b2\x20.commonmodule.ENG_CalcMethodK\
    indR\x06ClcMthB\0\x12\"\n\x02Hz\x18\x04\x20\x01(\x0b2\x10.commonmodule.M\
    VR\x02HzB\0\x12#\n\x02PF\x18\x05\x20\x01(\x0b2\x11.commonmodule.WYER\x02\
    PFB\0\x126\n\x06PFSign\x18\x06\x20\x01(\x0b2\x1c.commonmodule.ENG_PFSign\
    KindR\x06PFSignB\0\x12%\n\x03PhV\x18\x07\x20\x01(\x0b2\x11.commonmodule.\
    WYER\x03PhVB\0\x12%\n\x03PPV\x18\x08\x20\x01(\x0b2\x11.commonmodule.DELR\
    \x03PPVB\0\x12#\n\x02VA\x18\t\x20\x01(\x0b2\x11.commonmodule.WYER\x02VAB\
    \0\x12%\n\x03VAr\x18\n\x20\x01(\x0b2\x11.commonmodule.WYER\x03VArB\0\x12\
    !\n\x01W\x18\x0b\x20\x01(\x0b2\x11.commonmodule.WYER\x01WB\0:\0\"G\n\x12\
    Optional_DbPosKind\x12/\n\x05value\x18\x01\x20\x01(\x0e2\x17.commonmodul\
    e.DbPosKindR\x05valueB\0:\0\"\xa6\x01\n\tStatusDPS\x12-\n\x01q\x18\x01\
    \x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\x08\x88\xb5\x18\x01\x90\
    \xb5\x18\x01\x127\n\x05stVal\x18\x02\x20\x01(\x0e2\x17.commonmodule.DbPo\
    sKindR\x05stValB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12/\n\x01t\x18\x03\
    \x20\x01(\x0b2\x17.commonmodule.TimestampR\x01tB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01:\0\"\x88\x02\n\x12StatusAndEventXCBR\x12t\n\x1clogicalNodeF\
    orEventAndStatus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeForEvent\
    AndStatusR\x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\x12E\n\
    \x0bDynamicTest\x18\x02\x20\x01(\x0b2!.commonmodule.ENS_DynamicTestKindR\
    \x0bDynamicTestB\0\x123\n\x03Pos\x18\x03\x20\x01(\x0b2\x17.commonmodule.\
    StatusDPSR\x03PosB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"}\n\tStatusIS\
    C\x12%\n\x01q\x18\x01\x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\0\
    \x12\x1e\n\x05stVal\x18\x02\x20\x01(\x05R\x05stValB\x08\x88\xb5\x18\x01\
    \x90\xb5\x18\x01\x12'\n\x01t\x18\x03\x20\x01(\x0b2\x17.commonmodule.Time\
    stampR\x01tB\0:\0\"X\n\x11StatusMessageInfo\x12A\n\x0bmessageInfo\x18\
    \x01\x20\x01(\x0b2\x19.commonmodule.MessageInfoR\x0bmessageInfoB\x04\x80\
    \xb5\x18\x01:\0\"}\n\tStatusSPC\x12%\n\x01q\x18\x01\x20\x01(\x0b2\x15.co\
    mmonmodule.QualityR\x01qB\0\x12\x1e\n\x05stVal\x18\x02\x20\x01(\x08R\x05\
    stValB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12'\n\x01t\x18\x03\x20\x01(\
    \x0b2\x17.commonmodule.TimestampR\x01tB\0:\0\"a\n\x0bStatusValue\x12P\n\
    \x10identifiedObject\x18\x01\x20\x01(\x0b2\x1e.commonmodule.IdentifiedOb\
    jectR\x10identifiedObjectB\x04\x80\xb5\x18\x01:\0\"\x87\x01\n\x03VSS\x12\
    -\n\x01q\x18\x01\x20\x01(\x0b2\x15.commonmodule.QualityR\x01qB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01\x12\x1e\n\x05stVal\x18\x02\x20\x01(\tR\x05s\
    tValB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12/\n\x01t\x18\x03\x20\x01(\
    \x0b2\x17.commonmodule.TimestampR\x01tB\x08\x90\xb5\x18\x01\x88\xb5\x18\
    \x01:\0\"\xc8\x01\n\x10StringStatusGGIO\x12A\n\x0blogicalNode\x18\x01\
    \x20\x01(\x0b2\x19.commonmodule.LogicalNodeR\x0blogicalNodeB\x04\x80\xb5\
    \x18\x01\x12<\n\x05Phase\x18\x02\x20\x01(\x0b2$.commonmodule.Optional_Ph\
    aseCodeKindR\x05PhaseB\0\x121\n\x05StrIn\x18\x03\x20\x01(\x0b2\x11.commo\
    nmodule.VSSR\x05StrInB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\0\"\x8d\x01\
    \n\x0bSwitchPoint\x124\n\x03Pos\x18\x01\x20\x01(\x0b2\x18.commonmodule.C\
    ontrolDPCR\x03PosB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12F\n\tstartTime\
    \x18\x02\x20\x01(\x0b2\x1e.commonmodule.ControlTimestampR\tstartTimeB\
    \x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\0\"J\n\tSwitchCSG\x12;\n\x06crvPts\
    \x18\x01\x20\x03(\x0b2\x19.commonmodule.SwitchPointR\x06crvPtsB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01:\0\"Z\n\x19SwitchControlScheduleFSCH\x12;\n\
    \x07ValDCSG\x18\x01\x20\x01(\x0b2\x17.commonmodule.SwitchCSGR\x07ValDCSG\
    B\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"G\n\x12Optional_StateKind\x12/\
    \n\x05value\x18\x01\x20\x01(\x0e2\x17.commonmodule.StateKindR\x05valueB\
    \0:\0*\xf7\x06\n\x0eUnitSymbolKind\x12\x17\n\x13UnitSymbolKind_none\x10\
    \0\x12\x18\n\x14UnitSymbolKind_meter\x10\x02\x12\x17\n\x13UnitSymbolKind\
    _gram\x10\x03\x12\x16\n\x12UnitSymbolKind_Amp\x10\x05\x12\x16\n\x12UnitS\
    ymbolKind_deg\x10\t\x12\x16\n\x12UnitSymbolKind_rad\x10\n\x12\x17\n\x13U\
    nitSymbolKind_degC\x10\x17\x12\x18\n\x14UnitSymbolKind_Farad\x10\x19\x12\
    \x16\n\x12UnitSymbolKind_sec\x10\x1b\x12\x18\n\x14UnitSymbolKind_Henry\
    \x10\x1c\x12\x14\n\x10UnitSymbolKind_V\x10\x1d\x12\x16\n\x12UnitSymbolKi\
    nd_ohm\x10\x1e\x12\x18\n\x14UnitSymbolKind_Joule\x10\x1f\x12\x19\n\x15Un\
    itSymbolKind_Newton\x10\x20\x12\x15\n\x11UnitSymbolKind_Hz\x10!\x12\x14\
    \n\x10UnitSymbolKind_W\x10&\x12\x15\n\x11UnitSymbolKind_Pa\x10'\x12\x15\
    \n\x11UnitSymbolKind_m2\x10)\x12\x1a\n\x16UnitSymbolKind_Siemens\x105\
    \x12\x15\n\x11UnitSymbolKind_VA\x10=\x12\x16\n\x12UnitSymbolKind_VAr\x10\
    ?\x12\x19\n\x15UnitSymbolKind_wPerVA\x10A\x12\x16\n\x12UnitSymbolKind_VA\
    h\x10G\x12\x15\n\x11UnitSymbolKind_Wh\x10H\x12\x17\n\x13UnitSymbolKind_V\
    Arh\x10I\x12\x19\n\x15UnitSymbolKind_hzPerS\x10K\x12\x18\n\x14UnitSymbol\
    Kind_wPerS\x10Q\x12\x18\n\x14UnitSymbolKind_other\x10d\x12\x15\n\x11Unit\
    SymbolKind_Ah\x10j\x12\x17\n\x12UnitSymbolKind_min\x10\x9f\x01\x12\x18\n\
    \x13UnitSymbolKind_hour\x10\xa0\x01\x12\x16\n\x11UnitSymbolKind_m3\x10\
    \xa6\x01\x12\x1a\n\x15UnitSymbolKind_wPerM2\x10\xb3\x01\x12\x18\n\x13Uni\
    tSymbolKind_degF\x10\x97\x02\x12\x17\n\x12UnitSymbolKind_mph\x10\xf4\x03\
    \x1a\0*\xf6\x02\n\x12UnitMultiplierKind\x12\x1b\n\x17UnitMultiplierKind_\
    none\x10\0\x12\x1c\n\x18UnitMultiplierKind_other\x10\x01\x12\x1c\n\x18Un\
    itMultiplierKind_centi\x10\x02\x12\x1b\n\x17UnitMultiplierKind_deci\x10\
    \x03\x12\x1b\n\x17UnitMultiplierKind_Giga\x10\x04\x12\x1b\n\x17UnitMulti\
    plierKind_kilo\x10\x05\x12\x1b\n\x17UnitMultiplierKind_Mega\x10\x06\x12\
    \x1c\n\x18UnitMultiplierKind_micro\x10\x07\x12\x1c\n\x18UnitMultiplierKi\
    nd_milli\x10\x08\x12\x1b\n\x17UnitMultiplierKind_nano\x10\t\x12\x1b\n\
    \x17UnitMultiplierKind_pico\x10\n\x12\x1b\n\x17UnitMultiplierKind_Tera\
    \x10\x0b\x1a\0*\xa3\x04\n\rPhaseCodeKind\x12\x16\n\x12PhaseCodeKind_none\
    \x10\0\x12\x17\n\x13PhaseCodeKind_other\x10\x01\x12\x13\n\x0fPhaseCodeKi\
    nd_N\x10\x10\x12\x13\n\x0fPhaseCodeKind_C\x10\x20\x12\x14\n\x10PhaseCode\
    Kind_CN\x10!\x12\x14\n\x10PhaseCodeKind_AC\x10(\x12\x15\n\x11PhaseCodeKi\
    nd_ACN\x10)\x12\x13\n\x0fPhaseCodeKind_B\x10@\x12\x14\n\x10PhaseCodeKind\
    _BN\x10A\x12\x14\n\x10PhaseCodeKind_BC\x10B\x12\x15\n\x11PhaseCodeKind_B\
    CN\x10a\x12\x14\n\x0fPhaseCodeKind_A\x10\x80\x01\x12\x15\n\x10PhaseCodeK\
    ind_AN\x10\x81\x01\x12\x15\n\x10PhaseCodeKind_AB\x10\x84\x01\x12\x16\n\
    \x11PhaseCodeKind_ABN\x10\xc1\x01\x12\x16\n\x11PhaseCodeKind_ABC\x10\xe0\
    \x01\x12\x17\n\x12PhaseCodeKind_ABCN\x10\xe1\x01\x12\x15\n\x10PhaseCodeK\
    ind_s2\x10\x80\x02\x12\x16\n\x11PhaseCodeKind_s2N\x10\x81\x02\x12\x15\n\
    \x10PhaseCodeKind_s1\x10\x80\x04\x12\x16\n\x11PhaseCodeKind_s1N\x10\x81\
    \x04\x12\x16\n\x11PhaseCodeKind_s12\x10\x80\x06\x12\x17\n\x12PhaseCodeKi\
    nd_s12N\x10\x81\x06\x1a\0*{\n\x0cValidityKind\x12\x15\n\x11ValidityKind_\
    good\x10\0\x12\x18\n\x14ValidityKind_invalid\x10\x01\x12\x19\n\x15Validi\
    tyKind_reserved\x10\x02\x12\x1d\n\x19ValidityKind_questionable\x10\x03\
    \x1a\0*B\n\nSourceKind\x12\x16\n\x12SourceKind_process\x10\0\x12\x1a\n\
    \x16SourceKind_substituted\x10\x01\x1a\0*\xec\x01\n\x10TimeAccuracyKind\
    \x12\x1e\n\x1aTimeAccuracyKind_UNDEFINED\x10\0\x12\x17\n\x13TimeAccuracy\
    Kind_T0\x10\x07\x12\x17\n\x13TimeAccuracyKind_T1\x10\n\x12\x17\n\x13Time\
    AccuracyKind_T2\x10\x0e\x12\x17\n\x13TimeAccuracyKind_T3\x10\x10\x12\x17\
    \n\x13TimeAccuracyKind_T4\x10\x12\x12\x17\n\x13TimeAccuracyKind_T5\x10\
    \x14\x12\x20\n\x1cTimeAccuracyKind_unspecified\x10\x1f\x1a\0*\xc5\r\n\
    \x15ScheduleParameterKind\x12\x1e\n\x1aScheduleParameterKind_none\x10\0\
    \x12\x1f\n\x1bScheduleParameterKind_other\x10\x01\x12#\n\x1fSchedulePara\
    meterKind_A_net_mag\x10\x02\x12$\n\x20ScheduleParameterKind_A_neut_mag\
    \x10\x03\x12$\n\x20ScheduleParameterKind_A_phsA_mag\x10\x04\x12$\n\x20Sc\
    heduleParameterKind_A_phsB_mag\x10\x05\x12$\n\x20ScheduleParameterKind_A\
    _phsC_mag\x10\x06\x12\x20\n\x1cScheduleParameterKind_Hz_mag\x10\x07\x12$\
    \n\x20ScheduleParameterKind_PF_net_mag\x10\x08\x12%\n!ScheduleParameterK\
    ind_PF_neut_mag\x10\t\x12%\n!ScheduleParameterKind_PF_phsA_mag\x10\n\x12\
    %\n!ScheduleParameterKind_PF_phsB_mag\x10\x0b\x12%\n!ScheduleParameterKi\
    nd_PF_phsC_mag\x10\x0c\x12%\n!ScheduleParameterKind_PhV_net_ang\x10\r\
    \x12%\n!ScheduleParameterKind_PhV_net_mag\x10\x0e\x12&\n\"ScheduleParame\
    terKind_PhV_neut_ang\x10\x0f\x12&\n\"ScheduleParameterKind_PhV_neut_mag\
    \x10\x10\x12&\n\"ScheduleParameterKind_PhV_phsA_ang\x10\x11\x12&\n\"Sche\
    duleParameterKind_PhV_phsA_mag\x10\x12\x12&\n\"ScheduleParameterKind_PhV\
    _phsB_ang\x10\x13\x12&\n\"ScheduleParameterKind_PhV_phsB_mag\x10\x14\x12\
    &\n\"ScheduleParameterKind_PhV_phsC_ang\x10\x15\x12&\n\"ScheduleParamete\
    rKind_PhV_phsC_mag\x10\x16\x12'\n#ScheduleParameterKind_PPV_phsAB_ang\
    \x10\x17\x12'\n#ScheduleParameterKind_PPV_phsAB_mag\x10\x18\x12'\n#Sched\
    uleParameterKind_PPV_phsBC_ang\x10\x19\x12'\n#ScheduleParameterKind_PPV_\
    phsBC_mag\x10\x1a\x12'\n#ScheduleParameterKind_PPV_phsCA_ang\x10\x1b\x12\
    '\n#ScheduleParameterKind_PPV_phsCA_mag\x10\x1c\x12$\n\x20ScheduleParame\
    terKind_VA_net_mag\x10\x1d\x12%\n!ScheduleParameterKind_VA_neut_mag\x10\
    \x1e\x12%\n!ScheduleParameterKind_VA_phsA_mag\x10\x1f\x12%\n!SchedulePar\
    ameterKind_VA_phsB_mag\x10\x20\x12%\n!ScheduleParameterKind_VA_phsC_mag\
    \x10!\x12%\n!ScheduleParameterKind_VAr_net_mag\x10\"\x12&\n\"SchedulePar\
    ameterKind_VAr_neut_mag\x10#\x12&\n\"ScheduleParameterKind_VAr_phsA_mag\
    \x10$\x12&\n\"ScheduleParameterKind_VAr_phsB_mag\x10%\x12&\n\"SchedulePa\
    rameterKind_VAr_phsC_mag\x10&\x12#\n\x1fScheduleParameterKind_W_net_mag\
    \x10'\x12$\n\x20ScheduleParameterKind_W_neut_mag\x10(\x12$\n\x20Schedule\
    ParameterKind_W_phsA_mag\x10)\x12$\n\x20ScheduleParameterKind_W_phsB_mag\
    \x10*\x12$\n\x20ScheduleParameterKind_W_phsC_mag\x10+\x1a\0*\x81\x01\n\
    \x0eCalcMethodKind\x12\x1c\n\x18CalcMethodKind_UNDEFINED\x10\0\x12\x1a\n\
    \x16CalcMethodKind_P_CLASS\x10\x0b\x12\x1a\n\x16CalcMethodKind_M_CLASS\
    \x10\x0c\x12\x17\n\x13CalcMethodKind_DIFF\x10\r\x1a\0*\xb8\x02\n\x13Grid\
    ConnectModeKind\x12!\n\x1dGridConnectModeKind_UNDEFINED\x10\0\x12\x1b\n\
    \x17GridConnectModeKind_CSI\x10\x01\x12\x1e\n\x1aGridConnectModeKind_VC_\
    VSI\x10\x02\x12\x1e\n\x1aGridConnectModeKind_CC_VSI\x10\x03\x12\x1c\n\
    \x18GridConnectModeKind_none\x10b\x12\x1d\n\x19GridConnectModeKind_other\
    \x10c\x12\x1f\n\x1aGridConnectModeKind_VSI_PQ\x10\xd0\x0f\x12\x1f\n\x1aG\
    ridConnectModeKind_VSI_VF\x10\xd1\x0f\x12\x20\n\x1bGridConnectModeKind_V\
    SI_ISO\x10\xd2\x0f\x1a\0*P\n\nPFSignKind\x12\x18\n\x14PFSignKind_UNDEFIN\
    ED\x10\0\x12\x12\n\x0ePFSignKind_IEC\x10\x01\x12\x12\n\x0ePFSignKind_EEI\
    \x10\x02\x1a\0*\xca\x01\n\x11BehaviourModeKind\x12\x1f\n\x1bBehaviourMod\
    eKind_UNDEFINED\x10\0\x12\x18\n\x14BehaviourModeKind_on\x10\x01\x12\x1d\
    \n\x19BehaviourModeKind_blocked\x10\x02\x12\x1a\n\x16BehaviourModeKind_t\
    est\x10\x03\x12\"\n\x1eBehaviourModeKind_test_blocked\x10\x04\x12\x19\n\
    \x15BehaviourModeKind_off\x10\x05\x1a\0*\xe2\x03\n\x15DERGeneratorStateK\
    ind\x12#\n\x1fDERGeneratorStateKind_UNDEFINED\x10\0\x12'\n#DERGeneratorS\
    tateKind_Not_operating\x10\x01\x12#\n\x1fDERGeneratorStateKind_Operating\
    \x10\x02\x12%\n!DERGeneratorStateKind_Starting_up\x10\x03\x12'\n#DERGene\
    ratorStateKind_Shutting_down\x10\x04\x12-\n)DERGeneratorStateKind_At_dis\
    connect_level\x10\x05\x12*\n&DERGeneratorStateKind_Ramping_in_power\x10\
    \x06\x123\n/DERGeneratorStateKind_Ramping_in_reactive_power\x10\x07\x12!\
    \n\x1dDERGeneratorStateKind_Standby\x10\x08\x120\n,DERGeneratorStateKind\
    _Not_applicable_Unknown\x10b\x12\x1f\n\x1bDERGeneratorStateKind_Other\
    \x10c\x1a\0*\x85\x01\n\x0fDynamicTestKind\x12\x18\n\x14DynamicTestKind_n\
    one\x10\0\x12\x1b\n\x17DynamicTestKind_testing\x10\x01\x12\x1d\n\x19Dyna\
    micTestKind_operating\x10\x02\x12\x1a\n\x16DynamicTestKind_failed\x10\
    \x03\x1a\0*d\n\nHealthKind\x12\x13\n\x0fHealthKind_none\x10\0\x12\x11\n\
    \rHealthKind_OK\x10\x01\x12\x16\n\x12HealthKind_Warning\x10\x02\x12\x14\
    \n\x10HealthKind_Alarm\x10\x03\x1a\0*g\n\tDbPosKind\x12\x17\n\x13DbPosKi\
    nd_transient\x10\0\x12\x14\n\x10DbPosKind_closed\x10\x01\x12\x12\n\x0eDb\
    PosKind_open\x10\x02\x12\x15\n\x11DbPosKind_invalid\x10\x03\x1a\0*I\n\tS\
    tateKind\x12\x11\n\rStateKind_off\x10\0\x12\x10\n\x0cStateKind_on\x10\
    \x01\x12\x15\n\x11StateKind_standby\x10\x02\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
