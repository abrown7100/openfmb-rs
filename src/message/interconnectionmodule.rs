// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `interconnectionmodule/interconnectionmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InterconnectionPoint {
    // message fields
    blackStartEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    island: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    startTime: ::protobuf::SingularPtrField<super::commonmodule::Timestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterconnectionPoint {
    fn default() -> &'a InterconnectionPoint {
        <InterconnectionPoint as ::protobuf::Message>::default_instance()
    }
}

impl InterconnectionPoint {
    pub fn new() -> InterconnectionPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC blackStartEnabled = 1;


    pub fn get_blackStartEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.blackStartEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackStartEnabled(&mut self) {
        self.blackStartEnabled.clear();
    }

    pub fn has_blackStartEnabled(&self) -> bool {
        self.blackStartEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackStartEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.blackStartEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackStartEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.blackStartEnabled.is_none() {
            self.blackStartEnabled.set_default();
        }
        self.blackStartEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackStartEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.blackStartEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 2;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC island = 3;


    pub fn get_island(&self) -> &super::commonmodule::ControlDPC {
        self.island.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_island(&mut self) {
        self.island.clear();
    }

    pub fn has_island(&self) -> bool {
        self.island.is_some()
    }

    // Param is passed by value, moved
    pub fn set_island(&mut self, v: super::commonmodule::ControlDPC) {
        self.island = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_island(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.island.is_none() {
            self.island.set_default();
        }
        self.island.as_mut().unwrap()
    }

    // Take field
    pub fn take_island(&mut self) -> super::commonmodule::ControlDPC {
        self.island.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 4;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 5;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 6;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 7;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 8;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 9;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Timestamp startTime = 10;


    pub fn get_startTime(&self) -> &super::commonmodule::Timestamp {
        self.startTime.as_ref().unwrap_or_else(|| <super::commonmodule::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::commonmodule::Timestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::commonmodule::Timestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::commonmodule::Timestamp {
        self.startTime.take().unwrap_or_else(|| super::commonmodule::Timestamp::new())
    }
}

impl ::protobuf::Message for InterconnectionPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.blackStartEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.island {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackStartEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.island)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.island.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.island.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterconnectionPoint {
        InterconnectionPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "blackStartEnabled",
                |m: &InterconnectionPoint| { &m.blackStartEnabled },
                |m: &mut InterconnectionPoint| { &mut m.blackStartEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &InterconnectionPoint| { &m.frequencySetPointEnabled },
                |m: &mut InterconnectionPoint| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "island",
                |m: &InterconnectionPoint| { &m.island },
                |m: &mut InterconnectionPoint| { &mut m.island },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &InterconnectionPoint| { &m.pctHzDroop },
                |m: &mut InterconnectionPoint| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &InterconnectionPoint| { &m.pctVDroop },
                |m: &mut InterconnectionPoint| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &InterconnectionPoint| { &m.rampRates },
                |m: &mut InterconnectionPoint| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &InterconnectionPoint| { &m.reactivePwrSetPointEnabled },
                |m: &mut InterconnectionPoint| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &InterconnectionPoint| { &m.realPwrSetPointEnabled },
                |m: &mut InterconnectionPoint| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &InterconnectionPoint| { &m.voltageSetPointEnabled },
                |m: &mut InterconnectionPoint| { &mut m.voltageSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Timestamp>>(
                "startTime",
                |m: &InterconnectionPoint| { &m.startTime },
                |m: &mut InterconnectionPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterconnectionPoint>(
                "InterconnectionPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterconnectionPoint {
        static instance: ::protobuf::rt::LazyV2<InterconnectionPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterconnectionPoint::new)
    }
}

impl ::protobuf::Clear for InterconnectionPoint {
    fn clear(&mut self) {
        self.blackStartEnabled.clear();
        self.frequencySetPointEnabled.clear();
        self.island.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.voltageSetPointEnabled.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterconnectionPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterconnectionPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InterconnectionCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<InterconnectionPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterconnectionCSG {
    fn default() -> &'a InterconnectionCSG {
        <InterconnectionCSG as ::protobuf::Message>::default_instance()
    }
}

impl InterconnectionCSG {
    pub fn new() -> InterconnectionCSG {
        ::std::default::Default::default()
    }

    // repeated .interconnectionmodule.InterconnectionPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[InterconnectionPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<InterconnectionPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<InterconnectionPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<InterconnectionPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InterconnectionCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterconnectionCSG {
        InterconnectionCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionPoint>>(
                "crvPts",
                |m: &InterconnectionCSG| { &m.crvPts },
                |m: &mut InterconnectionCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterconnectionCSG>(
                "InterconnectionCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterconnectionCSG {
        static instance: ::protobuf::rt::LazyV2<InterconnectionCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterconnectionCSG::new)
    }
}

impl ::protobuf::Clear for InterconnectionCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterconnectionCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterconnectionCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InterconnectionControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<InterconnectionCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterconnectionControlScheduleFSCH {
    fn default() -> &'a InterconnectionControlScheduleFSCH {
        <InterconnectionControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl InterconnectionControlScheduleFSCH {
    pub fn new() -> InterconnectionControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .interconnectionmodule.InterconnectionCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &InterconnectionCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <InterconnectionCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: InterconnectionCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut InterconnectionCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> InterconnectionCSG {
        self.ValDCSG.take().unwrap_or_else(|| InterconnectionCSG::new())
    }
}

impl ::protobuf::Message for InterconnectionControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterconnectionControlScheduleFSCH {
        InterconnectionControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionCSG>>(
                "ValDCSG",
                |m: &InterconnectionControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut InterconnectionControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterconnectionControlScheduleFSCH>(
                "InterconnectionControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterconnectionControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<InterconnectionControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterconnectionControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for InterconnectionControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterconnectionControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterconnectionControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InterconnectionScheduleFSCC {
    // message fields
    controlFSCC: ::protobuf::SingularPtrField<super::commonmodule::ControlFSCC>,
    interconnectionControlScheduleFSCH: ::protobuf::RepeatedField<InterconnectionControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterconnectionScheduleFSCC {
    fn default() -> &'a InterconnectionScheduleFSCC {
        <InterconnectionScheduleFSCC as ::protobuf::Message>::default_instance()
    }
}

impl InterconnectionScheduleFSCC {
    pub fn new() -> InterconnectionScheduleFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlFSCC controlFSCC = 1;


    pub fn get_controlFSCC(&self) -> &super::commonmodule::ControlFSCC {
        self.controlFSCC.as_ref().unwrap_or_else(|| <super::commonmodule::ControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlFSCC(&mut self) {
        self.controlFSCC.clear();
    }

    pub fn has_controlFSCC(&self) -> bool {
        self.controlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlFSCC(&mut self, v: super::commonmodule::ControlFSCC) {
        self.controlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlFSCC(&mut self) -> &mut super::commonmodule::ControlFSCC {
        if self.controlFSCC.is_none() {
            self.controlFSCC.set_default();
        }
        self.controlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlFSCC(&mut self) -> super::commonmodule::ControlFSCC {
        self.controlFSCC.take().unwrap_or_else(|| super::commonmodule::ControlFSCC::new())
    }

    // repeated .interconnectionmodule.InterconnectionControlScheduleFSCH interconnectionControlScheduleFSCH = 2;


    pub fn get_interconnectionControlScheduleFSCH(&self) -> &[InterconnectionControlScheduleFSCH] {
        &self.interconnectionControlScheduleFSCH
    }
    pub fn clear_interconnectionControlScheduleFSCH(&mut self) {
        self.interconnectionControlScheduleFSCH.clear();
    }

    // Param is passed by value, moved
    pub fn set_interconnectionControlScheduleFSCH(&mut self, v: ::protobuf::RepeatedField<InterconnectionControlScheduleFSCH>) {
        self.interconnectionControlScheduleFSCH = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interconnectionControlScheduleFSCH(&mut self) -> &mut ::protobuf::RepeatedField<InterconnectionControlScheduleFSCH> {
        &mut self.interconnectionControlScheduleFSCH
    }

    // Take field
    pub fn take_interconnectionControlScheduleFSCH(&mut self) -> ::protobuf::RepeatedField<InterconnectionControlScheduleFSCH> {
        ::std::mem::replace(&mut self.interconnectionControlScheduleFSCH, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InterconnectionScheduleFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.controlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interconnectionControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlFSCC)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interconnectionControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.interconnectionControlScheduleFSCH {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlFSCC.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.interconnectionControlScheduleFSCH {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterconnectionScheduleFSCC {
        InterconnectionScheduleFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlFSCC>>(
                "controlFSCC",
                |m: &InterconnectionScheduleFSCC| { &m.controlFSCC },
                |m: &mut InterconnectionScheduleFSCC| { &mut m.controlFSCC },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionControlScheduleFSCH>>(
                "interconnectionControlScheduleFSCH",
                |m: &InterconnectionScheduleFSCC| { &m.interconnectionControlScheduleFSCH },
                |m: &mut InterconnectionScheduleFSCC| { &mut m.interconnectionControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterconnectionScheduleFSCC>(
                "InterconnectionScheduleFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterconnectionScheduleFSCC {
        static instance: ::protobuf::rt::LazyV2<InterconnectionScheduleFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterconnectionScheduleFSCC::new)
    }
}

impl ::protobuf::Clear for InterconnectionScheduleFSCC {
    fn clear(&mut self) {
        self.controlFSCC.clear();
        self.interconnectionControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterconnectionScheduleFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterconnectionScheduleFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InterconnectionSchedule {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    interconnectionScheduleFSCC: ::protobuf::SingularPtrField<InterconnectionScheduleFSCC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InterconnectionSchedule {
    fn default() -> &'a InterconnectionSchedule {
        <InterconnectionSchedule as ::protobuf::Message>::default_instance()
    }
}

impl InterconnectionSchedule {
    pub fn new() -> InterconnectionSchedule {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .interconnectionmodule.InterconnectionScheduleFSCC interconnectionScheduleFSCC = 3;


    pub fn get_interconnectionScheduleFSCC(&self) -> &InterconnectionScheduleFSCC {
        self.interconnectionScheduleFSCC.as_ref().unwrap_or_else(|| <InterconnectionScheduleFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interconnectionScheduleFSCC(&mut self) {
        self.interconnectionScheduleFSCC.clear();
    }

    pub fn has_interconnectionScheduleFSCC(&self) -> bool {
        self.interconnectionScheduleFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interconnectionScheduleFSCC(&mut self, v: InterconnectionScheduleFSCC) {
        self.interconnectionScheduleFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interconnectionScheduleFSCC(&mut self) -> &mut InterconnectionScheduleFSCC {
        if self.interconnectionScheduleFSCC.is_none() {
            self.interconnectionScheduleFSCC.set_default();
        }
        self.interconnectionScheduleFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_interconnectionScheduleFSCC(&mut self) -> InterconnectionScheduleFSCC {
        self.interconnectionScheduleFSCC.take().unwrap_or_else(|| InterconnectionScheduleFSCC::new())
    }
}

impl ::protobuf::Message for InterconnectionSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interconnectionScheduleFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interconnectionScheduleFSCC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interconnectionScheduleFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interconnectionScheduleFSCC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InterconnectionSchedule {
        InterconnectionSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &InterconnectionSchedule| { &m.controlValue },
                |m: &mut InterconnectionSchedule| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &InterconnectionSchedule| { &m.check },
                |m: &mut InterconnectionSchedule| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionScheduleFSCC>>(
                "interconnectionScheduleFSCC",
                |m: &InterconnectionSchedule| { &m.interconnectionScheduleFSCC },
                |m: &mut InterconnectionSchedule| { &mut m.interconnectionScheduleFSCC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InterconnectionSchedule>(
                "InterconnectionSchedule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InterconnectionSchedule {
        static instance: ::protobuf::rt::LazyV2<InterconnectionSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InterconnectionSchedule::new)
    }
}

impl ::protobuf::Clear for InterconnectionSchedule {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.interconnectionScheduleFSCC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InterconnectionSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterconnectionSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PlannedInterconnectionScheduleProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    applicationSystem: ::protobuf::SingularPtrField<super::commonmodule::ApplicationSystem>,
    interconnectionSchedule: ::protobuf::SingularPtrField<InterconnectionSchedule>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlannedInterconnectionScheduleProfile {
    fn default() -> &'a PlannedInterconnectionScheduleProfile {
        <PlannedInterconnectionScheduleProfile as ::protobuf::Message>::default_instance()
    }
}

impl PlannedInterconnectionScheduleProfile {
    pub fn new() -> PlannedInterconnectionScheduleProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.ApplicationSystem applicationSystem = 2;


    pub fn get_applicationSystem(&self) -> &super::commonmodule::ApplicationSystem {
        self.applicationSystem.as_ref().unwrap_or_else(|| <super::commonmodule::ApplicationSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applicationSystem(&mut self) {
        self.applicationSystem.clear();
    }

    pub fn has_applicationSystem(&self) -> bool {
        self.applicationSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applicationSystem(&mut self, v: super::commonmodule::ApplicationSystem) {
        self.applicationSystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applicationSystem(&mut self) -> &mut super::commonmodule::ApplicationSystem {
        if self.applicationSystem.is_none() {
            self.applicationSystem.set_default();
        }
        self.applicationSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_applicationSystem(&mut self) -> super::commonmodule::ApplicationSystem {
        self.applicationSystem.take().unwrap_or_else(|| super::commonmodule::ApplicationSystem::new())
    }

    // .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3;


    pub fn get_interconnectionSchedule(&self) -> &InterconnectionSchedule {
        self.interconnectionSchedule.as_ref().unwrap_or_else(|| <InterconnectionSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interconnectionSchedule(&mut self) {
        self.interconnectionSchedule.clear();
    }

    pub fn has_interconnectionSchedule(&self) -> bool {
        self.interconnectionSchedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interconnectionSchedule(&mut self, v: InterconnectionSchedule) {
        self.interconnectionSchedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interconnectionSchedule(&mut self) -> &mut InterconnectionSchedule {
        if self.interconnectionSchedule.is_none() {
            self.interconnectionSchedule.set_default();
        }
        self.interconnectionSchedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_interconnectionSchedule(&mut self) -> InterconnectionSchedule {
        self.interconnectionSchedule.take().unwrap_or_else(|| InterconnectionSchedule::new())
    }
}

impl ::protobuf::Message for PlannedInterconnectionScheduleProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applicationSystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interconnectionSchedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applicationSystem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interconnectionSchedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interconnectionSchedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interconnectionSchedule.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlannedInterconnectionScheduleProfile {
        PlannedInterconnectionScheduleProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &PlannedInterconnectionScheduleProfile| { &m.controlMessageInfo },
                |m: &mut PlannedInterconnectionScheduleProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ApplicationSystem>>(
                "applicationSystem",
                |m: &PlannedInterconnectionScheduleProfile| { &m.applicationSystem },
                |m: &mut PlannedInterconnectionScheduleProfile| { &mut m.applicationSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionSchedule>>(
                "interconnectionSchedule",
                |m: &PlannedInterconnectionScheduleProfile| { &m.interconnectionSchedule },
                |m: &mut PlannedInterconnectionScheduleProfile| { &mut m.interconnectionSchedule },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlannedInterconnectionScheduleProfile>(
                "PlannedInterconnectionScheduleProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlannedInterconnectionScheduleProfile {
        static instance: ::protobuf::rt::LazyV2<PlannedInterconnectionScheduleProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlannedInterconnectionScheduleProfile::new)
    }
}

impl ::protobuf::Clear for PlannedInterconnectionScheduleProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.applicationSystem.clear();
        self.interconnectionSchedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlannedInterconnectionScheduleProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlannedInterconnectionScheduleProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RequestedInterconnectionScheduleProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    applicationSystem: ::protobuf::SingularPtrField<super::commonmodule::ApplicationSystem>,
    interconnectionSchedule: ::protobuf::SingularPtrField<InterconnectionSchedule>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestedInterconnectionScheduleProfile {
    fn default() -> &'a RequestedInterconnectionScheduleProfile {
        <RequestedInterconnectionScheduleProfile as ::protobuf::Message>::default_instance()
    }
}

impl RequestedInterconnectionScheduleProfile {
    pub fn new() -> RequestedInterconnectionScheduleProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.ApplicationSystem applicationSystem = 2;


    pub fn get_applicationSystem(&self) -> &super::commonmodule::ApplicationSystem {
        self.applicationSystem.as_ref().unwrap_or_else(|| <super::commonmodule::ApplicationSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applicationSystem(&mut self) {
        self.applicationSystem.clear();
    }

    pub fn has_applicationSystem(&self) -> bool {
        self.applicationSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applicationSystem(&mut self, v: super::commonmodule::ApplicationSystem) {
        self.applicationSystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applicationSystem(&mut self) -> &mut super::commonmodule::ApplicationSystem {
        if self.applicationSystem.is_none() {
            self.applicationSystem.set_default();
        }
        self.applicationSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_applicationSystem(&mut self) -> super::commonmodule::ApplicationSystem {
        self.applicationSystem.take().unwrap_or_else(|| super::commonmodule::ApplicationSystem::new())
    }

    // .interconnectionmodule.InterconnectionSchedule interconnectionSchedule = 3;


    pub fn get_interconnectionSchedule(&self) -> &InterconnectionSchedule {
        self.interconnectionSchedule.as_ref().unwrap_or_else(|| <InterconnectionSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interconnectionSchedule(&mut self) {
        self.interconnectionSchedule.clear();
    }

    pub fn has_interconnectionSchedule(&self) -> bool {
        self.interconnectionSchedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interconnectionSchedule(&mut self, v: InterconnectionSchedule) {
        self.interconnectionSchedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interconnectionSchedule(&mut self) -> &mut InterconnectionSchedule {
        if self.interconnectionSchedule.is_none() {
            self.interconnectionSchedule.set_default();
        }
        self.interconnectionSchedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_interconnectionSchedule(&mut self) -> InterconnectionSchedule {
        self.interconnectionSchedule.take().unwrap_or_else(|| InterconnectionSchedule::new())
    }
}

impl ::protobuf::Message for RequestedInterconnectionScheduleProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applicationSystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interconnectionSchedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applicationSystem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interconnectionSchedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interconnectionSchedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interconnectionSchedule.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestedInterconnectionScheduleProfile {
        RequestedInterconnectionScheduleProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &RequestedInterconnectionScheduleProfile| { &m.controlMessageInfo },
                |m: &mut RequestedInterconnectionScheduleProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ApplicationSystem>>(
                "applicationSystem",
                |m: &RequestedInterconnectionScheduleProfile| { &m.applicationSystem },
                |m: &mut RequestedInterconnectionScheduleProfile| { &mut m.applicationSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InterconnectionSchedule>>(
                "interconnectionSchedule",
                |m: &RequestedInterconnectionScheduleProfile| { &m.interconnectionSchedule },
                |m: &mut RequestedInterconnectionScheduleProfile| { &mut m.interconnectionSchedule },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestedInterconnectionScheduleProfile>(
                "RequestedInterconnectionScheduleProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestedInterconnectionScheduleProfile {
        static instance: ::protobuf::rt::LazyV2<RequestedInterconnectionScheduleProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestedInterconnectionScheduleProfile::new)
    }
}

impl ::protobuf::Clear for RequestedInterconnectionScheduleProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.applicationSystem.clear();
        self.interconnectionSchedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestedInterconnectionScheduleProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestedInterconnectionScheduleProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1interconnectionmodule/interconnectionmodule.proto\x12\x15interconnect\
    ionmodule\"\xe7\x05\n\x14InterconnectionPoint\x12H\n\x11blackStartEnable\
    d\x18\x01\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x11blackStartEnable\
    dB\0\x12V\n\x18frequencySetPointEnabled\x18\x02\x20\x01(\x0b2\x18.common\
    module.ControlDPCR\x18frequencySetPointEnabledB\0\x122\n\x06island\x18\
    \x03\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x06islandB\0\x12=\n\npct\
    HzDroop\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\npctHzDroo\
    pB\0\x12;\n\tpctVDroop\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.FloatVa\
    lueR\tpctVDroopB\0\x126\n\trampRates\x18\x06\x20\x01(\x0b2\x16.commonmod\
    ule.RampRateR\trampRatesB\0\x12Z\n\x1areactivePwrSetPointEnabled\x18\x07\
    \x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1areactivePwrSetPointEnable\
    dB\0\x12R\n\x16realPwrSetPointEnabled\x18\x08\x20\x01(\x0b2\x18.commonmo\
    dule.ControlDPCR\x16realPwrSetPointEnabledB\0\x12R\n\x16voltageSetPointE\
    nabled\x18\t\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16voltageSetPoi\
    ntEnabledB\0\x12?\n\tstartTime\x18\n\x20\x01(\x0b2\x17.commonmodule.Time\
    stampR\tstartTimeB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"e\n\x12Interc\
    onnectionCSG\x12M\n\x06crvPts\x18\x01\x20\x03(\x0b2+.interconnectionmodu\
    le.InterconnectionPointR\x06crvPtsB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\
    \0\"u\n\"InterconnectionControlScheduleFSCH\x12M\n\x07ValDCSG\x18\x01\
    \x20\x01(\x0b2).interconnectionmodule.InterconnectionCSGR\x07ValDCSGB\
    \x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xf4\x01\n\x1bInterconnectionSc\
    heduleFSCC\x12A\n\x0bcontrolFSCC\x18\x01\x20\x01(\x0b2\x19.commonmodule.\
    ControlFSCCR\x0bcontrolFSCCB\x04\x80\xb5\x18\x01\x12\x8f\x01\n\"intercon\
    nectionControlScheduleFSCH\x18\x02\x20\x03(\x0b29.interconnectionmodule.\
    InterconnectionControlScheduleFSCHR\"interconnectionControlScheduleFSCHB\
    \x04\x90\xb5\x18\0:\0\"\x98\x02\n\x17InterconnectionSchedule\x12D\n\x0cc\
    ontrolValue\x18\x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\x0ccont\
    rolValueB\x04\x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\x0b2\x1d.\
    commonmodule.CheckConditionsR\x05checkB\0\x12~\n\x1binterconnectionSched\
    uleFSCC\x18\x03\x20\x01(\x0b22.interconnectionmodule.InterconnectionSche\
    duleFSCCR\x1binterconnectionScheduleFSCCB\x08\x88\xb5\x18\x01\x90\xb5\
    \x18\x01:\0\"\xd2\x02\n%PlannedInterconnectionScheduleProfile\x12V\n\x12\
    controlMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ControlMessage\
    InfoR\x12controlMessageInfoB\x04\x80\xb5\x18\x01\x12W\n\x11applicationSy\
    stem\x18\x02\x20\x01(\x0b2\x1f.commonmodule.ApplicationSystemR\x11applic\
    ationSystemB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12r\n\x17interconnecti\
    onSchedule\x18\x03\x20\x01(\x0b2..interconnectionmodule.InterconnectionS\
    cheduleR\x17interconnectionScheduleB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    :\x04\xc0\xf3\x18\x01\"\xd4\x02\n'RequestedInterconnectionScheduleProfil\
    e\x12V\n\x12controlMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.Co\
    ntrolMessageInfoR\x12controlMessageInfoB\x04\x80\xb5\x18\x01\x12W\n\x11a\
    pplicationSystem\x18\x02\x20\x01(\x0b2\x1f.commonmodule.ApplicationSyste\
    mR\x11applicationSystemB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12r\n\x17i\
    nterconnectionSchedule\x18\x03\x20\x01(\x0b2..interconnectionmodule.Inte\
    rconnectionScheduleR\x17interconnectionScheduleB\x08\x90\xb5\x18\x01\x88\
    \xb5\x18\x01:\x04\xc0\xf3\x18\x01B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
