// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `coordinationservicemodule/coordinationservicemodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Optional_CoordinationServiceModeKind {
    // message fields
    pub value: CoordinationServiceModeKind,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Optional_CoordinationServiceModeKind {
    fn default() -> &'a Optional_CoordinationServiceModeKind {
        <Optional_CoordinationServiceModeKind as ::protobuf::Message>::default_instance()
    }
}

impl Optional_CoordinationServiceModeKind {
    pub fn new() -> Optional_CoordinationServiceModeKind {
        ::std::default::Default::default()
    }

    // .coordinationservicemodule.CoordinationServiceModeKind value = 1;


    pub fn get_value(&self) -> CoordinationServiceModeKind {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = CoordinationServiceModeKind::CoordinationServiceModeKind_none;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CoordinationServiceModeKind) {
        self.value = v;
    }
}

impl ::protobuf::Message for Optional_CoordinationServiceModeKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CoordinationServiceModeKind::CoordinationServiceModeKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != CoordinationServiceModeKind::CoordinationServiceModeKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.value))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Optional_CoordinationServiceModeKind {
        Optional_CoordinationServiceModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CoordinationServiceModeKind>>(
                "value",
                |m: &Optional_CoordinationServiceModeKind| { &m.value },
                |m: &mut Optional_CoordinationServiceModeKind| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Optional_CoordinationServiceModeKind>(
                "Optional_CoordinationServiceModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Optional_CoordinationServiceModeKind {
        static instance: ::protobuf::rt::LazyV2<Optional_CoordinationServiceModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Optional_CoordinationServiceModeKind::new)
    }
}

impl ::protobuf::Clear for Optional_CoordinationServiceModeKind {
    fn clear(&mut self) {
        self.value = CoordinationServiceModeKind::CoordinationServiceModeKind_none;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Optional_CoordinationServiceModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Optional_CoordinationServiceModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ENG_CoordinationServiceModeKind {
    // message fields
    pub setVal: CoordinationServiceModeKind,
    setValExtension: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ENG_CoordinationServiceModeKind {
    fn default() -> &'a ENG_CoordinationServiceModeKind {
        <ENG_CoordinationServiceModeKind as ::protobuf::Message>::default_instance()
    }
}

impl ENG_CoordinationServiceModeKind {
    pub fn new() -> ENG_CoordinationServiceModeKind {
        ::std::default::Default::default()
    }

    // .coordinationservicemodule.CoordinationServiceModeKind setVal = 1;


    pub fn get_setVal(&self) -> CoordinationServiceModeKind {
        self.setVal
    }
    pub fn clear_setVal(&mut self) {
        self.setVal = CoordinationServiceModeKind::CoordinationServiceModeKind_none;
    }

    // Param is passed by value, moved
    pub fn set_setVal(&mut self, v: CoordinationServiceModeKind) {
        self.setVal = v;
    }

    // .google.protobuf.StringValue setValExtension = 2;


    pub fn get_setValExtension(&self) -> &::protobuf::well_known_types::StringValue {
        self.setValExtension.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::StringValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_setValExtension(&mut self) {
        self.setValExtension.clear();
    }

    pub fn has_setValExtension(&self) -> bool {
        self.setValExtension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setValExtension(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.setValExtension = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setValExtension(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.setValExtension.is_none() {
            self.setValExtension.set_default();
        }
        self.setValExtension.as_mut().unwrap()
    }

    // Take field
    pub fn take_setValExtension(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.setValExtension.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }
}

impl ::protobuf::Message for ENG_CoordinationServiceModeKind {
    fn is_initialized(&self) -> bool {
        for v in &self.setValExtension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.setVal, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.setValExtension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.setVal != CoordinationServiceModeKind::CoordinationServiceModeKind_none {
            my_size += ::protobuf::rt::enum_size(1, self.setVal);
        }
        if let Some(ref v) = self.setValExtension.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.setVal != CoordinationServiceModeKind::CoordinationServiceModeKind_none {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.setVal))?;
        }
        if let Some(ref v) = self.setValExtension.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ENG_CoordinationServiceModeKind {
        ENG_CoordinationServiceModeKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CoordinationServiceModeKind>>(
                "setVal",
                |m: &ENG_CoordinationServiceModeKind| { &m.setVal },
                |m: &mut ENG_CoordinationServiceModeKind| { &mut m.setVal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                "setValExtension",
                |m: &ENG_CoordinationServiceModeKind| { &m.setValExtension },
                |m: &mut ENG_CoordinationServiceModeKind| { &mut m.setValExtension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ENG_CoordinationServiceModeKind>(
                "ENG_CoordinationServiceModeKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ENG_CoordinationServiceModeKind {
        static instance: ::protobuf::rt::LazyV2<ENG_CoordinationServiceModeKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ENG_CoordinationServiceModeKind::new)
    }
}

impl ::protobuf::Clear for ENG_CoordinationServiceModeKind {
    fn clear(&mut self) {
        self.setVal = CoordinationServiceModeKind::CoordinationServiceModeKind_none;
        self.setValExtension.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ENG_CoordinationServiceModeKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ENG_CoordinationServiceModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationControlDCSC {
    // message fields
    logicalNodeForControl: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForControl>,
    CoordinationServiceMode: ::protobuf::SingularPtrField<ENG_CoordinationServiceModeKind>,
    Island: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationControlDCSC {
    fn default() -> &'a CoordinationControlDCSC {
        <CoordinationControlDCSC as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationControlDCSC {
    pub fn new() -> CoordinationControlDCSC {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForControl logicalNodeForControl = 1;


    pub fn get_logicalNodeForControl(&self) -> &super::commonmodule::LogicalNodeForControl {
        self.logicalNodeForControl.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForControl(&mut self) {
        self.logicalNodeForControl.clear();
    }

    pub fn has_logicalNodeForControl(&self) -> bool {
        self.logicalNodeForControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForControl(&mut self, v: super::commonmodule::LogicalNodeForControl) {
        self.logicalNodeForControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForControl(&mut self) -> &mut super::commonmodule::LogicalNodeForControl {
        if self.logicalNodeForControl.is_none() {
            self.logicalNodeForControl.set_default();
        }
        self.logicalNodeForControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForControl(&mut self) -> super::commonmodule::LogicalNodeForControl {
        self.logicalNodeForControl.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForControl::new())
    }

    // .coordinationservicemodule.ENG_CoordinationServiceModeKind CoordinationServiceMode = 2;


    pub fn get_CoordinationServiceMode(&self) -> &ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.as_ref().unwrap_or_else(|| <ENG_CoordinationServiceModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CoordinationServiceMode(&mut self) {
        self.CoordinationServiceMode.clear();
    }

    pub fn has_CoordinationServiceMode(&self) -> bool {
        self.CoordinationServiceMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CoordinationServiceMode(&mut self, v: ENG_CoordinationServiceModeKind) {
        self.CoordinationServiceMode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CoordinationServiceMode(&mut self) -> &mut ENG_CoordinationServiceModeKind {
        if self.CoordinationServiceMode.is_none() {
            self.CoordinationServiceMode.set_default();
        }
        self.CoordinationServiceMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_CoordinationServiceMode(&mut self) -> ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.take().unwrap_or_else(|| ENG_CoordinationServiceModeKind::new())
    }

    // .commonmodule.ControlDPC Island = 3;


    pub fn get_Island(&self) -> &super::commonmodule::ControlDPC {
        self.Island.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Island(&mut self) {
        self.Island.clear();
    }

    pub fn has_Island(&self) -> bool {
        self.Island.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Island(&mut self, v: super::commonmodule::ControlDPC) {
        self.Island = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Island(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.Island.is_none() {
            self.Island.set_default();
        }
        self.Island.as_mut().unwrap()
    }

    // Take field
    pub fn take_Island(&mut self) -> super::commonmodule::ControlDPC {
        self.Island.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }
}

impl ::protobuf::Message for CoordinationControlDCSC {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CoordinationServiceMode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Island {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForControl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CoordinationServiceMode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Island)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Island.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForControl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Island.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationControlDCSC {
        CoordinationControlDCSC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForControl>>(
                "logicalNodeForControl",
                |m: &CoordinationControlDCSC| { &m.logicalNodeForControl },
                |m: &mut CoordinationControlDCSC| { &mut m.logicalNodeForControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_CoordinationServiceModeKind>>(
                "CoordinationServiceMode",
                |m: &CoordinationControlDCSC| { &m.CoordinationServiceMode },
                |m: &mut CoordinationControlDCSC| { &mut m.CoordinationServiceMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "Island",
                |m: &CoordinationControlDCSC| { &m.Island },
                |m: &mut CoordinationControlDCSC| { &mut m.Island },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationControlDCSC>(
                "CoordinationControlDCSC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationControlDCSC {
        static instance: ::protobuf::rt::LazyV2<CoordinationControlDCSC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationControlDCSC::new)
    }
}

impl ::protobuf::Clear for CoordinationControlDCSC {
    fn clear(&mut self) {
        self.logicalNodeForControl.clear();
        self.CoordinationServiceMode.clear();
        self.Island.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationControlDCSC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationControlDCSC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationControl {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    coordinationControlDCSC: ::protobuf::SingularPtrField<CoordinationControlDCSC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationControl {
    fn default() -> &'a CoordinationControl {
        <CoordinationControl as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationControl {
    pub fn new() -> CoordinationControl {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .coordinationservicemodule.CoordinationControlDCSC coordinationControlDCSC = 3;


    pub fn get_coordinationControlDCSC(&self) -> &CoordinationControlDCSC {
        self.coordinationControlDCSC.as_ref().unwrap_or_else(|| <CoordinationControlDCSC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationControlDCSC(&mut self) {
        self.coordinationControlDCSC.clear();
    }

    pub fn has_coordinationControlDCSC(&self) -> bool {
        self.coordinationControlDCSC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationControlDCSC(&mut self, v: CoordinationControlDCSC) {
        self.coordinationControlDCSC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationControlDCSC(&mut self) -> &mut CoordinationControlDCSC {
        if self.coordinationControlDCSC.is_none() {
            self.coordinationControlDCSC.set_default();
        }
        self.coordinationControlDCSC.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationControlDCSC(&mut self) -> CoordinationControlDCSC {
        self.coordinationControlDCSC.take().unwrap_or_else(|| CoordinationControlDCSC::new())
    }
}

impl ::protobuf::Message for CoordinationControl {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationControlDCSC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationControlDCSC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationControlDCSC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationControlDCSC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationControl {
        CoordinationControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &CoordinationControl| { &m.controlValue },
                |m: &mut CoordinationControl| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &CoordinationControl| { &m.check },
                |m: &mut CoordinationControl| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationControlDCSC>>(
                "coordinationControlDCSC",
                |m: &CoordinationControl| { &m.coordinationControlDCSC },
                |m: &mut CoordinationControl| { &mut m.coordinationControlDCSC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationControl>(
                "CoordinationControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationControl {
        static instance: ::protobuf::rt::LazyV2<CoordinationControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationControl::new)
    }
}

impl ::protobuf::Clear for CoordinationControl {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.coordinationControlDCSC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationControlProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    applicationSystem: ::protobuf::SingularPtrField<super::commonmodule::ApplicationSystem>,
    coordinationControl: ::protobuf::SingularPtrField<CoordinationControl>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationControlProfile {
    fn default() -> &'a CoordinationControlProfile {
        <CoordinationControlProfile as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationControlProfile {
    pub fn new() -> CoordinationControlProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.ApplicationSystem applicationSystem = 2;


    pub fn get_applicationSystem(&self) -> &super::commonmodule::ApplicationSystem {
        self.applicationSystem.as_ref().unwrap_or_else(|| <super::commonmodule::ApplicationSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applicationSystem(&mut self) {
        self.applicationSystem.clear();
    }

    pub fn has_applicationSystem(&self) -> bool {
        self.applicationSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applicationSystem(&mut self, v: super::commonmodule::ApplicationSystem) {
        self.applicationSystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applicationSystem(&mut self) -> &mut super::commonmodule::ApplicationSystem {
        if self.applicationSystem.is_none() {
            self.applicationSystem.set_default();
        }
        self.applicationSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_applicationSystem(&mut self) -> super::commonmodule::ApplicationSystem {
        self.applicationSystem.take().unwrap_or_else(|| super::commonmodule::ApplicationSystem::new())
    }

    // .coordinationservicemodule.CoordinationControl coordinationControl = 3;


    pub fn get_coordinationControl(&self) -> &CoordinationControl {
        self.coordinationControl.as_ref().unwrap_or_else(|| <CoordinationControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationControl(&mut self) {
        self.coordinationControl.clear();
    }

    pub fn has_coordinationControl(&self) -> bool {
        self.coordinationControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationControl(&mut self, v: CoordinationControl) {
        self.coordinationControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationControl(&mut self) -> &mut CoordinationControl {
        if self.coordinationControl.is_none() {
            self.coordinationControl.set_default();
        }
        self.coordinationControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationControl(&mut self) -> CoordinationControl {
        self.coordinationControl.take().unwrap_or_else(|| CoordinationControl::new())
    }
}

impl ::protobuf::Message for CoordinationControlProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applicationSystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationControl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applicationSystem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationControl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationControl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationControlProfile {
        CoordinationControlProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &CoordinationControlProfile| { &m.controlMessageInfo },
                |m: &mut CoordinationControlProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ApplicationSystem>>(
                "applicationSystem",
                |m: &CoordinationControlProfile| { &m.applicationSystem },
                |m: &mut CoordinationControlProfile| { &mut m.applicationSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationControl>>(
                "coordinationControl",
                |m: &CoordinationControlProfile| { &m.coordinationControl },
                |m: &mut CoordinationControlProfile| { &mut m.coordinationControl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationControlProfile>(
                "CoordinationControlProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationControlProfile {
        static instance: ::protobuf::rt::LazyV2<CoordinationControlProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationControlProfile::new)
    }
}

impl ::protobuf::Clear for CoordinationControlProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.applicationSystem.clear();
        self.coordinationControl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationControlProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationControlProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationEventDCSC {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    CoordinationServiceMode: ::protobuf::SingularPtrField<ENG_CoordinationServiceModeKind>,
    Island: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleAuto: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleManual: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleNetzero: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleStart: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationEventDCSC {
    fn default() -> &'a CoordinationEventDCSC {
        <CoordinationEventDCSC as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationEventDCSC {
    pub fn new() -> CoordinationEventDCSC {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .coordinationservicemodule.ENG_CoordinationServiceModeKind CoordinationServiceMode = 2;


    pub fn get_CoordinationServiceMode(&self) -> &ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.as_ref().unwrap_or_else(|| <ENG_CoordinationServiceModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CoordinationServiceMode(&mut self) {
        self.CoordinationServiceMode.clear();
    }

    pub fn has_CoordinationServiceMode(&self) -> bool {
        self.CoordinationServiceMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CoordinationServiceMode(&mut self, v: ENG_CoordinationServiceModeKind) {
        self.CoordinationServiceMode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CoordinationServiceMode(&mut self) -> &mut ENG_CoordinationServiceModeKind {
        if self.CoordinationServiceMode.is_none() {
            self.CoordinationServiceMode.set_default();
        }
        self.CoordinationServiceMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_CoordinationServiceMode(&mut self) -> ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.take().unwrap_or_else(|| ENG_CoordinationServiceModeKind::new())
    }

    // .commonmodule.StatusSPS Island = 3;


    pub fn get_Island(&self) -> &super::commonmodule::StatusSPS {
        self.Island.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Island(&mut self) {
        self.Island.clear();
    }

    pub fn has_Island(&self) -> bool {
        self.Island.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Island(&mut self, v: super::commonmodule::StatusSPS) {
        self.Island = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Island(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.Island.is_none() {
            self.Island.set_default();
        }
        self.Island.as_mut().unwrap()
    }

    // Take field
    pub fn take_Island(&mut self) -> super::commonmodule::StatusSPS {
        self.Island.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleAuto = 4;


    pub fn get_PermissibleAuto(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleAuto.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleAuto(&mut self) {
        self.PermissibleAuto.clear();
    }

    pub fn has_PermissibleAuto(&self) -> bool {
        self.PermissibleAuto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleAuto(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleAuto = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleAuto(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleAuto.is_none() {
            self.PermissibleAuto.set_default();
        }
        self.PermissibleAuto.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleAuto(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleAuto.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleManual = 5;


    pub fn get_PermissibleManual(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleManual.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleManual(&mut self) {
        self.PermissibleManual.clear();
    }

    pub fn has_PermissibleManual(&self) -> bool {
        self.PermissibleManual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleManual(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleManual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleManual(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleManual.is_none() {
            self.PermissibleManual.set_default();
        }
        self.PermissibleManual.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleManual(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleManual.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleNetzero = 6;


    pub fn get_PermissibleNetzero(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleNetzero.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleNetzero(&mut self) {
        self.PermissibleNetzero.clear();
    }

    pub fn has_PermissibleNetzero(&self) -> bool {
        self.PermissibleNetzero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleNetzero(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleNetzero = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleNetzero(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleNetzero.is_none() {
            self.PermissibleNetzero.set_default();
        }
        self.PermissibleNetzero.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleNetzero(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleNetzero.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleStart = 7;


    pub fn get_PermissibleStart(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleStart.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleStart(&mut self) {
        self.PermissibleStart.clear();
    }

    pub fn has_PermissibleStart(&self) -> bool {
        self.PermissibleStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleStart(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleStart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleStart(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleStart.is_none() {
            self.PermissibleStart.set_default();
        }
        self.PermissibleStart.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleStart(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleStart.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleStop = 8;


    pub fn get_PermissibleStop(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleStop(&mut self) {
        self.PermissibleStop.clear();
    }

    pub fn has_PermissibleStop(&self) -> bool {
        self.PermissibleStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleStop.is_none() {
            self.PermissibleStop.set_default();
        }
        self.PermissibleStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleStop(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }
}

impl ::protobuf::Message for CoordinationEventDCSC {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CoordinationServiceMode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Island {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleAuto {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleManual {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleNetzero {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleStart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleStop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CoordinationServiceMode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Island)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleAuto)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleManual)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleNetzero)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleStart)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleStop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Island.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleAuto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleManual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleNetzero.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Island.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleAuto.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleManual.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleNetzero.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleStart.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleStop.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationEventDCSC {
        CoordinationEventDCSC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &CoordinationEventDCSC| { &m.logicalNodeForEventAndStatus },
                |m: &mut CoordinationEventDCSC| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_CoordinationServiceModeKind>>(
                "CoordinationServiceMode",
                |m: &CoordinationEventDCSC| { &m.CoordinationServiceMode },
                |m: &mut CoordinationEventDCSC| { &mut m.CoordinationServiceMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "Island",
                |m: &CoordinationEventDCSC| { &m.Island },
                |m: &mut CoordinationEventDCSC| { &mut m.Island },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleAuto",
                |m: &CoordinationEventDCSC| { &m.PermissibleAuto },
                |m: &mut CoordinationEventDCSC| { &mut m.PermissibleAuto },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleManual",
                |m: &CoordinationEventDCSC| { &m.PermissibleManual },
                |m: &mut CoordinationEventDCSC| { &mut m.PermissibleManual },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleNetzero",
                |m: &CoordinationEventDCSC| { &m.PermissibleNetzero },
                |m: &mut CoordinationEventDCSC| { &mut m.PermissibleNetzero },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleStart",
                |m: &CoordinationEventDCSC| { &m.PermissibleStart },
                |m: &mut CoordinationEventDCSC| { &mut m.PermissibleStart },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleStop",
                |m: &CoordinationEventDCSC| { &m.PermissibleStop },
                |m: &mut CoordinationEventDCSC| { &mut m.PermissibleStop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationEventDCSC>(
                "CoordinationEventDCSC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationEventDCSC {
        static instance: ::protobuf::rt::LazyV2<CoordinationEventDCSC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationEventDCSC::new)
    }
}

impl ::protobuf::Clear for CoordinationEventDCSC {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.CoordinationServiceMode.clear();
        self.Island.clear();
        self.PermissibleAuto.clear();
        self.PermissibleManual.clear();
        self.PermissibleNetzero.clear();
        self.PermissibleStart.clear();
        self.PermissibleStop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationEventDCSC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationEventDCSC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationEvent {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    coordinationEventDCSC: ::protobuf::SingularPtrField<CoordinationEventDCSC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationEvent {
    fn default() -> &'a CoordinationEvent {
        <CoordinationEvent as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationEvent {
    pub fn new() -> CoordinationEvent {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .coordinationservicemodule.CoordinationEventDCSC coordinationEventDCSC = 2;


    pub fn get_coordinationEventDCSC(&self) -> &CoordinationEventDCSC {
        self.coordinationEventDCSC.as_ref().unwrap_or_else(|| <CoordinationEventDCSC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationEventDCSC(&mut self) {
        self.coordinationEventDCSC.clear();
    }

    pub fn has_coordinationEventDCSC(&self) -> bool {
        self.coordinationEventDCSC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationEventDCSC(&mut self, v: CoordinationEventDCSC) {
        self.coordinationEventDCSC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationEventDCSC(&mut self) -> &mut CoordinationEventDCSC {
        if self.coordinationEventDCSC.is_none() {
            self.coordinationEventDCSC.set_default();
        }
        self.coordinationEventDCSC.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationEventDCSC(&mut self) -> CoordinationEventDCSC {
        self.coordinationEventDCSC.take().unwrap_or_else(|| CoordinationEventDCSC::new())
    }
}

impl ::protobuf::Message for CoordinationEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationEventDCSC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationEventDCSC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationEventDCSC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationEventDCSC.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationEvent {
        CoordinationEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &CoordinationEvent| { &m.eventValue },
                |m: &mut CoordinationEvent| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationEventDCSC>>(
                "coordinationEventDCSC",
                |m: &CoordinationEvent| { &m.coordinationEventDCSC },
                |m: &mut CoordinationEvent| { &mut m.coordinationEventDCSC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationEvent>(
                "CoordinationEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationEvent {
        static instance: ::protobuf::rt::LazyV2<CoordinationEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationEvent::new)
    }
}

impl ::protobuf::Clear for CoordinationEvent {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.coordinationEventDCSC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationEventProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    applicationSystem: ::protobuf::SingularPtrField<super::commonmodule::ApplicationSystem>,
    coordinationEvent: ::protobuf::SingularPtrField<CoordinationEvent>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationEventProfile {
    fn default() -> &'a CoordinationEventProfile {
        <CoordinationEventProfile as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationEventProfile {
    pub fn new() -> CoordinationEventProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .commonmodule.ApplicationSystem applicationSystem = 2;


    pub fn get_applicationSystem(&self) -> &super::commonmodule::ApplicationSystem {
        self.applicationSystem.as_ref().unwrap_or_else(|| <super::commonmodule::ApplicationSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applicationSystem(&mut self) {
        self.applicationSystem.clear();
    }

    pub fn has_applicationSystem(&self) -> bool {
        self.applicationSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applicationSystem(&mut self, v: super::commonmodule::ApplicationSystem) {
        self.applicationSystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applicationSystem(&mut self) -> &mut super::commonmodule::ApplicationSystem {
        if self.applicationSystem.is_none() {
            self.applicationSystem.set_default();
        }
        self.applicationSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_applicationSystem(&mut self) -> super::commonmodule::ApplicationSystem {
        self.applicationSystem.take().unwrap_or_else(|| super::commonmodule::ApplicationSystem::new())
    }

    // .coordinationservicemodule.CoordinationEvent coordinationEvent = 3;


    pub fn get_coordinationEvent(&self) -> &CoordinationEvent {
        self.coordinationEvent.as_ref().unwrap_or_else(|| <CoordinationEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationEvent(&mut self) {
        self.coordinationEvent.clear();
    }

    pub fn has_coordinationEvent(&self) -> bool {
        self.coordinationEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationEvent(&mut self, v: CoordinationEvent) {
        self.coordinationEvent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationEvent(&mut self) -> &mut CoordinationEvent {
        if self.coordinationEvent.is_none() {
            self.coordinationEvent.set_default();
        }
        self.coordinationEvent.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationEvent(&mut self) -> CoordinationEvent {
        self.coordinationEvent.take().unwrap_or_else(|| CoordinationEvent::new())
    }
}

impl ::protobuf::Message for CoordinationEventProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applicationSystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applicationSystem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationEvent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationEvent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationEvent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationEventProfile {
        CoordinationEventProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &CoordinationEventProfile| { &m.eventMessageInfo },
                |m: &mut CoordinationEventProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ApplicationSystem>>(
                "applicationSystem",
                |m: &CoordinationEventProfile| { &m.applicationSystem },
                |m: &mut CoordinationEventProfile| { &mut m.applicationSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationEvent>>(
                "coordinationEvent",
                |m: &CoordinationEventProfile| { &m.coordinationEvent },
                |m: &mut CoordinationEventProfile| { &mut m.coordinationEvent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationEventProfile>(
                "CoordinationEventProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationEventProfile {
        static instance: ::protobuf::rt::LazyV2<CoordinationEventProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationEventProfile::new)
    }
}

impl ::protobuf::Clear for CoordinationEventProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.applicationSystem.clear();
        self.coordinationEvent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationEventProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationEventProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationStatusDCSC {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    CoordinationServiceMode: ::protobuf::SingularPtrField<ENG_CoordinationServiceModeKind>,
    Island: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleAuto: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleManual: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleNetzero: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleStart: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PermissibleStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationStatusDCSC {
    fn default() -> &'a CoordinationStatusDCSC {
        <CoordinationStatusDCSC as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationStatusDCSC {
    pub fn new() -> CoordinationStatusDCSC {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .coordinationservicemodule.ENG_CoordinationServiceModeKind CoordinationServiceMode = 2;


    pub fn get_CoordinationServiceMode(&self) -> &ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.as_ref().unwrap_or_else(|| <ENG_CoordinationServiceModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CoordinationServiceMode(&mut self) {
        self.CoordinationServiceMode.clear();
    }

    pub fn has_CoordinationServiceMode(&self) -> bool {
        self.CoordinationServiceMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CoordinationServiceMode(&mut self, v: ENG_CoordinationServiceModeKind) {
        self.CoordinationServiceMode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CoordinationServiceMode(&mut self) -> &mut ENG_CoordinationServiceModeKind {
        if self.CoordinationServiceMode.is_none() {
            self.CoordinationServiceMode.set_default();
        }
        self.CoordinationServiceMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_CoordinationServiceMode(&mut self) -> ENG_CoordinationServiceModeKind {
        self.CoordinationServiceMode.take().unwrap_or_else(|| ENG_CoordinationServiceModeKind::new())
    }

    // .commonmodule.StatusSPS Island = 3;


    pub fn get_Island(&self) -> &super::commonmodule::StatusSPS {
        self.Island.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Island(&mut self) {
        self.Island.clear();
    }

    pub fn has_Island(&self) -> bool {
        self.Island.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Island(&mut self, v: super::commonmodule::StatusSPS) {
        self.Island = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Island(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.Island.is_none() {
            self.Island.set_default();
        }
        self.Island.as_mut().unwrap()
    }

    // Take field
    pub fn take_Island(&mut self) -> super::commonmodule::StatusSPS {
        self.Island.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleAuto = 4;


    pub fn get_PermissibleAuto(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleAuto.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleAuto(&mut self) {
        self.PermissibleAuto.clear();
    }

    pub fn has_PermissibleAuto(&self) -> bool {
        self.PermissibleAuto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleAuto(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleAuto = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleAuto(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleAuto.is_none() {
            self.PermissibleAuto.set_default();
        }
        self.PermissibleAuto.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleAuto(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleAuto.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleManual = 5;


    pub fn get_PermissibleManual(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleManual.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleManual(&mut self) {
        self.PermissibleManual.clear();
    }

    pub fn has_PermissibleManual(&self) -> bool {
        self.PermissibleManual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleManual(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleManual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleManual(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleManual.is_none() {
            self.PermissibleManual.set_default();
        }
        self.PermissibleManual.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleManual(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleManual.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleNetzero = 6;


    pub fn get_PermissibleNetzero(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleNetzero.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleNetzero(&mut self) {
        self.PermissibleNetzero.clear();
    }

    pub fn has_PermissibleNetzero(&self) -> bool {
        self.PermissibleNetzero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleNetzero(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleNetzero = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleNetzero(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleNetzero.is_none() {
            self.PermissibleNetzero.set_default();
        }
        self.PermissibleNetzero.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleNetzero(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleNetzero.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleStart = 7;


    pub fn get_PermissibleStart(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleStart.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleStart(&mut self) {
        self.PermissibleStart.clear();
    }

    pub fn has_PermissibleStart(&self) -> bool {
        self.PermissibleStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleStart(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleStart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleStart(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleStart.is_none() {
            self.PermissibleStart.set_default();
        }
        self.PermissibleStart.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleStart(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleStart.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS PermissibleStop = 8;


    pub fn get_PermissibleStop(&self) -> &super::commonmodule::StatusSPS {
        self.PermissibleStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PermissibleStop(&mut self) {
        self.PermissibleStop.clear();
    }

    pub fn has_PermissibleStop(&self) -> bool {
        self.PermissibleStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PermissibleStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.PermissibleStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PermissibleStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.PermissibleStop.is_none() {
            self.PermissibleStop.set_default();
        }
        self.PermissibleStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_PermissibleStop(&mut self) -> super::commonmodule::StatusSPS {
        self.PermissibleStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }
}

impl ::protobuf::Message for CoordinationStatusDCSC {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CoordinationServiceMode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Island {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleAuto {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleManual {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleNetzero {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleStart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PermissibleStop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CoordinationServiceMode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Island)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleAuto)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleManual)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleNetzero)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleStart)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PermissibleStop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Island.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleAuto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleManual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleNetzero.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PermissibleStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CoordinationServiceMode.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Island.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleAuto.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleManual.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleNetzero.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleStart.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PermissibleStop.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationStatusDCSC {
        CoordinationStatusDCSC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &CoordinationStatusDCSC| { &m.logicalNodeForEventAndStatus },
                |m: &mut CoordinationStatusDCSC| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ENG_CoordinationServiceModeKind>>(
                "CoordinationServiceMode",
                |m: &CoordinationStatusDCSC| { &m.CoordinationServiceMode },
                |m: &mut CoordinationStatusDCSC| { &mut m.CoordinationServiceMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "Island",
                |m: &CoordinationStatusDCSC| { &m.Island },
                |m: &mut CoordinationStatusDCSC| { &mut m.Island },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleAuto",
                |m: &CoordinationStatusDCSC| { &m.PermissibleAuto },
                |m: &mut CoordinationStatusDCSC| { &mut m.PermissibleAuto },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleManual",
                |m: &CoordinationStatusDCSC| { &m.PermissibleManual },
                |m: &mut CoordinationStatusDCSC| { &mut m.PermissibleManual },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleNetzero",
                |m: &CoordinationStatusDCSC| { &m.PermissibleNetzero },
                |m: &mut CoordinationStatusDCSC| { &mut m.PermissibleNetzero },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleStart",
                |m: &CoordinationStatusDCSC| { &m.PermissibleStart },
                |m: &mut CoordinationStatusDCSC| { &mut m.PermissibleStart },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "PermissibleStop",
                |m: &CoordinationStatusDCSC| { &m.PermissibleStop },
                |m: &mut CoordinationStatusDCSC| { &mut m.PermissibleStop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationStatusDCSC>(
                "CoordinationStatusDCSC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationStatusDCSC {
        static instance: ::protobuf::rt::LazyV2<CoordinationStatusDCSC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationStatusDCSC::new)
    }
}

impl ::protobuf::Clear for CoordinationStatusDCSC {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.CoordinationServiceMode.clear();
        self.Island.clear();
        self.PermissibleAuto.clear();
        self.PermissibleManual.clear();
        self.PermissibleNetzero.clear();
        self.PermissibleStart.clear();
        self.PermissibleStop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationStatusDCSC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationStatusDCSC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationStatus {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    coordinationStatusDCSC: ::protobuf::SingularPtrField<CoordinationStatusDCSC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationStatus {
    fn default() -> &'a CoordinationStatus {
        <CoordinationStatus as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationStatus {
    pub fn new() -> CoordinationStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .coordinationservicemodule.CoordinationStatusDCSC coordinationStatusDCSC = 2;


    pub fn get_coordinationStatusDCSC(&self) -> &CoordinationStatusDCSC {
        self.coordinationStatusDCSC.as_ref().unwrap_or_else(|| <CoordinationStatusDCSC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationStatusDCSC(&mut self) {
        self.coordinationStatusDCSC.clear();
    }

    pub fn has_coordinationStatusDCSC(&self) -> bool {
        self.coordinationStatusDCSC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationStatusDCSC(&mut self, v: CoordinationStatusDCSC) {
        self.coordinationStatusDCSC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationStatusDCSC(&mut self) -> &mut CoordinationStatusDCSC {
        if self.coordinationStatusDCSC.is_none() {
            self.coordinationStatusDCSC.set_default();
        }
        self.coordinationStatusDCSC.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationStatusDCSC(&mut self) -> CoordinationStatusDCSC {
        self.coordinationStatusDCSC.take().unwrap_or_else(|| CoordinationStatusDCSC::new())
    }
}

impl ::protobuf::Message for CoordinationStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationStatusDCSC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationStatusDCSC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationStatusDCSC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationStatusDCSC.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationStatus {
        CoordinationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &CoordinationStatus| { &m.eventValue },
                |m: &mut CoordinationStatus| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationStatusDCSC>>(
                "coordinationStatusDCSC",
                |m: &CoordinationStatus| { &m.coordinationStatusDCSC },
                |m: &mut CoordinationStatus| { &mut m.coordinationStatusDCSC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationStatus>(
                "CoordinationStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationStatus {
        static instance: ::protobuf::rt::LazyV2<CoordinationStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationStatus::new)
    }
}

impl ::protobuf::Clear for CoordinationStatus {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.coordinationStatusDCSC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CoordinationStatusProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    applicationSystem: ::protobuf::SingularPtrField<super::commonmodule::ApplicationSystem>,
    coordinationStatus: ::protobuf::SingularPtrField<CoordinationStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoordinationStatusProfile {
    fn default() -> &'a CoordinationStatusProfile {
        <CoordinationStatusProfile as ::protobuf::Message>::default_instance()
    }
}

impl CoordinationStatusProfile {
    pub fn new() -> CoordinationStatusProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .commonmodule.ApplicationSystem applicationSystem = 2;


    pub fn get_applicationSystem(&self) -> &super::commonmodule::ApplicationSystem {
        self.applicationSystem.as_ref().unwrap_or_else(|| <super::commonmodule::ApplicationSystem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_applicationSystem(&mut self) {
        self.applicationSystem.clear();
    }

    pub fn has_applicationSystem(&self) -> bool {
        self.applicationSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_applicationSystem(&mut self, v: super::commonmodule::ApplicationSystem) {
        self.applicationSystem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_applicationSystem(&mut self) -> &mut super::commonmodule::ApplicationSystem {
        if self.applicationSystem.is_none() {
            self.applicationSystem.set_default();
        }
        self.applicationSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_applicationSystem(&mut self) -> super::commonmodule::ApplicationSystem {
        self.applicationSystem.take().unwrap_or_else(|| super::commonmodule::ApplicationSystem::new())
    }

    // .coordinationservicemodule.CoordinationStatus coordinationStatus = 3;


    pub fn get_coordinationStatus(&self) -> &CoordinationStatus {
        self.coordinationStatus.as_ref().unwrap_or_else(|| <CoordinationStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_coordinationStatus(&mut self) {
        self.coordinationStatus.clear();
    }

    pub fn has_coordinationStatus(&self) -> bool {
        self.coordinationStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coordinationStatus(&mut self, v: CoordinationStatus) {
        self.coordinationStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coordinationStatus(&mut self) -> &mut CoordinationStatus {
        if self.coordinationStatus.is_none() {
            self.coordinationStatus.set_default();
        }
        self.coordinationStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_coordinationStatus(&mut self) -> CoordinationStatus {
        self.coordinationStatus.take().unwrap_or_else(|| CoordinationStatus::new())
    }
}

impl ::protobuf::Message for CoordinationStatusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.applicationSystem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coordinationStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.applicationSystem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coordinationStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.coordinationStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.applicationSystem.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.coordinationStatus.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoordinationStatusProfile {
        CoordinationStatusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &CoordinationStatusProfile| { &m.eventMessageInfo },
                |m: &mut CoordinationStatusProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ApplicationSystem>>(
                "applicationSystem",
                |m: &CoordinationStatusProfile| { &m.applicationSystem },
                |m: &mut CoordinationStatusProfile| { &mut m.applicationSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CoordinationStatus>>(
                "coordinationStatus",
                |m: &CoordinationStatusProfile| { &m.coordinationStatus },
                |m: &mut CoordinationStatusProfile| { &mut m.coordinationStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoordinationStatusProfile>(
                "CoordinationStatusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoordinationStatusProfile {
        static instance: ::protobuf::rt::LazyV2<CoordinationStatusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoordinationStatusProfile::new)
    }
}

impl ::protobuf::Clear for CoordinationStatusProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.applicationSystem.clear();
        self.coordinationStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoordinationStatusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationStatusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CoordinationServiceModeKind {
    CoordinationServiceModeKind_none = 0,
    CoordinationServiceModeKind_auto = 1,
    CoordinationServiceModeKind_manual = 2,
    CoordinationServiceModeKind_netzero = 3,
    CoordinationServiceModeKind_start = 4,
    CoordinationServiceModeKind_stop = 5,
}

impl ::protobuf::ProtobufEnum for CoordinationServiceModeKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CoordinationServiceModeKind> {
        match value {
            0 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_none),
            1 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_auto),
            2 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_manual),
            3 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_netzero),
            4 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_start),
            5 => ::std::option::Option::Some(CoordinationServiceModeKind::CoordinationServiceModeKind_stop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CoordinationServiceModeKind] = &[
            CoordinationServiceModeKind::CoordinationServiceModeKind_none,
            CoordinationServiceModeKind::CoordinationServiceModeKind_auto,
            CoordinationServiceModeKind::CoordinationServiceModeKind_manual,
            CoordinationServiceModeKind::CoordinationServiceModeKind_netzero,
            CoordinationServiceModeKind::CoordinationServiceModeKind_start,
            CoordinationServiceModeKind::CoordinationServiceModeKind_stop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CoordinationServiceModeKind>("CoordinationServiceModeKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CoordinationServiceModeKind {
}

impl ::std::default::Default for CoordinationServiceModeKind {
    fn default() -> Self {
        CoordinationServiceModeKind::CoordinationServiceModeKind_none
    }
}

impl ::protobuf::reflect::ProtobufValue for CoordinationServiceModeKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n9coordinationservicemodule/coordinationservicemodule.proto\x12\x19coor\
    dinationservicemodule\"x\n$Optional_CoordinationServiceModeKind\x12N\n\
    \x05value\x18\x01\x20\x01(\x0e26.coordinationservicemodule.CoordinationS\
    erviceModeKindR\x05valueB\0:\0\"\xc7\x01\n\x1fENG_CoordinationServiceMod\
    eKind\x12X\n\x06setVal\x18\x01\x20\x01(\x0e26.coordinationservicemodule.\
    CoordinationServiceModeKindR\x06setValB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12H\n\x0fsetValExtension\x18\x02\x20\x01(\x0b2\x1c.google.protobuf\
    .StringValueR\x0fsetValExtensionB\0:\0\"\xa8\x02\n\x17CoordinationContro\
    lDCSC\x12_\n\x15logicalNodeForControl\x18\x01\x20\x01(\x0b2#.commonmodul\
    e.LogicalNodeForControlR\x15logicalNodeForControlB\x04\x80\xb5\x18\x01\
    \x12v\n\x17CoordinationServiceMode\x18\x02\x20\x01(\x0b2:.coordinationse\
    rvicemodule.ENG_CoordinationServiceModeKindR\x17CoordinationServiceModeB\
    \0\x122\n\x06Island\x18\x03\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x06IslandB\0:\0\"\x8c\x02\n\x13CoordinationControl\x12D\n\x0ccontrolVal\
    ue\x18\x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\x0ccontrolValueB\
    \x04\x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\x0b2\x1d.commonmod\
    ule.CheckConditionsR\x05checkB\0\x12v\n\x17coordinationControlDCSC\x18\
    \x03\x20\x01(\x0b22.coordinationservicemodule.CoordinationControlDCSCR\
    \x17coordinationControlDCSCB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\
    \xbf\x02\n\x1aCoordinationControlProfile\x12V\n\x12controlMessageInfo\
    \x18\x01\x20\x01(\x0b2\x20.commonmodule.ControlMessageInfoR\x12controlMe\
    ssageInfoB\x04\x80\xb5\x18\x01\x12W\n\x11applicationSystem\x18\x02\x20\
    \x01(\x0b2\x1f.commonmodule.ApplicationSystemR\x11applicationSystemB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x12j\n\x13coordinationControl\x18\x03\
    \x20\x01(\x0b2..coordinationservicemodule.CoordinationControlR\x13coordi\
    nationControlB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\x01\
    \"\x9f\x05\n\x15CoordinationEventDCSC\x12t\n\x1clogicalNodeForEventAndSt\
    atus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeForEventAndStatusR\
    \x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\x12v\n\x17Coordina\
    tionServiceMode\x18\x02\x20\x01(\x0b2:.coordinationservicemodule.ENG_Coo\
    rdinationServiceModeKindR\x17CoordinationServiceModeB\0\x121\n\x06Island\
    \x18\x03\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x06IslandB\0\x12C\n\
    \x0fPermissibleAuto\x18\x04\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\
    \x0fPermissibleAutoB\0\x12G\n\x11PermissibleManual\x18\x05\x20\x01(\x0b2\
    \x17.commonmodule.StatusSPSR\x11PermissibleManualB\0\x12I\n\x12Permissib\
    leNetzero\x18\x06\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x12Permissib\
    leNetzeroB\0\x12E\n\x10PermissibleStart\x18\x07\x20\x01(\x0b2\x17.common\
    module.StatusSPSR\x10PermissibleStartB\0\x12C\n\x0fPermissibleStop\x18\
    \x08\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x0fPermissibleStopB\0:\0\
    \"\xc7\x01\n\x11CoordinationEvent\x12>\n\neventValue\x18\x01\x20\x01(\
    \x0b2\x18.commonmodule.EventValueR\neventValueB\x04\x80\xb5\x18\x01\x12p\
    \n\x15coordinationEventDCSC\x18\x02\x20\x01(\x0b20.coordinationservicemo\
    dule.CoordinationEventDCSCR\x15coordinationEventDCSCB\x08\x88\xb5\x18\
    \x01\x90\xb5\x18\x01:\0\"\xb1\x02\n\x18CoordinationEventProfile\x12P\n\
    \x10eventMessageInfo\x18\x01\x20\x01(\x0b2\x1e.commonmodule.EventMessage\
    InfoR\x10eventMessageInfoB\x04\x80\xb5\x18\x01\x12W\n\x11applicationSyst\
    em\x18\x02\x20\x01(\x0b2\x1f.commonmodule.ApplicationSystemR\x11applicat\
    ionSystemB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12d\n\x11coordinationEve\
    nt\x18\x03\x20\x01(\x0b2,.coordinationservicemodule.CoordinationEventR\
    \x11coordinationEventB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\x04\xc0\xf3\
    \x18\x01\"\xa0\x05\n\x16CoordinationStatusDCSC\x12t\n\x1clogicalNodeForE\
    ventAndStatus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeForEventAnd\
    StatusR\x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\x12v\n\x17C\
    oordinationServiceMode\x18\x02\x20\x01(\x0b2:.coordinationservicemodule.\
    ENG_CoordinationServiceModeKindR\x17CoordinationServiceModeB\0\x121\n\
    \x06Island\x18\x03\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x06IslandB\
    \0\x12C\n\x0fPermissibleAuto\x18\x04\x20\x01(\x0b2\x17.commonmodule.Stat\
    usSPSR\x0fPermissibleAutoB\0\x12G\n\x11PermissibleManual\x18\x05\x20\x01\
    (\x0b2\x17.commonmodule.StatusSPSR\x11PermissibleManualB\0\x12I\n\x12Per\
    missibleNetzero\x18\x06\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x12Per\
    missibleNetzeroB\0\x12E\n\x10PermissibleStart\x18\x07\x20\x01(\x0b2\x17.\
    commonmodule.StatusSPSR\x10PermissibleStartB\0\x12C\n\x0fPermissibleStop\
    \x18\x08\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x0fPermissibleStopB\0\
    :\0\"\xcb\x01\n\x12CoordinationStatus\x12>\n\neventValue\x18\x01\x20\x01\
    (\x0b2\x18.commonmodule.EventValueR\neventValueB\x04\x80\xb5\x18\x01\x12\
    s\n\x16coordinationStatusDCSC\x18\x02\x20\x01(\x0b21.coordinationservice\
    module.CoordinationStatusDCSCR\x16coordinationStatusDCSCB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"\xb5\x02\n\x19CoordinationStatusProfile\x12\
    P\n\x10eventMessageInfo\x18\x01\x20\x01(\x0b2\x1e.commonmodule.EventMess\
    ageInfoR\x10eventMessageInfoB\x04\x80\xb5\x18\x01\x12W\n\x11applicationS\
    ystem\x18\x02\x20\x01(\x0b2\x1f.commonmodule.ApplicationSystemR\x11appli\
    cationSystemB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12g\n\x12coordination\
    Status\x18\x03\x20\x01(\x0b2-.coordinationservicemodule.CoordinationStat\
    usR\x12coordinationStatusB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\
    \xf3\x18\x01*\x89\x02\n\x1bCoordinationServiceModeKind\x12$\n\x20Coordin\
    ationServiceModeKind_none\x10\0\x12$\n\x20CoordinationServiceModeKind_au\
    to\x10\x01\x12&\n\"CoordinationServiceModeKind_manual\x10\x02\x12'\n#Coo\
    rdinationServiceModeKind_netzero\x10\x03\x12%\n!CoordinationServiceModeK\
    ind_start\x10\x04\x12$\n\x20CoordinationServiceModeKind_stop\x10\x05\x1a\
    \0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
