// SPDX-FileCopyrightText: 2021 Open Energy Solutions Inc
//
// SPDX-License-Identifier: Apache-2.0

// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `essmodule/essmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EssEventZBAT {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    BatHi: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    BatLo: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    BatSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    Soc: ::protobuf::SingularPtrField<super::commonmodule::MV>,
    Stdby: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EssEventZBAT {
    fn default() -> &'a EssEventZBAT {
        <EssEventZBAT as ::protobuf::Message>::default_instance()
    }
}

impl EssEventZBAT {
    pub fn new() -> EssEventZBAT {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.StatusSPS BatHi = 2;


    pub fn get_BatHi(&self) -> &super::commonmodule::StatusSPS {
        self.BatHi.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_BatHi(&mut self) {
        self.BatHi.clear();
    }

    pub fn has_BatHi(&self) -> bool {
        self.BatHi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BatHi(&mut self, v: super::commonmodule::StatusSPS) {
        self.BatHi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BatHi(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.BatHi.is_none() {
            self.BatHi.set_default();
        }
        self.BatHi.as_mut().unwrap()
    }

    // Take field
    pub fn take_BatHi(&mut self) -> super::commonmodule::StatusSPS {
        self.BatHi.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS BatLo = 3;


    pub fn get_BatLo(&self) -> &super::commonmodule::StatusSPS {
        self.BatLo.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_BatLo(&mut self) {
        self.BatLo.clear();
    }

    pub fn has_BatLo(&self) -> bool {
        self.BatLo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BatLo(&mut self, v: super::commonmodule::StatusSPS) {
        self.BatLo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BatLo(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.BatLo.is_none() {
            self.BatLo.set_default();
        }
        self.BatLo.as_mut().unwrap()
    }

    // Take field
    pub fn take_BatLo(&mut self) -> super::commonmodule::StatusSPS {
        self.BatLo.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS BatSt = 4;


    pub fn get_BatSt(&self) -> &super::commonmodule::StatusSPS {
        self.BatSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_BatSt(&mut self) {
        self.BatSt.clear();
    }

    pub fn has_BatSt(&self) -> bool {
        self.BatSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BatSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.BatSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BatSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.BatSt.is_none() {
            self.BatSt.set_default();
        }
        self.BatSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_BatSt(&mut self) -> super::commonmodule::StatusSPS {
        self.BatSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.MV Soc = 5;


    pub fn get_Soc(&self) -> &super::commonmodule::MV {
        self.Soc.as_ref().unwrap_or_else(|| <super::commonmodule::MV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Soc(&mut self) {
        self.Soc.clear();
    }

    pub fn has_Soc(&self) -> bool {
        self.Soc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Soc(&mut self, v: super::commonmodule::MV) {
        self.Soc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Soc(&mut self) -> &mut super::commonmodule::MV {
        if self.Soc.is_none() {
            self.Soc.set_default();
        }
        self.Soc.as_mut().unwrap()
    }

    // Take field
    pub fn take_Soc(&mut self) -> super::commonmodule::MV {
        self.Soc.take().unwrap_or_else(|| super::commonmodule::MV::new())
    }

    // .commonmodule.StatusSPS Stdby = 6;


    pub fn get_Stdby(&self) -> &super::commonmodule::StatusSPS {
        self.Stdby.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Stdby(&mut self) {
        self.Stdby.clear();
    }

    pub fn has_Stdby(&self) -> bool {
        self.Stdby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Stdby(&mut self, v: super::commonmodule::StatusSPS) {
        self.Stdby = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Stdby(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.Stdby.is_none() {
            self.Stdby.set_default();
        }
        self.Stdby.as_mut().unwrap()
    }

    // Take field
    pub fn take_Stdby(&mut self) -> super::commonmodule::StatusSPS {
        self.Stdby.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }
}

impl ::protobuf::Message for EssEventZBAT {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BatHi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BatLo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BatSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Soc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Stdby {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BatHi)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BatLo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BatSt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Soc)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Stdby)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BatHi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BatLo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BatSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Soc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Stdby.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BatHi.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BatLo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BatSt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Soc.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Stdby.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EssEventZBAT {
        EssEventZBAT::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &EssEventZBAT| { &m.logicalNodeForEventAndStatus },
                |m: &mut EssEventZBAT| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "BatHi",
                |m: &EssEventZBAT| { &m.BatHi },
                |m: &mut EssEventZBAT| { &mut m.BatHi },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "BatLo",
                |m: &EssEventZBAT| { &m.BatLo },
                |m: &mut EssEventZBAT| { &mut m.BatLo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "BatSt",
                |m: &EssEventZBAT| { &m.BatSt },
                |m: &mut EssEventZBAT| { &mut m.BatSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::MV>>(
                "Soc",
                |m: &EssEventZBAT| { &m.Soc },
                |m: &mut EssEventZBAT| { &mut m.Soc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "Stdby",
                |m: &EssEventZBAT| { &m.Stdby },
                |m: &mut EssEventZBAT| { &mut m.Stdby },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EssEventZBAT>(
                "EssEventZBAT",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EssEventZBAT {
        static instance: ::protobuf::rt::LazyV2<EssEventZBAT> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EssEventZBAT::new)
    }
}

impl ::protobuf::Clear for EssEventZBAT {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.BatHi.clear();
        self.BatLo.clear();
        self.BatSt.clear();
        self.Soc.clear();
        self.Stdby.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EssEventZBAT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EssEventZBAT {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FrequencyRegulation {
    // message fields
    frequencyDeadBandMinus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    frequencyDeadBandPlus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    frequencyRegulationCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    frequencySetPoint: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    gridFrequencyStableBandMinus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    gridFrequencyStableBandPlus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    overFrequencyDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    underFrequencyDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FrequencyRegulation {
    fn default() -> &'a FrequencyRegulation {
        <FrequencyRegulation as ::protobuf::Message>::default_instance()
    }
}

impl FrequencyRegulation {
    pub fn new() -> FrequencyRegulation {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue frequencyDeadBandMinus = 1;


    pub fn get_frequencyDeadBandMinus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.frequencyDeadBandMinus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencyDeadBandMinus(&mut self) {
        self.frequencyDeadBandMinus.clear();
    }

    pub fn has_frequencyDeadBandMinus(&self) -> bool {
        self.frequencyDeadBandMinus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencyDeadBandMinus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.frequencyDeadBandMinus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencyDeadBandMinus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.frequencyDeadBandMinus.is_none() {
            self.frequencyDeadBandMinus.set_default();
        }
        self.frequencyDeadBandMinus.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencyDeadBandMinus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.frequencyDeadBandMinus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue frequencyDeadBandPlus = 2;


    pub fn get_frequencyDeadBandPlus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.frequencyDeadBandPlus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencyDeadBandPlus(&mut self) {
        self.frequencyDeadBandPlus.clear();
    }

    pub fn has_frequencyDeadBandPlus(&self) -> bool {
        self.frequencyDeadBandPlus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencyDeadBandPlus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.frequencyDeadBandPlus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencyDeadBandPlus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.frequencyDeadBandPlus.is_none() {
            self.frequencyDeadBandPlus.set_default();
        }
        self.frequencyDeadBandPlus.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencyDeadBandPlus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.frequencyDeadBandPlus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.BoolValue frequencyRegulationCtl = 3;


    pub fn get_frequencyRegulationCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.frequencyRegulationCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencyRegulationCtl(&mut self) {
        self.frequencyRegulationCtl.clear();
    }

    pub fn has_frequencyRegulationCtl(&self) -> bool {
        self.frequencyRegulationCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencyRegulationCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.frequencyRegulationCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencyRegulationCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.frequencyRegulationCtl.is_none() {
            self.frequencyRegulationCtl.set_default();
        }
        self.frequencyRegulationCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencyRegulationCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.frequencyRegulationCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.FloatValue frequencySetPoint = 4;


    pub fn get_frequencySetPoint(&self) -> &::protobuf::well_known_types::FloatValue {
        self.frequencySetPoint.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPoint(&mut self) {
        self.frequencySetPoint.clear();
    }

    pub fn has_frequencySetPoint(&self) -> bool {
        self.frequencySetPoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPoint(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.frequencySetPoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPoint(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.frequencySetPoint.is_none() {
            self.frequencySetPoint.set_default();
        }
        self.frequencySetPoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPoint(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.frequencySetPoint.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue gridFrequencyStableBandMinus = 5;


    pub fn get_gridFrequencyStableBandMinus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.gridFrequencyStableBandMinus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gridFrequencyStableBandMinus(&mut self) {
        self.gridFrequencyStableBandMinus.clear();
    }

    pub fn has_gridFrequencyStableBandMinus(&self) -> bool {
        self.gridFrequencyStableBandMinus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gridFrequencyStableBandMinus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.gridFrequencyStableBandMinus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gridFrequencyStableBandMinus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.gridFrequencyStableBandMinus.is_none() {
            self.gridFrequencyStableBandMinus.set_default();
        }
        self.gridFrequencyStableBandMinus.as_mut().unwrap()
    }

    // Take field
    pub fn take_gridFrequencyStableBandMinus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.gridFrequencyStableBandMinus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue gridFrequencyStableBandPlus = 6;


    pub fn get_gridFrequencyStableBandPlus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.gridFrequencyStableBandPlus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gridFrequencyStableBandPlus(&mut self) {
        self.gridFrequencyStableBandPlus.clear();
    }

    pub fn has_gridFrequencyStableBandPlus(&self) -> bool {
        self.gridFrequencyStableBandPlus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gridFrequencyStableBandPlus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.gridFrequencyStableBandPlus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gridFrequencyStableBandPlus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.gridFrequencyStableBandPlus.is_none() {
            self.gridFrequencyStableBandPlus.set_default();
        }
        self.gridFrequencyStableBandPlus.as_mut().unwrap()
    }

    // Take field
    pub fn take_gridFrequencyStableBandPlus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.gridFrequencyStableBandPlus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue overFrequencyDroop = 7;


    pub fn get_overFrequencyDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.overFrequencyDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overFrequencyDroop(&mut self) {
        self.overFrequencyDroop.clear();
    }

    pub fn has_overFrequencyDroop(&self) -> bool {
        self.overFrequencyDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overFrequencyDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.overFrequencyDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overFrequencyDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.overFrequencyDroop.is_none() {
            self.overFrequencyDroop.set_default();
        }
        self.overFrequencyDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_overFrequencyDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.overFrequencyDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue underFrequencyDroop = 8;


    pub fn get_underFrequencyDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.underFrequencyDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_underFrequencyDroop(&mut self) {
        self.underFrequencyDroop.clear();
    }

    pub fn has_underFrequencyDroop(&self) -> bool {
        self.underFrequencyDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underFrequencyDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.underFrequencyDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_underFrequencyDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.underFrequencyDroop.is_none() {
            self.underFrequencyDroop.set_default();
        }
        self.underFrequencyDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_underFrequencyDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.underFrequencyDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for FrequencyRegulation {
    fn is_initialized(&self) -> bool {
        for v in &self.frequencyDeadBandMinus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencyDeadBandPlus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencyRegulationCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPoint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gridFrequencyStableBandMinus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gridFrequencyStableBandPlus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overFrequencyDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.underFrequencyDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencyDeadBandMinus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencyDeadBandPlus)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencyRegulationCtl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPoint)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gridFrequencyStableBandMinus)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gridFrequencyStableBandPlus)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overFrequencyDroop)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.underFrequencyDroop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.frequencyDeadBandMinus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencyDeadBandPlus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencyRegulationCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gridFrequencyStableBandMinus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gridFrequencyStableBandPlus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overFrequencyDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.underFrequencyDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.frequencyDeadBandMinus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencyDeadBandPlus.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencyRegulationCtl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPoint.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gridFrequencyStableBandMinus.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gridFrequencyStableBandPlus.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overFrequencyDroop.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.underFrequencyDroop.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FrequencyRegulation {
        FrequencyRegulation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "frequencyDeadBandMinus",
                |m: &FrequencyRegulation| { &m.frequencyDeadBandMinus },
                |m: &mut FrequencyRegulation| { &mut m.frequencyDeadBandMinus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "frequencyDeadBandPlus",
                |m: &FrequencyRegulation| { &m.frequencyDeadBandPlus },
                |m: &mut FrequencyRegulation| { &mut m.frequencyDeadBandPlus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "frequencyRegulationCtl",
                |m: &FrequencyRegulation| { &m.frequencyRegulationCtl },
                |m: &mut FrequencyRegulation| { &mut m.frequencyRegulationCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "frequencySetPoint",
                |m: &FrequencyRegulation| { &m.frequencySetPoint },
                |m: &mut FrequencyRegulation| { &mut m.frequencySetPoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "gridFrequencyStableBandMinus",
                |m: &FrequencyRegulation| { &m.gridFrequencyStableBandMinus },
                |m: &mut FrequencyRegulation| { &mut m.gridFrequencyStableBandMinus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "gridFrequencyStableBandPlus",
                |m: &FrequencyRegulation| { &m.gridFrequencyStableBandPlus },
                |m: &mut FrequencyRegulation| { &mut m.gridFrequencyStableBandPlus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "overFrequencyDroop",
                |m: &FrequencyRegulation| { &m.overFrequencyDroop },
                |m: &mut FrequencyRegulation| { &mut m.overFrequencyDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "underFrequencyDroop",
                |m: &FrequencyRegulation| { &m.underFrequencyDroop },
                |m: &mut FrequencyRegulation| { &mut m.underFrequencyDroop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FrequencyRegulation>(
                "FrequencyRegulation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FrequencyRegulation {
        static instance: ::protobuf::rt::LazyV2<FrequencyRegulation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FrequencyRegulation::new)
    }
}

impl ::protobuf::Clear for FrequencyRegulation {
    fn clear(&mut self) {
        self.frequencyDeadBandMinus.clear();
        self.frequencyDeadBandPlus.clear();
        self.frequencyRegulationCtl.clear();
        self.frequencySetPoint.clear();
        self.gridFrequencyStableBandMinus.clear();
        self.gridFrequencyStableBandPlus.clear();
        self.overFrequencyDroop.clear();
        self.underFrequencyDroop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrequencyRegulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrequencyRegulation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PeakShaving {
    // message fields
    baseShavingLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    peakShavingCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    peakShavingLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socManagementAllowedHighLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socManagementAllowedLowLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeakShaving {
    fn default() -> &'a PeakShaving {
        <PeakShaving as ::protobuf::Message>::default_instance()
    }
}

impl PeakShaving {
    pub fn new() -> PeakShaving {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue baseShavingLimit = 1;


    pub fn get_baseShavingLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.baseShavingLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_baseShavingLimit(&mut self) {
        self.baseShavingLimit.clear();
    }

    pub fn has_baseShavingLimit(&self) -> bool {
        self.baseShavingLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseShavingLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.baseShavingLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseShavingLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.baseShavingLimit.is_none() {
            self.baseShavingLimit.set_default();
        }
        self.baseShavingLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_baseShavingLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.baseShavingLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.BoolValue peakShavingCtl = 2;


    pub fn get_peakShavingCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.peakShavingCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_peakShavingCtl(&mut self) {
        self.peakShavingCtl.clear();
    }

    pub fn has_peakShavingCtl(&self) -> bool {
        self.peakShavingCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peakShavingCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.peakShavingCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peakShavingCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.peakShavingCtl.is_none() {
            self.peakShavingCtl.set_default();
        }
        self.peakShavingCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_peakShavingCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.peakShavingCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.FloatValue peakShavingLimit = 3;


    pub fn get_peakShavingLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.peakShavingLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_peakShavingLimit(&mut self) {
        self.peakShavingLimit.clear();
    }

    pub fn has_peakShavingLimit(&self) -> bool {
        self.peakShavingLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peakShavingLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.peakShavingLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peakShavingLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.peakShavingLimit.is_none() {
            self.peakShavingLimit.set_default();
        }
        self.peakShavingLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_peakShavingLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.peakShavingLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socManagementAllowedHighLimit = 4;


    pub fn get_socManagementAllowedHighLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socManagementAllowedHighLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socManagementAllowedHighLimit(&mut self) {
        self.socManagementAllowedHighLimit.clear();
    }

    pub fn has_socManagementAllowedHighLimit(&self) -> bool {
        self.socManagementAllowedHighLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socManagementAllowedHighLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socManagementAllowedHighLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socManagementAllowedHighLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socManagementAllowedHighLimit.is_none() {
            self.socManagementAllowedHighLimit.set_default();
        }
        self.socManagementAllowedHighLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_socManagementAllowedHighLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socManagementAllowedHighLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socManagementAllowedLowLimit = 5;


    pub fn get_socManagementAllowedLowLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socManagementAllowedLowLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socManagementAllowedLowLimit(&mut self) {
        self.socManagementAllowedLowLimit.clear();
    }

    pub fn has_socManagementAllowedLowLimit(&self) -> bool {
        self.socManagementAllowedLowLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socManagementAllowedLowLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socManagementAllowedLowLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socManagementAllowedLowLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socManagementAllowedLowLimit.is_none() {
            self.socManagementAllowedLowLimit.set_default();
        }
        self.socManagementAllowedLowLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_socManagementAllowedLowLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socManagementAllowedLowLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for PeakShaving {
    fn is_initialized(&self) -> bool {
        for v in &self.baseShavingLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.peakShavingCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.peakShavingLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socManagementAllowedHighLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socManagementAllowedLowLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.baseShavingLimit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peakShavingCtl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peakShavingLimit)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socManagementAllowedHighLimit)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socManagementAllowedLowLimit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.baseShavingLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.peakShavingCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.peakShavingLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socManagementAllowedHighLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socManagementAllowedLowLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.baseShavingLimit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.peakShavingCtl.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.peakShavingLimit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socManagementAllowedHighLimit.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socManagementAllowedLowLimit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeakShaving {
        PeakShaving::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "baseShavingLimit",
                |m: &PeakShaving| { &m.baseShavingLimit },
                |m: &mut PeakShaving| { &mut m.baseShavingLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "peakShavingCtl",
                |m: &PeakShaving| { &m.peakShavingCtl },
                |m: &mut PeakShaving| { &mut m.peakShavingCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "peakShavingLimit",
                |m: &PeakShaving| { &m.peakShavingLimit },
                |m: &mut PeakShaving| { &mut m.peakShavingLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socManagementAllowedHighLimit",
                |m: &PeakShaving| { &m.socManagementAllowedHighLimit },
                |m: &mut PeakShaving| { &mut m.socManagementAllowedHighLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socManagementAllowedLowLimit",
                |m: &PeakShaving| { &m.socManagementAllowedLowLimit },
                |m: &mut PeakShaving| { &mut m.socManagementAllowedLowLimit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PeakShaving>(
                "PeakShaving",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PeakShaving {
        static instance: ::protobuf::rt::LazyV2<PeakShaving> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeakShaving::new)
    }
}

impl ::protobuf::Clear for PeakShaving {
    fn clear(&mut self) {
        self.baseShavingLimit.clear();
        self.peakShavingCtl.clear();
        self.peakShavingLimit.clear();
        self.socManagementAllowedHighLimit.clear();
        self.socManagementAllowedLowLimit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeakShaving {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeakShaving {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SocLimit {
    // message fields
    socHighLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socHighLimitHysteresis: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socLimitCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    socLowLimit: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socLowLimitHysteresis: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SocLimit {
    fn default() -> &'a SocLimit {
        <SocLimit as ::protobuf::Message>::default_instance()
    }
}

impl SocLimit {
    pub fn new() -> SocLimit {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue socHighLimit = 1;


    pub fn get_socHighLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socHighLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socHighLimit(&mut self) {
        self.socHighLimit.clear();
    }

    pub fn has_socHighLimit(&self) -> bool {
        self.socHighLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socHighLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socHighLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socHighLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socHighLimit.is_none() {
            self.socHighLimit.set_default();
        }
        self.socHighLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_socHighLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socHighLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socHighLimitHysteresis = 2;


    pub fn get_socHighLimitHysteresis(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socHighLimitHysteresis.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socHighLimitHysteresis(&mut self) {
        self.socHighLimitHysteresis.clear();
    }

    pub fn has_socHighLimitHysteresis(&self) -> bool {
        self.socHighLimitHysteresis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socHighLimitHysteresis(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socHighLimitHysteresis = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socHighLimitHysteresis(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socHighLimitHysteresis.is_none() {
            self.socHighLimitHysteresis.set_default();
        }
        self.socHighLimitHysteresis.as_mut().unwrap()
    }

    // Take field
    pub fn take_socHighLimitHysteresis(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socHighLimitHysteresis.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.BoolValue socLimitCtl = 3;


    pub fn get_socLimitCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.socLimitCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socLimitCtl(&mut self) {
        self.socLimitCtl.clear();
    }

    pub fn has_socLimitCtl(&self) -> bool {
        self.socLimitCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socLimitCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.socLimitCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socLimitCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.socLimitCtl.is_none() {
            self.socLimitCtl.set_default();
        }
        self.socLimitCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_socLimitCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.socLimitCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.FloatValue socLowLimit = 4;


    pub fn get_socLowLimit(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socLowLimit.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socLowLimit(&mut self) {
        self.socLowLimit.clear();
    }

    pub fn has_socLowLimit(&self) -> bool {
        self.socLowLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socLowLimit(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socLowLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socLowLimit(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socLowLimit.is_none() {
            self.socLowLimit.set_default();
        }
        self.socLowLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_socLowLimit(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socLowLimit.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socLowLimitHysteresis = 5;


    pub fn get_socLowLimitHysteresis(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socLowLimitHysteresis.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socLowLimitHysteresis(&mut self) {
        self.socLowLimitHysteresis.clear();
    }

    pub fn has_socLowLimitHysteresis(&self) -> bool {
        self.socLowLimitHysteresis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socLowLimitHysteresis(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socLowLimitHysteresis = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socLowLimitHysteresis(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socLowLimitHysteresis.is_none() {
            self.socLowLimitHysteresis.set_default();
        }
        self.socLowLimitHysteresis.as_mut().unwrap()
    }

    // Take field
    pub fn take_socLowLimitHysteresis(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socLowLimitHysteresis.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for SocLimit {
    fn is_initialized(&self) -> bool {
        for v in &self.socHighLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socHighLimitHysteresis {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socLimitCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socLowLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socLowLimitHysteresis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socHighLimit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socHighLimitHysteresis)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socLimitCtl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socLowLimit)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socLowLimitHysteresis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socHighLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socHighLimitHysteresis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socLimitCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socLowLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socLowLimitHysteresis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socHighLimit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socHighLimitHysteresis.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socLimitCtl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socLowLimit.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socLowLimitHysteresis.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SocLimit {
        SocLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socHighLimit",
                |m: &SocLimit| { &m.socHighLimit },
                |m: &mut SocLimit| { &mut m.socHighLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socHighLimitHysteresis",
                |m: &SocLimit| { &m.socHighLimitHysteresis },
                |m: &mut SocLimit| { &mut m.socHighLimitHysteresis },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "socLimitCtl",
                |m: &SocLimit| { &m.socLimitCtl },
                |m: &mut SocLimit| { &mut m.socLimitCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socLowLimit",
                |m: &SocLimit| { &m.socLowLimit },
                |m: &mut SocLimit| { &mut m.socLowLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socLowLimitHysteresis",
                |m: &SocLimit| { &m.socLowLimitHysteresis },
                |m: &mut SocLimit| { &mut m.socLowLimitHysteresis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SocLimit>(
                "SocLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SocLimit {
        static instance: ::protobuf::rt::LazyV2<SocLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SocLimit::new)
    }
}

impl ::protobuf::Clear for SocLimit {
    fn clear(&mut self) {
        self.socHighLimit.clear();
        self.socHighLimitHysteresis.clear();
        self.socLimitCtl.clear();
        self.socLowLimit.clear();
        self.socLowLimitHysteresis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SocLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SocLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SOCManagement {
    // message fields
    socDeadBandMinus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socDeadBandPlus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socManagementCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    socPowerSetPoint: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    socSetPoint: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOCManagement {
    fn default() -> &'a SOCManagement {
        <SOCManagement as ::protobuf::Message>::default_instance()
    }
}

impl SOCManagement {
    pub fn new() -> SOCManagement {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue socDeadBandMinus = 1;


    pub fn get_socDeadBandMinus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socDeadBandMinus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socDeadBandMinus(&mut self) {
        self.socDeadBandMinus.clear();
    }

    pub fn has_socDeadBandMinus(&self) -> bool {
        self.socDeadBandMinus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socDeadBandMinus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socDeadBandMinus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socDeadBandMinus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socDeadBandMinus.is_none() {
            self.socDeadBandMinus.set_default();
        }
        self.socDeadBandMinus.as_mut().unwrap()
    }

    // Take field
    pub fn take_socDeadBandMinus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socDeadBandMinus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socDeadBandPlus = 2;


    pub fn get_socDeadBandPlus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socDeadBandPlus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socDeadBandPlus(&mut self) {
        self.socDeadBandPlus.clear();
    }

    pub fn has_socDeadBandPlus(&self) -> bool {
        self.socDeadBandPlus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socDeadBandPlus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socDeadBandPlus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socDeadBandPlus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socDeadBandPlus.is_none() {
            self.socDeadBandPlus.set_default();
        }
        self.socDeadBandPlus.as_mut().unwrap()
    }

    // Take field
    pub fn take_socDeadBandPlus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socDeadBandPlus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.BoolValue socManagementCtl = 3;


    pub fn get_socManagementCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.socManagementCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socManagementCtl(&mut self) {
        self.socManagementCtl.clear();
    }

    pub fn has_socManagementCtl(&self) -> bool {
        self.socManagementCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socManagementCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.socManagementCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socManagementCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.socManagementCtl.is_none() {
            self.socManagementCtl.set_default();
        }
        self.socManagementCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_socManagementCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.socManagementCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.FloatValue socPowerSetPoint = 4;


    pub fn get_socPowerSetPoint(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socPowerSetPoint.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socPowerSetPoint(&mut self) {
        self.socPowerSetPoint.clear();
    }

    pub fn has_socPowerSetPoint(&self) -> bool {
        self.socPowerSetPoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socPowerSetPoint(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socPowerSetPoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socPowerSetPoint(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socPowerSetPoint.is_none() {
            self.socPowerSetPoint.set_default();
        }
        self.socPowerSetPoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_socPowerSetPoint(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socPowerSetPoint.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue socSetPoint = 5;


    pub fn get_socSetPoint(&self) -> &::protobuf::well_known_types::FloatValue {
        self.socSetPoint.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socSetPoint(&mut self) {
        self.socSetPoint.clear();
    }

    pub fn has_socSetPoint(&self) -> bool {
        self.socSetPoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socSetPoint(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.socSetPoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socSetPoint(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.socSetPoint.is_none() {
            self.socSetPoint.set_default();
        }
        self.socSetPoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_socSetPoint(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.socSetPoint.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for SOCManagement {
    fn is_initialized(&self) -> bool {
        for v in &self.socDeadBandMinus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socDeadBandPlus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socManagementCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socPowerSetPoint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socSetPoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socDeadBandMinus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socDeadBandPlus)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socManagementCtl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socPowerSetPoint)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socSetPoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socDeadBandMinus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socDeadBandPlus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socManagementCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socPowerSetPoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socSetPoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socDeadBandMinus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socDeadBandPlus.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socManagementCtl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socPowerSetPoint.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socSetPoint.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOCManagement {
        SOCManagement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socDeadBandMinus",
                |m: &SOCManagement| { &m.socDeadBandMinus },
                |m: &mut SOCManagement| { &mut m.socDeadBandMinus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socDeadBandPlus",
                |m: &SOCManagement| { &m.socDeadBandPlus },
                |m: &mut SOCManagement| { &mut m.socDeadBandPlus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "socManagementCtl",
                |m: &SOCManagement| { &m.socManagementCtl },
                |m: &mut SOCManagement| { &mut m.socManagementCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socPowerSetPoint",
                |m: &SOCManagement| { &m.socPowerSetPoint },
                |m: &mut SOCManagement| { &mut m.socPowerSetPoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "socSetPoint",
                |m: &SOCManagement| { &m.socSetPoint },
                |m: &mut SOCManagement| { &mut m.socSetPoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOCManagement>(
                "SOCManagement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOCManagement {
        static instance: ::protobuf::rt::LazyV2<SOCManagement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOCManagement::new)
    }
}

impl ::protobuf::Clear for SOCManagement {
    fn clear(&mut self) {
        self.socDeadBandMinus.clear();
        self.socDeadBandPlus.clear();
        self.socManagementCtl.clear();
        self.socPowerSetPoint.clear();
        self.socSetPoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOCManagement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOCManagement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoltageRegulation {
    // message fields
    overVoltageDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    underVoltageDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    voltageDeadBandMinus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    voltageDeadBandPlus: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    voltageSetPoint: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoltageRegulation {
    fn default() -> &'a VoltageRegulation {
        <VoltageRegulation as ::protobuf::Message>::default_instance()
    }
}

impl VoltageRegulation {
    pub fn new() -> VoltageRegulation {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue overVoltageDroop = 1;


    pub fn get_overVoltageDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.overVoltageDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overVoltageDroop(&mut self) {
        self.overVoltageDroop.clear();
    }

    pub fn has_overVoltageDroop(&self) -> bool {
        self.overVoltageDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overVoltageDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.overVoltageDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overVoltageDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.overVoltageDroop.is_none() {
            self.overVoltageDroop.set_default();
        }
        self.overVoltageDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_overVoltageDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.overVoltageDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue underVoltageDroop = 2;


    pub fn get_underVoltageDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.underVoltageDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_underVoltageDroop(&mut self) {
        self.underVoltageDroop.clear();
    }

    pub fn has_underVoltageDroop(&self) -> bool {
        self.underVoltageDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underVoltageDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.underVoltageDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_underVoltageDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.underVoltageDroop.is_none() {
            self.underVoltageDroop.set_default();
        }
        self.underVoltageDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_underVoltageDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.underVoltageDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue voltageDeadBandMinus = 3;


    pub fn get_voltageDeadBandMinus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.voltageDeadBandMinus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageDeadBandMinus(&mut self) {
        self.voltageDeadBandMinus.clear();
    }

    pub fn has_voltageDeadBandMinus(&self) -> bool {
        self.voltageDeadBandMinus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageDeadBandMinus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.voltageDeadBandMinus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageDeadBandMinus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.voltageDeadBandMinus.is_none() {
            self.voltageDeadBandMinus.set_default();
        }
        self.voltageDeadBandMinus.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageDeadBandMinus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.voltageDeadBandMinus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue voltageDeadBandPlus = 4;


    pub fn get_voltageDeadBandPlus(&self) -> &::protobuf::well_known_types::FloatValue {
        self.voltageDeadBandPlus.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageDeadBandPlus(&mut self) {
        self.voltageDeadBandPlus.clear();
    }

    pub fn has_voltageDeadBandPlus(&self) -> bool {
        self.voltageDeadBandPlus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageDeadBandPlus(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.voltageDeadBandPlus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageDeadBandPlus(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.voltageDeadBandPlus.is_none() {
            self.voltageDeadBandPlus.set_default();
        }
        self.voltageDeadBandPlus.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageDeadBandPlus(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.voltageDeadBandPlus.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue voltageSetPoint = 5;


    pub fn get_voltageSetPoint(&self) -> &::protobuf::well_known_types::FloatValue {
        self.voltageSetPoint.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPoint(&mut self) {
        self.voltageSetPoint.clear();
    }

    pub fn has_voltageSetPoint(&self) -> bool {
        self.voltageSetPoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPoint(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.voltageSetPoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPoint(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.voltageSetPoint.is_none() {
            self.voltageSetPoint.set_default();
        }
        self.voltageSetPoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPoint(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.voltageSetPoint.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for VoltageRegulation {
    fn is_initialized(&self) -> bool {
        for v in &self.overVoltageDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.underVoltageDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageDeadBandMinus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageDeadBandPlus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overVoltageDroop)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.underVoltageDroop)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageDeadBandMinus)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageDeadBandPlus)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.overVoltageDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.underVoltageDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageDeadBandMinus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageDeadBandPlus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.overVoltageDroop.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.underVoltageDroop.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageDeadBandMinus.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageDeadBandPlus.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPoint.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoltageRegulation {
        VoltageRegulation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "overVoltageDroop",
                |m: &VoltageRegulation| { &m.overVoltageDroop },
                |m: &mut VoltageRegulation| { &mut m.overVoltageDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "underVoltageDroop",
                |m: &VoltageRegulation| { &m.underVoltageDroop },
                |m: &mut VoltageRegulation| { &mut m.underVoltageDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "voltageDeadBandMinus",
                |m: &VoltageRegulation| { &m.voltageDeadBandMinus },
                |m: &mut VoltageRegulation| { &mut m.voltageDeadBandMinus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "voltageDeadBandPlus",
                |m: &VoltageRegulation| { &m.voltageDeadBandPlus },
                |m: &mut VoltageRegulation| { &mut m.voltageDeadBandPlus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "voltageSetPoint",
                |m: &VoltageRegulation| { &m.voltageSetPoint },
                |m: &mut VoltageRegulation| { &mut m.voltageSetPoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoltageRegulation>(
                "VoltageRegulation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoltageRegulation {
        static instance: ::protobuf::rt::LazyV2<VoltageRegulation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoltageRegulation::new)
    }
}

impl ::protobuf::Clear for VoltageRegulation {
    fn clear(&mut self) {
        self.overVoltageDroop.clear();
        self.underVoltageDroop.clear();
        self.voltageDeadBandMinus.clear();
        self.voltageDeadBandPlus.clear();
        self.voltageSetPoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoltageRegulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoltageRegulation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoltageDroop {
    // message fields
    voltageDroopCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    voltageRegulation: ::protobuf::SingularPtrField<VoltageRegulation>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoltageDroop {
    fn default() -> &'a VoltageDroop {
        <VoltageDroop as ::protobuf::Message>::default_instance()
    }
}

impl VoltageDroop {
    pub fn new() -> VoltageDroop {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue voltageDroopCtl = 1;


    pub fn get_voltageDroopCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.voltageDroopCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageDroopCtl(&mut self) {
        self.voltageDroopCtl.clear();
    }

    pub fn has_voltageDroopCtl(&self) -> bool {
        self.voltageDroopCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageDroopCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.voltageDroopCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageDroopCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.voltageDroopCtl.is_none() {
            self.voltageDroopCtl.set_default();
        }
        self.voltageDroopCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageDroopCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.voltageDroopCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .essmodule.VoltageRegulation voltageRegulation = 2;


    pub fn get_voltageRegulation(&self) -> &VoltageRegulation {
        self.voltageRegulation.as_ref().unwrap_or_else(|| <VoltageRegulation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageRegulation(&mut self) {
        self.voltageRegulation.clear();
    }

    pub fn has_voltageRegulation(&self) -> bool {
        self.voltageRegulation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageRegulation(&mut self, v: VoltageRegulation) {
        self.voltageRegulation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageRegulation(&mut self) -> &mut VoltageRegulation {
        if self.voltageRegulation.is_none() {
            self.voltageRegulation.set_default();
        }
        self.voltageRegulation.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageRegulation(&mut self) -> VoltageRegulation {
        self.voltageRegulation.take().unwrap_or_else(|| VoltageRegulation::new())
    }
}

impl ::protobuf::Message for VoltageDroop {
    fn is_initialized(&self) -> bool {
        for v in &self.voltageDroopCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageRegulation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageDroopCtl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageRegulation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.voltageDroopCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageRegulation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.voltageDroopCtl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageRegulation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoltageDroop {
        VoltageDroop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "voltageDroopCtl",
                |m: &VoltageDroop| { &m.voltageDroopCtl },
                |m: &mut VoltageDroop| { &mut m.voltageDroopCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoltageRegulation>>(
                "voltageRegulation",
                |m: &VoltageDroop| { &m.voltageRegulation },
                |m: &mut VoltageDroop| { &mut m.voltageRegulation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoltageDroop>(
                "VoltageDroop",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoltageDroop {
        static instance: ::protobuf::rt::LazyV2<VoltageDroop> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoltageDroop::new)
    }
}

impl ::protobuf::Clear for VoltageDroop {
    fn clear(&mut self) {
        self.voltageDroopCtl.clear();
        self.voltageRegulation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoltageDroop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoltageDroop {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoltagePI {
    // message fields
    voltagePICtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    voltageRegulation: ::protobuf::SingularPtrField<VoltageRegulation>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoltagePI {
    fn default() -> &'a VoltagePI {
        <VoltagePI as ::protobuf::Message>::default_instance()
    }
}

impl VoltagePI {
    pub fn new() -> VoltagePI {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue voltagePICtl = 1;


    pub fn get_voltagePICtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.voltagePICtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltagePICtl(&mut self) {
        self.voltagePICtl.clear();
    }

    pub fn has_voltagePICtl(&self) -> bool {
        self.voltagePICtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltagePICtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.voltagePICtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltagePICtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.voltagePICtl.is_none() {
            self.voltagePICtl.set_default();
        }
        self.voltagePICtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltagePICtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.voltagePICtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .essmodule.VoltageRegulation voltageRegulation = 2;


    pub fn get_voltageRegulation(&self) -> &VoltageRegulation {
        self.voltageRegulation.as_ref().unwrap_or_else(|| <VoltageRegulation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageRegulation(&mut self) {
        self.voltageRegulation.clear();
    }

    pub fn has_voltageRegulation(&self) -> bool {
        self.voltageRegulation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageRegulation(&mut self, v: VoltageRegulation) {
        self.voltageRegulation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageRegulation(&mut self) -> &mut VoltageRegulation {
        if self.voltageRegulation.is_none() {
            self.voltageRegulation.set_default();
        }
        self.voltageRegulation.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageRegulation(&mut self) -> VoltageRegulation {
        self.voltageRegulation.take().unwrap_or_else(|| VoltageRegulation::new())
    }
}

impl ::protobuf::Message for VoltagePI {
    fn is_initialized(&self) -> bool {
        for v in &self.voltagePICtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageRegulation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltagePICtl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageRegulation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.voltagePICtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageRegulation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.voltagePICtl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageRegulation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoltagePI {
        VoltagePI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "voltagePICtl",
                |m: &VoltagePI| { &m.voltagePICtl },
                |m: &mut VoltagePI| { &mut m.voltagePICtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoltageRegulation>>(
                "voltageRegulation",
                |m: &VoltagePI| { &m.voltageRegulation },
                |m: &mut VoltagePI| { &mut m.voltageRegulation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoltagePI>(
                "VoltagePI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoltagePI {
        static instance: ::protobuf::rt::LazyV2<VoltagePI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoltagePI::new)
    }
}

impl ::protobuf::Clear for VoltagePI {
    fn clear(&mut self) {
        self.voltagePICtl.clear();
        self.voltageRegulation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoltagePI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoltagePI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CapacityFirming {
    // message fields
    capacityFirmingCtl: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    limitNegative_dp_dt: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    limitPositive_dp_dt: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CapacityFirming {
    fn default() -> &'a CapacityFirming {
        <CapacityFirming as ::protobuf::Message>::default_instance()
    }
}

impl CapacityFirming {
    pub fn new() -> CapacityFirming {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue capacityFirmingCtl = 1;


    pub fn get_capacityFirmingCtl(&self) -> &::protobuf::well_known_types::BoolValue {
        self.capacityFirmingCtl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capacityFirmingCtl(&mut self) {
        self.capacityFirmingCtl.clear();
    }

    pub fn has_capacityFirmingCtl(&self) -> bool {
        self.capacityFirmingCtl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacityFirmingCtl(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.capacityFirmingCtl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacityFirmingCtl(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.capacityFirmingCtl.is_none() {
            self.capacityFirmingCtl.set_default();
        }
        self.capacityFirmingCtl.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacityFirmingCtl(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.capacityFirmingCtl.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.FloatValue limitNegative_dp_dt = 2;


    pub fn get_limitNegative_dp_dt(&self) -> &::protobuf::well_known_types::FloatValue {
        self.limitNegative_dp_dt.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limitNegative_dp_dt(&mut self) {
        self.limitNegative_dp_dt.clear();
    }

    pub fn has_limitNegative_dp_dt(&self) -> bool {
        self.limitNegative_dp_dt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitNegative_dp_dt(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.limitNegative_dp_dt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limitNegative_dp_dt(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.limitNegative_dp_dt.is_none() {
            self.limitNegative_dp_dt.set_default();
        }
        self.limitNegative_dp_dt.as_mut().unwrap()
    }

    // Take field
    pub fn take_limitNegative_dp_dt(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.limitNegative_dp_dt.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue limitPositive_dp_dt = 3;


    pub fn get_limitPositive_dp_dt(&self) -> &::protobuf::well_known_types::FloatValue {
        self.limitPositive_dp_dt.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limitPositive_dp_dt(&mut self) {
        self.limitPositive_dp_dt.clear();
    }

    pub fn has_limitPositive_dp_dt(&self) -> bool {
        self.limitPositive_dp_dt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitPositive_dp_dt(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.limitPositive_dp_dt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limitPositive_dp_dt(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.limitPositive_dp_dt.is_none() {
            self.limitPositive_dp_dt.set_default();
        }
        self.limitPositive_dp_dt.as_mut().unwrap()
    }

    // Take field
    pub fn take_limitPositive_dp_dt(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.limitPositive_dp_dt.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for CapacityFirming {
    fn is_initialized(&self) -> bool {
        for v in &self.capacityFirmingCtl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limitNegative_dp_dt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limitPositive_dp_dt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacityFirmingCtl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limitNegative_dp_dt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limitPositive_dp_dt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capacityFirmingCtl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limitNegative_dp_dt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limitPositive_dp_dt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capacityFirmingCtl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limitNegative_dp_dt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limitPositive_dp_dt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapacityFirming {
        CapacityFirming::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "capacityFirmingCtl",
                |m: &CapacityFirming| { &m.capacityFirmingCtl },
                |m: &mut CapacityFirming| { &mut m.capacityFirmingCtl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "limitNegative_dp_dt",
                |m: &CapacityFirming| { &m.limitNegative_dp_dt },
                |m: &mut CapacityFirming| { &mut m.limitNegative_dp_dt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "limitPositive_dp_dt",
                |m: &CapacityFirming| { &m.limitPositive_dp_dt },
                |m: &mut CapacityFirming| { &mut m.limitPositive_dp_dt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CapacityFirming>(
                "CapacityFirming",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CapacityFirming {
        static instance: ::protobuf::rt::LazyV2<CapacityFirming> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CapacityFirming::new)
    }
}

impl ::protobuf::Clear for CapacityFirming {
    fn clear(&mut self) {
        self.capacityFirmingCtl.clear();
        self.limitNegative_dp_dt.clear();
        self.limitPositive_dp_dt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapacityFirming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapacityFirming {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSFunction {
    // message fields
    capacityFirming: ::protobuf::SingularPtrField<CapacityFirming>,
    frequencyRegulation: ::protobuf::SingularPtrField<FrequencyRegulation>,
    peakShaving: ::protobuf::SingularPtrField<PeakShaving>,
    socLimit: ::protobuf::SingularPtrField<SocLimit>,
    socManagement: ::protobuf::SingularPtrField<SOCManagement>,
    voltageDroop: ::protobuf::SingularPtrField<VoltageDroop>,
    voltagePI: ::protobuf::SingularPtrField<VoltagePI>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSFunction {
    fn default() -> &'a ESSFunction {
        <ESSFunction as ::protobuf::Message>::default_instance()
    }
}

impl ESSFunction {
    pub fn new() -> ESSFunction {
        ::std::default::Default::default()
    }

    // .essmodule.CapacityFirming capacityFirming = 1;


    pub fn get_capacityFirming(&self) -> &CapacityFirming {
        self.capacityFirming.as_ref().unwrap_or_else(|| <CapacityFirming as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capacityFirming(&mut self) {
        self.capacityFirming.clear();
    }

    pub fn has_capacityFirming(&self) -> bool {
        self.capacityFirming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacityFirming(&mut self, v: CapacityFirming) {
        self.capacityFirming = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacityFirming(&mut self) -> &mut CapacityFirming {
        if self.capacityFirming.is_none() {
            self.capacityFirming.set_default();
        }
        self.capacityFirming.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacityFirming(&mut self) -> CapacityFirming {
        self.capacityFirming.take().unwrap_or_else(|| CapacityFirming::new())
    }

    // .essmodule.FrequencyRegulation frequencyRegulation = 2;


    pub fn get_frequencyRegulation(&self) -> &FrequencyRegulation {
        self.frequencyRegulation.as_ref().unwrap_or_else(|| <FrequencyRegulation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencyRegulation(&mut self) {
        self.frequencyRegulation.clear();
    }

    pub fn has_frequencyRegulation(&self) -> bool {
        self.frequencyRegulation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencyRegulation(&mut self, v: FrequencyRegulation) {
        self.frequencyRegulation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencyRegulation(&mut self) -> &mut FrequencyRegulation {
        if self.frequencyRegulation.is_none() {
            self.frequencyRegulation.set_default();
        }
        self.frequencyRegulation.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencyRegulation(&mut self) -> FrequencyRegulation {
        self.frequencyRegulation.take().unwrap_or_else(|| FrequencyRegulation::new())
    }

    // .essmodule.PeakShaving peakShaving = 3;


    pub fn get_peakShaving(&self) -> &PeakShaving {
        self.peakShaving.as_ref().unwrap_or_else(|| <PeakShaving as ::protobuf::Message>::default_instance())
    }
    pub fn clear_peakShaving(&mut self) {
        self.peakShaving.clear();
    }

    pub fn has_peakShaving(&self) -> bool {
        self.peakShaving.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peakShaving(&mut self, v: PeakShaving) {
        self.peakShaving = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peakShaving(&mut self) -> &mut PeakShaving {
        if self.peakShaving.is_none() {
            self.peakShaving.set_default();
        }
        self.peakShaving.as_mut().unwrap()
    }

    // Take field
    pub fn take_peakShaving(&mut self) -> PeakShaving {
        self.peakShaving.take().unwrap_or_else(|| PeakShaving::new())
    }

    // .essmodule.SocLimit socLimit = 4;


    pub fn get_socLimit(&self) -> &SocLimit {
        self.socLimit.as_ref().unwrap_or_else(|| <SocLimit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socLimit(&mut self) {
        self.socLimit.clear();
    }

    pub fn has_socLimit(&self) -> bool {
        self.socLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socLimit(&mut self, v: SocLimit) {
        self.socLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socLimit(&mut self) -> &mut SocLimit {
        if self.socLimit.is_none() {
            self.socLimit.set_default();
        }
        self.socLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_socLimit(&mut self) -> SocLimit {
        self.socLimit.take().unwrap_or_else(|| SocLimit::new())
    }

    // .essmodule.SOCManagement socManagement = 5;


    pub fn get_socManagement(&self) -> &SOCManagement {
        self.socManagement.as_ref().unwrap_or_else(|| <SOCManagement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_socManagement(&mut self) {
        self.socManagement.clear();
    }

    pub fn has_socManagement(&self) -> bool {
        self.socManagement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socManagement(&mut self, v: SOCManagement) {
        self.socManagement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socManagement(&mut self) -> &mut SOCManagement {
        if self.socManagement.is_none() {
            self.socManagement.set_default();
        }
        self.socManagement.as_mut().unwrap()
    }

    // Take field
    pub fn take_socManagement(&mut self) -> SOCManagement {
        self.socManagement.take().unwrap_or_else(|| SOCManagement::new())
    }

    // .essmodule.VoltageDroop voltageDroop = 6;


    pub fn get_voltageDroop(&self) -> &VoltageDroop {
        self.voltageDroop.as_ref().unwrap_or_else(|| <VoltageDroop as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageDroop(&mut self) {
        self.voltageDroop.clear();
    }

    pub fn has_voltageDroop(&self) -> bool {
        self.voltageDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageDroop(&mut self, v: VoltageDroop) {
        self.voltageDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageDroop(&mut self) -> &mut VoltageDroop {
        if self.voltageDroop.is_none() {
            self.voltageDroop.set_default();
        }
        self.voltageDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageDroop(&mut self) -> VoltageDroop {
        self.voltageDroop.take().unwrap_or_else(|| VoltageDroop::new())
    }

    // .essmodule.VoltagePI voltagePI = 7;


    pub fn get_voltagePI(&self) -> &VoltagePI {
        self.voltagePI.as_ref().unwrap_or_else(|| <VoltagePI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltagePI(&mut self) {
        self.voltagePI.clear();
    }

    pub fn has_voltagePI(&self) -> bool {
        self.voltagePI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltagePI(&mut self, v: VoltagePI) {
        self.voltagePI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltagePI(&mut self) -> &mut VoltagePI {
        if self.voltagePI.is_none() {
            self.voltagePI.set_default();
        }
        self.voltagePI.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltagePI(&mut self) -> VoltagePI {
        self.voltagePI.take().unwrap_or_else(|| VoltagePI::new())
    }
}

impl ::protobuf::Message for ESSFunction {
    fn is_initialized(&self) -> bool {
        for v in &self.capacityFirming {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencyRegulation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.peakShaving {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socManagement {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltagePI {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacityFirming)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencyRegulation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peakShaving)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socLimit)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socManagement)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageDroop)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltagePI)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capacityFirming.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencyRegulation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.peakShaving.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.socManagement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltagePI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capacityFirming.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencyRegulation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.peakShaving.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socLimit.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.socManagement.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageDroop.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltagePI.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSFunction {
        ESSFunction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapacityFirming>>(
                "capacityFirming",
                |m: &ESSFunction| { &m.capacityFirming },
                |m: &mut ESSFunction| { &mut m.capacityFirming },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrequencyRegulation>>(
                "frequencyRegulation",
                |m: &ESSFunction| { &m.frequencyRegulation },
                |m: &mut ESSFunction| { &mut m.frequencyRegulation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeakShaving>>(
                "peakShaving",
                |m: &ESSFunction| { &m.peakShaving },
                |m: &mut ESSFunction| { &mut m.peakShaving },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SocLimit>>(
                "socLimit",
                |m: &ESSFunction| { &m.socLimit },
                |m: &mut ESSFunction| { &mut m.socLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOCManagement>>(
                "socManagement",
                |m: &ESSFunction| { &m.socManagement },
                |m: &mut ESSFunction| { &mut m.socManagement },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoltageDroop>>(
                "voltageDroop",
                |m: &ESSFunction| { &m.voltageDroop },
                |m: &mut ESSFunction| { &mut m.voltageDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoltagePI>>(
                "voltagePI",
                |m: &ESSFunction| { &m.voltagePI },
                |m: &mut ESSFunction| { &mut m.voltagePI },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSFunction>(
                "ESSFunction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSFunction {
        static instance: ::protobuf::rt::LazyV2<ESSFunction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSFunction::new)
    }
}

impl ::protobuf::Clear for ESSFunction {
    fn clear(&mut self) {
        self.capacityFirming.clear();
        self.frequencyRegulation.clear();
        self.peakShaving.clear();
        self.socLimit.clear();
        self.socManagement.clear();
        self.voltageDroop.clear();
        self.voltagePI.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSPointStatus {
    // message fields
    blackStartEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    function: ::protobuf::SingularPtrField<ESSFunction>,
    mode: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    syncBackToGrid: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    transToIslndOnGridLossEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSPointStatus {
    fn default() -> &'a ESSPointStatus {
        <ESSPointStatus as ::protobuf::Message>::default_instance()
    }
}

impl ESSPointStatus {
    pub fn new() -> ESSPointStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC blackStartEnabled = 1;


    pub fn get_blackStartEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.blackStartEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackStartEnabled(&mut self) {
        self.blackStartEnabled.clear();
    }

    pub fn has_blackStartEnabled(&self) -> bool {
        self.blackStartEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackStartEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.blackStartEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackStartEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.blackStartEnabled.is_none() {
            self.blackStartEnabled.set_default();
        }
        self.blackStartEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackStartEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.blackStartEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 2;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .essmodule.ESSFunction function = 3;


    pub fn get_function(&self) -> &ESSFunction {
        self.function.as_ref().unwrap_or_else(|| <ESSFunction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    pub fn has_function(&self) -> bool {
        self.function.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ESSFunction) {
        self.function = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ESSFunction {
        if self.function.is_none() {
            self.function.set_default();
        }
        self.function.as_mut().unwrap()
    }

    // Take field
    pub fn take_function(&mut self) -> ESSFunction {
        self.function.take().unwrap_or_else(|| ESSFunction::new())
    }

    // .commonmodule.ENG_GridConnectModeKind mode = 4;


    pub fn get_mode(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.mode.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.mode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.mode.is_none() {
            self.mode.set_default();
        }
        self.mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_mode(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.mode.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 5;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 6;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 7;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 9;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 10;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC syncBackToGrid = 11;


    pub fn get_syncBackToGrid(&self) -> &super::commonmodule::ControlDPC {
        self.syncBackToGrid.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncBackToGrid(&mut self) {
        self.syncBackToGrid.clear();
    }

    pub fn has_syncBackToGrid(&self) -> bool {
        self.syncBackToGrid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBackToGrid(&mut self, v: super::commonmodule::ControlDPC) {
        self.syncBackToGrid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncBackToGrid(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.syncBackToGrid.is_none() {
            self.syncBackToGrid.set_default();
        }
        self.syncBackToGrid.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncBackToGrid(&mut self) -> super::commonmodule::ControlDPC {
        self.syncBackToGrid.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 12;


    pub fn get_transToIslndOnGridLossEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transToIslndOnGridLossEnabled(&mut self) {
        self.transToIslndOnGridLossEnabled.clear();
    }

    pub fn has_transToIslndOnGridLossEnabled(&self) -> bool {
        self.transToIslndOnGridLossEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transToIslndOnGridLossEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.transToIslndOnGridLossEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transToIslndOnGridLossEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.transToIslndOnGridLossEnabled.is_none() {
            self.transToIslndOnGridLossEnabled.set_default();
        }
        self.transToIslndOnGridLossEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_transToIslndOnGridLossEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 13;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }
}

impl ::protobuf::Message for ESSPointStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.blackStartEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.function {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncBackToGrid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transToIslndOnGridLossEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackStartEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mode)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncBackToGrid)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transToIslndOnGridLossEnabled)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.function.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mode.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSPointStatus {
        ESSPointStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "blackStartEnabled",
                |m: &ESSPointStatus| { &m.blackStartEnabled },
                |m: &mut ESSPointStatus| { &mut m.blackStartEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &ESSPointStatus| { &m.frequencySetPointEnabled },
                |m: &mut ESSPointStatus| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSFunction>>(
                "function",
                |m: &ESSPointStatus| { &m.function },
                |m: &mut ESSPointStatus| { &mut m.function },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "mode",
                |m: &ESSPointStatus| { &m.mode },
                |m: &mut ESSPointStatus| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &ESSPointStatus| { &m.pctHzDroop },
                |m: &mut ESSPointStatus| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &ESSPointStatus| { &m.pctVDroop },
                |m: &mut ESSPointStatus| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &ESSPointStatus| { &m.rampRates },
                |m: &mut ESSPointStatus| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &ESSPointStatus| { &m.reactivePwrSetPointEnabled },
                |m: &mut ESSPointStatus| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &ESSPointStatus| { &m.realPwrSetPointEnabled },
                |m: &mut ESSPointStatus| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &ESSPointStatus| { &m.state },
                |m: &mut ESSPointStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "syncBackToGrid",
                |m: &ESSPointStatus| { &m.syncBackToGrid },
                |m: &mut ESSPointStatus| { &mut m.syncBackToGrid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "transToIslndOnGridLossEnabled",
                |m: &ESSPointStatus| { &m.transToIslndOnGridLossEnabled },
                |m: &mut ESSPointStatus| { &mut m.transToIslndOnGridLossEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &ESSPointStatus| { &m.voltageSetPointEnabled },
                |m: &mut ESSPointStatus| { &mut m.voltageSetPointEnabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSPointStatus>(
                "ESSPointStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSPointStatus {
        static instance: ::protobuf::rt::LazyV2<ESSPointStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSPointStatus::new)
    }
}

impl ::protobuf::Clear for ESSPointStatus {
    fn clear(&mut self) {
        self.blackStartEnabled.clear();
        self.frequencySetPointEnabled.clear();
        self.function.clear();
        self.mode.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.state.clear();
        self.syncBackToGrid.clear();
        self.transToIslndOnGridLossEnabled.clear();
        self.voltageSetPointEnabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSPointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSPointStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSEventAndStatusZGEN {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    AuxPwrSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    DynamicTest: ::protobuf::SingularPtrField<super::commonmodule::ENS_DynamicTestKind>,
    EmgStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    GnSynSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PointStatus: ::protobuf::SingularPtrField<ESSPointStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSEventAndStatusZGEN {
    fn default() -> &'a ESSEventAndStatusZGEN {
        <ESSEventAndStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl ESSEventAndStatusZGEN {
    pub fn new() -> ESSEventAndStatusZGEN {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.StatusSPS AuxPwrSt = 2;


    pub fn get_AuxPwrSt(&self) -> &super::commonmodule::StatusSPS {
        self.AuxPwrSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_AuxPwrSt(&mut self) {
        self.AuxPwrSt.clear();
    }

    pub fn has_AuxPwrSt(&self) -> bool {
        self.AuxPwrSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AuxPwrSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.AuxPwrSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AuxPwrSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.AuxPwrSt.is_none() {
            self.AuxPwrSt.set_default();
        }
        self.AuxPwrSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_AuxPwrSt(&mut self) -> super::commonmodule::StatusSPS {
        self.AuxPwrSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.ENS_DynamicTestKind DynamicTest = 3;


    pub fn get_DynamicTest(&self) -> &super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.as_ref().unwrap_or_else(|| <super::commonmodule::ENS_DynamicTestKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DynamicTest(&mut self) {
        self.DynamicTest.clear();
    }

    pub fn has_DynamicTest(&self) -> bool {
        self.DynamicTest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DynamicTest(&mut self, v: super::commonmodule::ENS_DynamicTestKind) {
        self.DynamicTest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DynamicTest(&mut self) -> &mut super::commonmodule::ENS_DynamicTestKind {
        if self.DynamicTest.is_none() {
            self.DynamicTest.set_default();
        }
        self.DynamicTest.as_mut().unwrap()
    }

    // Take field
    pub fn take_DynamicTest(&mut self) -> super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.take().unwrap_or_else(|| super::commonmodule::ENS_DynamicTestKind::new())
    }

    // .commonmodule.StatusSPS EmgStop = 4;


    pub fn get_EmgStop(&self) -> &super::commonmodule::StatusSPS {
        self.EmgStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_EmgStop(&mut self) {
        self.EmgStop.clear();
    }

    pub fn has_EmgStop(&self) -> bool {
        self.EmgStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EmgStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.EmgStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EmgStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.EmgStop.is_none() {
            self.EmgStop.set_default();
        }
        self.EmgStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_EmgStop(&mut self) -> super::commonmodule::StatusSPS {
        self.EmgStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.StatusSPS GnSynSt = 5;


    pub fn get_GnSynSt(&self) -> &super::commonmodule::StatusSPS {
        self.GnSynSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GnSynSt(&mut self) {
        self.GnSynSt.clear();
    }

    pub fn has_GnSynSt(&self) -> bool {
        self.GnSynSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GnSynSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.GnSynSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GnSynSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.GnSynSt.is_none() {
            self.GnSynSt.set_default();
        }
        self.GnSynSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_GnSynSt(&mut self) -> super::commonmodule::StatusSPS {
        self.GnSynSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .essmodule.ESSPointStatus PointStatus = 6;


    pub fn get_PointStatus(&self) -> &ESSPointStatus {
        self.PointStatus.as_ref().unwrap_or_else(|| <ESSPointStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PointStatus(&mut self) {
        self.PointStatus.clear();
    }

    pub fn has_PointStatus(&self) -> bool {
        self.PointStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PointStatus(&mut self, v: ESSPointStatus) {
        self.PointStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PointStatus(&mut self) -> &mut ESSPointStatus {
        if self.PointStatus.is_none() {
            self.PointStatus.set_default();
        }
        self.PointStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_PointStatus(&mut self) -> ESSPointStatus {
        self.PointStatus.take().unwrap_or_else(|| ESSPointStatus::new())
    }
}

impl ::protobuf::Message for ESSEventAndStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.AuxPwrSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DynamicTest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EmgStop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GnSynSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PointStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.AuxPwrSt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DynamicTest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EmgStop)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GnSynSt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PointStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GnSynSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.AuxPwrSt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GnSynSt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSEventAndStatusZGEN {
        ESSEventAndStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &ESSEventAndStatusZGEN| { &m.logicalNodeForEventAndStatus },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "AuxPwrSt",
                |m: &ESSEventAndStatusZGEN| { &m.AuxPwrSt },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.AuxPwrSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENS_DynamicTestKind>>(
                "DynamicTest",
                |m: &ESSEventAndStatusZGEN| { &m.DynamicTest },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.DynamicTest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "EmgStop",
                |m: &ESSEventAndStatusZGEN| { &m.EmgStop },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.EmgStop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "GnSynSt",
                |m: &ESSEventAndStatusZGEN| { &m.GnSynSt },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.GnSynSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSPointStatus>>(
                "PointStatus",
                |m: &ESSEventAndStatusZGEN| { &m.PointStatus },
                |m: &mut ESSEventAndStatusZGEN| { &mut m.PointStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSEventAndStatusZGEN>(
                "ESSEventAndStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSEventAndStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<ESSEventAndStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSEventAndStatusZGEN::new)
    }
}

impl ::protobuf::Clear for ESSEventAndStatusZGEN {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.AuxPwrSt.clear();
        self.DynamicTest.clear();
        self.EmgStop.clear();
        self.GnSynSt.clear();
        self.PointStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSEventAndStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSEventAndStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSEventZGEN {
    // message fields
    eSSEventAndStatusZGEN: ::protobuf::SingularPtrField<ESSEventAndStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSEventZGEN {
    fn default() -> &'a ESSEventZGEN {
        <ESSEventZGEN as ::protobuf::Message>::default_instance()
    }
}

impl ESSEventZGEN {
    pub fn new() -> ESSEventZGEN {
        ::std::default::Default::default()
    }

    // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1;


    pub fn get_eSSEventAndStatusZGEN(&self) -> &ESSEventAndStatusZGEN {
        self.eSSEventAndStatusZGEN.as_ref().unwrap_or_else(|| <ESSEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eSSEventAndStatusZGEN(&mut self) {
        self.eSSEventAndStatusZGEN.clear();
    }

    pub fn has_eSSEventAndStatusZGEN(&self) -> bool {
        self.eSSEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eSSEventAndStatusZGEN(&mut self, v: ESSEventAndStatusZGEN) {
        self.eSSEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eSSEventAndStatusZGEN(&mut self) -> &mut ESSEventAndStatusZGEN {
        if self.eSSEventAndStatusZGEN.is_none() {
            self.eSSEventAndStatusZGEN.set_default();
        }
        self.eSSEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_eSSEventAndStatusZGEN(&mut self) -> ESSEventAndStatusZGEN {
        self.eSSEventAndStatusZGEN.take().unwrap_or_else(|| ESSEventAndStatusZGEN::new())
    }
}

impl ::protobuf::Message for ESSEventZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.eSSEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eSSEventAndStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eSSEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eSSEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSEventZGEN {
        ESSEventZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSEventAndStatusZGEN>>(
                "eSSEventAndStatusZGEN",
                |m: &ESSEventZGEN| { &m.eSSEventAndStatusZGEN },
                |m: &mut ESSEventZGEN| { &mut m.eSSEventAndStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSEventZGEN>(
                "ESSEventZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSEventZGEN {
        static instance: ::protobuf::rt::LazyV2<ESSEventZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSEventZGEN::new)
    }
}

impl ::protobuf::Clear for ESSEventZGEN {
    fn clear(&mut self) {
        self.eSSEventAndStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSEventZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSEventZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSEvent {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    essEventZBAT: ::protobuf::SingularPtrField<EssEventZBAT>,
    essEventZGEN: ::protobuf::SingularPtrField<ESSEventZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSEvent {
    fn default() -> &'a ESSEvent {
        <ESSEvent as ::protobuf::Message>::default_instance()
    }
}

impl ESSEvent {
    pub fn new() -> ESSEvent {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .essmodule.EssEventZBAT essEventZBAT = 2;


    pub fn get_essEventZBAT(&self) -> &EssEventZBAT {
        self.essEventZBAT.as_ref().unwrap_or_else(|| <EssEventZBAT as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essEventZBAT(&mut self) {
        self.essEventZBAT.clear();
    }

    pub fn has_essEventZBAT(&self) -> bool {
        self.essEventZBAT.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essEventZBAT(&mut self, v: EssEventZBAT) {
        self.essEventZBAT = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essEventZBAT(&mut self) -> &mut EssEventZBAT {
        if self.essEventZBAT.is_none() {
            self.essEventZBAT.set_default();
        }
        self.essEventZBAT.as_mut().unwrap()
    }

    // Take field
    pub fn take_essEventZBAT(&mut self) -> EssEventZBAT {
        self.essEventZBAT.take().unwrap_or_else(|| EssEventZBAT::new())
    }

    // .essmodule.ESSEventZGEN essEventZGEN = 3;


    pub fn get_essEventZGEN(&self) -> &ESSEventZGEN {
        self.essEventZGEN.as_ref().unwrap_or_else(|| <ESSEventZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essEventZGEN(&mut self) {
        self.essEventZGEN.clear();
    }

    pub fn has_essEventZGEN(&self) -> bool {
        self.essEventZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essEventZGEN(&mut self, v: ESSEventZGEN) {
        self.essEventZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essEventZGEN(&mut self) -> &mut ESSEventZGEN {
        if self.essEventZGEN.is_none() {
            self.essEventZGEN.set_default();
        }
        self.essEventZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_essEventZGEN(&mut self) -> ESSEventZGEN {
        self.essEventZGEN.take().unwrap_or_else(|| ESSEventZGEN::new())
    }
}

impl ::protobuf::Message for ESSEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essEventZBAT {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essEventZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essEventZBAT)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essEventZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essEventZBAT.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essEventZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essEventZBAT.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essEventZGEN.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSEvent {
        ESSEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &ESSEvent| { &m.eventValue },
                |m: &mut ESSEvent| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EssEventZBAT>>(
                "essEventZBAT",
                |m: &ESSEvent| { &m.essEventZBAT },
                |m: &mut ESSEvent| { &mut m.essEventZBAT },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSEventZGEN>>(
                "essEventZGEN",
                |m: &ESSEvent| { &m.essEventZGEN },
                |m: &mut ESSEvent| { &mut m.essEventZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSEvent>(
                "ESSEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSEvent {
        static instance: ::protobuf::rt::LazyV2<ESSEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSEvent::new)
    }
}

impl ::protobuf::Clear for ESSEvent {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.essEventZBAT.clear();
        self.essEventZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSEventProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    ess: ::protobuf::SingularPtrField<super::commonmodule::ESS>,
    essEvent: ::protobuf::SingularPtrField<ESSEvent>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSEventProfile {
    fn default() -> &'a ESSEventProfile {
        <ESSEventProfile as ::protobuf::Message>::default_instance()
    }
}

impl ESSEventProfile {
    pub fn new() -> ESSEventProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .commonmodule.ESS ess = 2;


    pub fn get_ess(&self) -> &super::commonmodule::ESS {
        self.ess.as_ref().unwrap_or_else(|| <super::commonmodule::ESS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ess(&mut self) {
        self.ess.clear();
    }

    pub fn has_ess(&self) -> bool {
        self.ess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ess(&mut self, v: super::commonmodule::ESS) {
        self.ess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ess(&mut self) -> &mut super::commonmodule::ESS {
        if self.ess.is_none() {
            self.ess.set_default();
        }
        self.ess.as_mut().unwrap()
    }

    // Take field
    pub fn take_ess(&mut self) -> super::commonmodule::ESS {
        self.ess.take().unwrap_or_else(|| super::commonmodule::ESS::new())
    }

    // .essmodule.ESSEvent essEvent = 3;


    pub fn get_essEvent(&self) -> &ESSEvent {
        self.essEvent.as_ref().unwrap_or_else(|| <ESSEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essEvent(&mut self) {
        self.essEvent.clear();
    }

    pub fn has_essEvent(&self) -> bool {
        self.essEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essEvent(&mut self, v: ESSEvent) {
        self.essEvent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essEvent(&mut self) -> &mut ESSEvent {
        if self.essEvent.is_none() {
            self.essEvent.set_default();
        }
        self.essEvent.as_mut().unwrap()
    }

    // Take field
    pub fn take_essEvent(&mut self) -> ESSEvent {
        self.essEvent.take().unwrap_or_else(|| ESSEvent::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for ESSEventProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ess)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essEvent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essEvent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ess.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essEvent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSEventProfile {
        ESSEventProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &ESSEventProfile| { &m.eventMessageInfo },
                |m: &mut ESSEventProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ESS>>(
                "ess",
                |m: &ESSEventProfile| { &m.ess },
                |m: &mut ESSEventProfile| { &mut m.ess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSEvent>>(
                "essEvent",
                |m: &ESSEventProfile| { &m.essEvent },
                |m: &mut ESSEventProfile| { &mut m.essEvent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &ESSEventProfile| { &m.ied },
                |m: &mut ESSEventProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSEventProfile>(
                "ESSEventProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSEventProfile {
        static instance: ::protobuf::rt::LazyV2<ESSEventProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSEventProfile::new)
    }
}

impl ::protobuf::Clear for ESSEventProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.ess.clear();
        self.essEvent.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSEventProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSEventProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSReading {
    // message fields
    conductingEquipmentTerminalReading: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipmentTerminalReading>,
    phaseMMTN: ::protobuf::SingularPtrField<super::commonmodule::PhaseMMTN>,
    readingMMTR: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMTR>,
    readingMMXU: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMXU>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSReading {
    fn default() -> &'a ESSReading {
        <ESSReading as ::protobuf::Message>::default_instance()
    }
}

impl ESSReading {
    pub fn new() -> ESSReading {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1;


    pub fn get_conductingEquipmentTerminalReading(&self) -> &super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipmentTerminalReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipmentTerminalReading(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
    }

    pub fn has_conductingEquipmentTerminalReading(&self) -> bool {
        self.conductingEquipmentTerminalReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipmentTerminalReading(&mut self, v: super::commonmodule::ConductingEquipmentTerminalReading) {
        self.conductingEquipmentTerminalReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipmentTerminalReading(&mut self) -> &mut super::commonmodule::ConductingEquipmentTerminalReading {
        if self.conductingEquipmentTerminalReading.is_none() {
            self.conductingEquipmentTerminalReading.set_default();
        }
        self.conductingEquipmentTerminalReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipmentTerminalReading(&mut self) -> super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.take().unwrap_or_else(|| super::commonmodule::ConductingEquipmentTerminalReading::new())
    }

    // .commonmodule.PhaseMMTN phaseMMTN = 2;


    pub fn get_phaseMMTN(&self) -> &super::commonmodule::PhaseMMTN {
        self.phaseMMTN.as_ref().unwrap_or_else(|| <super::commonmodule::PhaseMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phaseMMTN(&mut self) {
        self.phaseMMTN.clear();
    }

    pub fn has_phaseMMTN(&self) -> bool {
        self.phaseMMTN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phaseMMTN(&mut self, v: super::commonmodule::PhaseMMTN) {
        self.phaseMMTN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phaseMMTN(&mut self) -> &mut super::commonmodule::PhaseMMTN {
        if self.phaseMMTN.is_none() {
            self.phaseMMTN.set_default();
        }
        self.phaseMMTN.as_mut().unwrap()
    }

    // Take field
    pub fn take_phaseMMTN(&mut self) -> super::commonmodule::PhaseMMTN {
        self.phaseMMTN.take().unwrap_or_else(|| super::commonmodule::PhaseMMTN::new())
    }

    // .commonmodule.ReadingMMTR readingMMTR = 3;


    pub fn get_readingMMTR(&self) -> &super::commonmodule::ReadingMMTR {
        self.readingMMTR.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMTR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMTR(&mut self) {
        self.readingMMTR.clear();
    }

    pub fn has_readingMMTR(&self) -> bool {
        self.readingMMTR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMTR(&mut self, v: super::commonmodule::ReadingMMTR) {
        self.readingMMTR = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMTR(&mut self) -> &mut super::commonmodule::ReadingMMTR {
        if self.readingMMTR.is_none() {
            self.readingMMTR.set_default();
        }
        self.readingMMTR.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMTR(&mut self) -> super::commonmodule::ReadingMMTR {
        self.readingMMTR.take().unwrap_or_else(|| super::commonmodule::ReadingMMTR::new())
    }

    // .commonmodule.ReadingMMXU readingMMXU = 4;


    pub fn get_readingMMXU(&self) -> &super::commonmodule::ReadingMMXU {
        self.readingMMXU.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMXU as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMXU(&mut self) {
        self.readingMMXU.clear();
    }

    pub fn has_readingMMXU(&self) -> bool {
        self.readingMMXU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMXU(&mut self, v: super::commonmodule::ReadingMMXU) {
        self.readingMMXU = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMXU(&mut self) -> &mut super::commonmodule::ReadingMMXU {
        if self.readingMMXU.is_none() {
            self.readingMMXU.set_default();
        }
        self.readingMMXU.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMXU(&mut self) -> super::commonmodule::ReadingMMXU {
        self.readingMMXU.take().unwrap_or_else(|| super::commonmodule::ReadingMMXU::new())
    }
}

impl ::protobuf::Message for ESSReading {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipmentTerminalReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phaseMMTN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMTR {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMXU {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipmentTerminalReading)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phaseMMTN)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMTR)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMXU)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSReading {
        ESSReading::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipmentTerminalReading>>(
                "conductingEquipmentTerminalReading",
                |m: &ESSReading| { &m.conductingEquipmentTerminalReading },
                |m: &mut ESSReading| { &mut m.conductingEquipmentTerminalReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::PhaseMMTN>>(
                "phaseMMTN",
                |m: &ESSReading| { &m.phaseMMTN },
                |m: &mut ESSReading| { &mut m.phaseMMTN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMTR>>(
                "readingMMTR",
                |m: &ESSReading| { &m.readingMMTR },
                |m: &mut ESSReading| { &mut m.readingMMTR },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMXU>>(
                "readingMMXU",
                |m: &ESSReading| { &m.readingMMXU },
                |m: &mut ESSReading| { &mut m.readingMMXU },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSReading>(
                "ESSReading",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSReading {
        static instance: ::protobuf::rt::LazyV2<ESSReading> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSReading::new)
    }
}

impl ::protobuf::Clear for ESSReading {
    fn clear(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
        self.phaseMMTN.clear();
        self.readingMMTR.clear();
        self.readingMMXU.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSReading {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSReadingProfile {
    // message fields
    readingMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ReadingMessageInfo>,
    ess: ::protobuf::SingularPtrField<super::commonmodule::ESS>,
    essReading: ::protobuf::SingularPtrField<ESSReading>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSReadingProfile {
    fn default() -> &'a ESSReadingProfile {
        <ESSReadingProfile as ::protobuf::Message>::default_instance()
    }
}

impl ESSReadingProfile {
    pub fn new() -> ESSReadingProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ReadingMessageInfo readingMessageInfo = 1;


    pub fn get_readingMessageInfo(&self) -> &super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMessageInfo(&mut self) {
        self.readingMessageInfo.clear();
    }

    pub fn has_readingMessageInfo(&self) -> bool {
        self.readingMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMessageInfo(&mut self, v: super::commonmodule::ReadingMessageInfo) {
        self.readingMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMessageInfo(&mut self) -> &mut super::commonmodule::ReadingMessageInfo {
        if self.readingMessageInfo.is_none() {
            self.readingMessageInfo.set_default();
        }
        self.readingMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMessageInfo(&mut self) -> super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.take().unwrap_or_else(|| super::commonmodule::ReadingMessageInfo::new())
    }

    // .commonmodule.ESS ess = 2;


    pub fn get_ess(&self) -> &super::commonmodule::ESS {
        self.ess.as_ref().unwrap_or_else(|| <super::commonmodule::ESS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ess(&mut self) {
        self.ess.clear();
    }

    pub fn has_ess(&self) -> bool {
        self.ess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ess(&mut self, v: super::commonmodule::ESS) {
        self.ess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ess(&mut self) -> &mut super::commonmodule::ESS {
        if self.ess.is_none() {
            self.ess.set_default();
        }
        self.ess.as_mut().unwrap()
    }

    // Take field
    pub fn take_ess(&mut self) -> super::commonmodule::ESS {
        self.ess.take().unwrap_or_else(|| super::commonmodule::ESS::new())
    }

    // .essmodule.ESSReading essReading = 3;


    pub fn get_essReading(&self) -> &ESSReading {
        self.essReading.as_ref().unwrap_or_else(|| <ESSReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essReading(&mut self) {
        self.essReading.clear();
    }

    pub fn has_essReading(&self) -> bool {
        self.essReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essReading(&mut self, v: ESSReading) {
        self.essReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essReading(&mut self) -> &mut ESSReading {
        if self.essReading.is_none() {
            self.essReading.set_default();
        }
        self.essReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_essReading(&mut self) -> ESSReading {
        self.essReading.take().unwrap_or_else(|| ESSReading::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for ESSReadingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.readingMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ess)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essReading)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ess.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essReading.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSReadingProfile {
        ESSReadingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMessageInfo>>(
                "readingMessageInfo",
                |m: &ESSReadingProfile| { &m.readingMessageInfo },
                |m: &mut ESSReadingProfile| { &mut m.readingMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ESS>>(
                "ess",
                |m: &ESSReadingProfile| { &m.ess },
                |m: &mut ESSReadingProfile| { &mut m.ess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSReading>>(
                "essReading",
                |m: &ESSReadingProfile| { &m.essReading },
                |m: &mut ESSReadingProfile| { &mut m.essReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &ESSReadingProfile| { &m.ied },
                |m: &mut ESSReadingProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSReadingProfile>(
                "ESSReadingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSReadingProfile {
        static instance: ::protobuf::rt::LazyV2<ESSReadingProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSReadingProfile::new)
    }
}

impl ::protobuf::Clear for ESSReadingProfile {
    fn clear(&mut self) {
        self.readingMessageInfo.clear();
        self.ess.clear();
        self.essReading.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSReadingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSReadingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EssStatusZBAT {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    BatSt: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    GriMod: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    Soc: ::protobuf::SingularPtrField<super::commonmodule::MV>,
    Stdby: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EssStatusZBAT {
    fn default() -> &'a EssStatusZBAT {
        <EssStatusZBAT as ::protobuf::Message>::default_instance()
    }
}

impl EssStatusZBAT {
    pub fn new() -> EssStatusZBAT {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.StatusSPS BatSt = 2;


    pub fn get_BatSt(&self) -> &super::commonmodule::StatusSPS {
        self.BatSt.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_BatSt(&mut self) {
        self.BatSt.clear();
    }

    pub fn has_BatSt(&self) -> bool {
        self.BatSt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BatSt(&mut self, v: super::commonmodule::StatusSPS) {
        self.BatSt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BatSt(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.BatSt.is_none() {
            self.BatSt.set_default();
        }
        self.BatSt.as_mut().unwrap()
    }

    // Take field
    pub fn take_BatSt(&mut self) -> super::commonmodule::StatusSPS {
        self.BatSt.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .commonmodule.ENG_GridConnectModeKind GriMod = 3;


    pub fn get_GriMod(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GriMod(&mut self) {
        self.GriMod.clear();
    }

    pub fn has_GriMod(&self) -> bool {
        self.GriMod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GriMod(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.GriMod = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GriMod(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.GriMod.is_none() {
            self.GriMod.set_default();
        }
        self.GriMod.as_mut().unwrap()
    }

    // Take field
    pub fn take_GriMod(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.GriMod.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }

    // .commonmodule.MV Soc = 4;


    pub fn get_Soc(&self) -> &super::commonmodule::MV {
        self.Soc.as_ref().unwrap_or_else(|| <super::commonmodule::MV as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Soc(&mut self) {
        self.Soc.clear();
    }

    pub fn has_Soc(&self) -> bool {
        self.Soc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Soc(&mut self, v: super::commonmodule::MV) {
        self.Soc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Soc(&mut self) -> &mut super::commonmodule::MV {
        if self.Soc.is_none() {
            self.Soc.set_default();
        }
        self.Soc.as_mut().unwrap()
    }

    // Take field
    pub fn take_Soc(&mut self) -> super::commonmodule::MV {
        self.Soc.take().unwrap_or_else(|| super::commonmodule::MV::new())
    }

    // .commonmodule.StatusSPS Stdby = 5;


    pub fn get_Stdby(&self) -> &super::commonmodule::StatusSPS {
        self.Stdby.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Stdby(&mut self) {
        self.Stdby.clear();
    }

    pub fn has_Stdby(&self) -> bool {
        self.Stdby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Stdby(&mut self, v: super::commonmodule::StatusSPS) {
        self.Stdby = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Stdby(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.Stdby.is_none() {
            self.Stdby.set_default();
        }
        self.Stdby.as_mut().unwrap()
    }

    // Take field
    pub fn take_Stdby(&mut self) -> super::commonmodule::StatusSPS {
        self.Stdby.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }
}

impl ::protobuf::Message for EssStatusZBAT {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.BatSt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.GriMod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Soc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Stdby {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BatSt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GriMod)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Soc)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Stdby)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.BatSt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Soc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Stdby.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.BatSt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.GriMod.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Soc.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Stdby.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EssStatusZBAT {
        EssStatusZBAT::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &EssStatusZBAT| { &m.logicalNodeForEventAndStatus },
                |m: &mut EssStatusZBAT| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "BatSt",
                |m: &EssStatusZBAT| { &m.BatSt },
                |m: &mut EssStatusZBAT| { &mut m.BatSt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "GriMod",
                |m: &EssStatusZBAT| { &m.GriMod },
                |m: &mut EssStatusZBAT| { &mut m.GriMod },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::MV>>(
                "Soc",
                |m: &EssStatusZBAT| { &m.Soc },
                |m: &mut EssStatusZBAT| { &mut m.Soc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "Stdby",
                |m: &EssStatusZBAT| { &m.Stdby },
                |m: &mut EssStatusZBAT| { &mut m.Stdby },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EssStatusZBAT>(
                "EssStatusZBAT",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EssStatusZBAT {
        static instance: ::protobuf::rt::LazyV2<EssStatusZBAT> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EssStatusZBAT::new)
    }
}

impl ::protobuf::Clear for EssStatusZBAT {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.BatSt.clear();
        self.GriMod.clear();
        self.Soc.clear();
        self.Stdby.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EssStatusZBAT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EssStatusZBAT {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSStatusZGEN {
    // message fields
    eSSEventAndStatusZGEN: ::protobuf::SingularPtrField<ESSEventAndStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSStatusZGEN {
    fn default() -> &'a ESSStatusZGEN {
        <ESSStatusZGEN as ::protobuf::Message>::default_instance()
    }
}

impl ESSStatusZGEN {
    pub fn new() -> ESSStatusZGEN {
        ::std::default::Default::default()
    }

    // .essmodule.ESSEventAndStatusZGEN eSSEventAndStatusZGEN = 1;


    pub fn get_eSSEventAndStatusZGEN(&self) -> &ESSEventAndStatusZGEN {
        self.eSSEventAndStatusZGEN.as_ref().unwrap_or_else(|| <ESSEventAndStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eSSEventAndStatusZGEN(&mut self) {
        self.eSSEventAndStatusZGEN.clear();
    }

    pub fn has_eSSEventAndStatusZGEN(&self) -> bool {
        self.eSSEventAndStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eSSEventAndStatusZGEN(&mut self, v: ESSEventAndStatusZGEN) {
        self.eSSEventAndStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eSSEventAndStatusZGEN(&mut self) -> &mut ESSEventAndStatusZGEN {
        if self.eSSEventAndStatusZGEN.is_none() {
            self.eSSEventAndStatusZGEN.set_default();
        }
        self.eSSEventAndStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_eSSEventAndStatusZGEN(&mut self) -> ESSEventAndStatusZGEN {
        self.eSSEventAndStatusZGEN.take().unwrap_or_else(|| ESSEventAndStatusZGEN::new())
    }
}

impl ::protobuf::Message for ESSStatusZGEN {
    fn is_initialized(&self) -> bool {
        for v in &self.eSSEventAndStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eSSEventAndStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eSSEventAndStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eSSEventAndStatusZGEN.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSStatusZGEN {
        ESSStatusZGEN::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSEventAndStatusZGEN>>(
                "eSSEventAndStatusZGEN",
                |m: &ESSStatusZGEN| { &m.eSSEventAndStatusZGEN },
                |m: &mut ESSStatusZGEN| { &mut m.eSSEventAndStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSStatusZGEN>(
                "ESSStatusZGEN",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSStatusZGEN {
        static instance: ::protobuf::rt::LazyV2<ESSStatusZGEN> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSStatusZGEN::new)
    }
}

impl ::protobuf::Clear for ESSStatusZGEN {
    fn clear(&mut self) {
        self.eSSEventAndStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSStatusZGEN {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSStatusZGEN {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSStatus {
    // message fields
    statusValue: ::protobuf::SingularPtrField<super::commonmodule::StatusValue>,
    essStatusZBAT: ::protobuf::SingularPtrField<EssStatusZBAT>,
    essStatusZGEN: ::protobuf::SingularPtrField<ESSStatusZGEN>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSStatus {
    fn default() -> &'a ESSStatus {
        <ESSStatus as ::protobuf::Message>::default_instance()
    }
}

impl ESSStatus {
    pub fn new() -> ESSStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusValue statusValue = 1;


    pub fn get_statusValue(&self) -> &super::commonmodule::StatusValue {
        self.statusValue.as_ref().unwrap_or_else(|| <super::commonmodule::StatusValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusValue(&mut self) {
        self.statusValue.clear();
    }

    pub fn has_statusValue(&self) -> bool {
        self.statusValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusValue(&mut self, v: super::commonmodule::StatusValue) {
        self.statusValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusValue(&mut self) -> &mut super::commonmodule::StatusValue {
        if self.statusValue.is_none() {
            self.statusValue.set_default();
        }
        self.statusValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusValue(&mut self) -> super::commonmodule::StatusValue {
        self.statusValue.take().unwrap_or_else(|| super::commonmodule::StatusValue::new())
    }

    // .essmodule.EssStatusZBAT essStatusZBAT = 2;


    pub fn get_essStatusZBAT(&self) -> &EssStatusZBAT {
        self.essStatusZBAT.as_ref().unwrap_or_else(|| <EssStatusZBAT as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essStatusZBAT(&mut self) {
        self.essStatusZBAT.clear();
    }

    pub fn has_essStatusZBAT(&self) -> bool {
        self.essStatusZBAT.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essStatusZBAT(&mut self, v: EssStatusZBAT) {
        self.essStatusZBAT = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essStatusZBAT(&mut self) -> &mut EssStatusZBAT {
        if self.essStatusZBAT.is_none() {
            self.essStatusZBAT.set_default();
        }
        self.essStatusZBAT.as_mut().unwrap()
    }

    // Take field
    pub fn take_essStatusZBAT(&mut self) -> EssStatusZBAT {
        self.essStatusZBAT.take().unwrap_or_else(|| EssStatusZBAT::new())
    }

    // .essmodule.ESSStatusZGEN essStatusZGEN = 3;


    pub fn get_essStatusZGEN(&self) -> &ESSStatusZGEN {
        self.essStatusZGEN.as_ref().unwrap_or_else(|| <ESSStatusZGEN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essStatusZGEN(&mut self) {
        self.essStatusZGEN.clear();
    }

    pub fn has_essStatusZGEN(&self) -> bool {
        self.essStatusZGEN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essStatusZGEN(&mut self, v: ESSStatusZGEN) {
        self.essStatusZGEN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essStatusZGEN(&mut self) -> &mut ESSStatusZGEN {
        if self.essStatusZGEN.is_none() {
            self.essStatusZGEN.set_default();
        }
        self.essStatusZGEN.as_mut().unwrap()
    }

    // Take field
    pub fn take_essStatusZGEN(&mut self) -> ESSStatusZGEN {
        self.essStatusZGEN.take().unwrap_or_else(|| ESSStatusZGEN::new())
    }
}

impl ::protobuf::Message for ESSStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.statusValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essStatusZBAT {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essStatusZGEN {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essStatusZBAT)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essStatusZGEN)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essStatusZBAT.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essStatusZGEN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essStatusZBAT.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essStatusZGEN.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSStatus {
        ESSStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusValue>>(
                "statusValue",
                |m: &ESSStatus| { &m.statusValue },
                |m: &mut ESSStatus| { &mut m.statusValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EssStatusZBAT>>(
                "essStatusZBAT",
                |m: &ESSStatus| { &m.essStatusZBAT },
                |m: &mut ESSStatus| { &mut m.essStatusZBAT },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSStatusZGEN>>(
                "essStatusZGEN",
                |m: &ESSStatus| { &m.essStatusZGEN },
                |m: &mut ESSStatus| { &mut m.essStatusZGEN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSStatus>(
                "ESSStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSStatus {
        static instance: ::protobuf::rt::LazyV2<ESSStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSStatus::new)
    }
}

impl ::protobuf::Clear for ESSStatus {
    fn clear(&mut self) {
        self.statusValue.clear();
        self.essStatusZBAT.clear();
        self.essStatusZGEN.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSStatusProfile {
    // message fields
    statusMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::StatusMessageInfo>,
    ess: ::protobuf::SingularPtrField<super::commonmodule::ESS>,
    essStatus: ::protobuf::SingularPtrField<ESSStatus>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSStatusProfile {
    fn default() -> &'a ESSStatusProfile {
        <ESSStatusProfile as ::protobuf::Message>::default_instance()
    }
}

impl ESSStatusProfile {
    pub fn new() -> ESSStatusProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusMessageInfo statusMessageInfo = 1;


    pub fn get_statusMessageInfo(&self) -> &super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::StatusMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusMessageInfo(&mut self) {
        self.statusMessageInfo.clear();
    }

    pub fn has_statusMessageInfo(&self) -> bool {
        self.statusMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusMessageInfo(&mut self, v: super::commonmodule::StatusMessageInfo) {
        self.statusMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusMessageInfo(&mut self) -> &mut super::commonmodule::StatusMessageInfo {
        if self.statusMessageInfo.is_none() {
            self.statusMessageInfo.set_default();
        }
        self.statusMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusMessageInfo(&mut self) -> super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.take().unwrap_or_else(|| super::commonmodule::StatusMessageInfo::new())
    }

    // .commonmodule.ESS ess = 2;


    pub fn get_ess(&self) -> &super::commonmodule::ESS {
        self.ess.as_ref().unwrap_or_else(|| <super::commonmodule::ESS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ess(&mut self) {
        self.ess.clear();
    }

    pub fn has_ess(&self) -> bool {
        self.ess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ess(&mut self, v: super::commonmodule::ESS) {
        self.ess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ess(&mut self) -> &mut super::commonmodule::ESS {
        if self.ess.is_none() {
            self.ess.set_default();
        }
        self.ess.as_mut().unwrap()
    }

    // Take field
    pub fn take_ess(&mut self) -> super::commonmodule::ESS {
        self.ess.take().unwrap_or_else(|| super::commonmodule::ESS::new())
    }

    // .essmodule.ESSStatus essStatus = 3;


    pub fn get_essStatus(&self) -> &ESSStatus {
        self.essStatus.as_ref().unwrap_or_else(|| <ESSStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essStatus(&mut self) {
        self.essStatus.clear();
    }

    pub fn has_essStatus(&self) -> bool {
        self.essStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essStatus(&mut self, v: ESSStatus) {
        self.essStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essStatus(&mut self) -> &mut ESSStatus {
        if self.essStatus.is_none() {
            self.essStatus.set_default();
        }
        self.essStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_essStatus(&mut self) -> ESSStatus {
        self.essStatus.take().unwrap_or_else(|| ESSStatus::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for ESSStatusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.statusMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ess)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essStatus)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ess.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essStatus.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSStatusProfile {
        ESSStatusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusMessageInfo>>(
                "statusMessageInfo",
                |m: &ESSStatusProfile| { &m.statusMessageInfo },
                |m: &mut ESSStatusProfile| { &mut m.statusMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ESS>>(
                "ess",
                |m: &ESSStatusProfile| { &m.ess },
                |m: &mut ESSStatusProfile| { &mut m.ess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSStatus>>(
                "essStatus",
                |m: &ESSStatusProfile| { &m.essStatus },
                |m: &mut ESSStatusProfile| { &mut m.essStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &ESSStatusProfile| { &m.ied },
                |m: &mut ESSStatusProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSStatusProfile>(
                "ESSStatusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSStatusProfile {
        static instance: ::protobuf::rt::LazyV2<ESSStatusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSStatusProfile::new)
    }
}

impl ::protobuf::Clear for ESSStatusProfile {
    fn clear(&mut self) {
        self.statusMessageInfo.clear();
        self.ess.clear();
        self.essStatus.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSStatusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSStatusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSPoint {
    // message fields
    blackStartEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    frequencySetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    function: ::protobuf::SingularPtrField<ESSFunction>,
    mode: ::protobuf::SingularPtrField<super::commonmodule::ENG_GridConnectModeKind>,
    pctHzDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pctVDroop: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    reset: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    syncBackToGrid: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    transToIslndOnGridLossEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    voltageSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    startTime: ::protobuf::SingularPtrField<super::commonmodule::ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSPoint {
    fn default() -> &'a ESSPoint {
        <ESSPoint as ::protobuf::Message>::default_instance()
    }
}

impl ESSPoint {
    pub fn new() -> ESSPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlDPC blackStartEnabled = 1;


    pub fn get_blackStartEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.blackStartEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackStartEnabled(&mut self) {
        self.blackStartEnabled.clear();
    }

    pub fn has_blackStartEnabled(&self) -> bool {
        self.blackStartEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackStartEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.blackStartEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackStartEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.blackStartEnabled.is_none() {
            self.blackStartEnabled.set_default();
        }
        self.blackStartEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackStartEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.blackStartEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC frequencySetPointEnabled = 2;


    pub fn get_frequencySetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frequencySetPointEnabled(&mut self) {
        self.frequencySetPointEnabled.clear();
    }

    pub fn has_frequencySetPointEnabled(&self) -> bool {
        self.frequencySetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequencySetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.frequencySetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequencySetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.frequencySetPointEnabled.is_none() {
            self.frequencySetPointEnabled.set_default();
        }
        self.frequencySetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequencySetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.frequencySetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .essmodule.ESSFunction function = 3;


    pub fn get_function(&self) -> &ESSFunction {
        self.function.as_ref().unwrap_or_else(|| <ESSFunction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    pub fn has_function(&self) -> bool {
        self.function.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ESSFunction) {
        self.function = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ESSFunction {
        if self.function.is_none() {
            self.function.set_default();
        }
        self.function.as_mut().unwrap()
    }

    // Take field
    pub fn take_function(&mut self) -> ESSFunction {
        self.function.take().unwrap_or_else(|| ESSFunction::new())
    }

    // .commonmodule.ENG_GridConnectModeKind mode = 4;


    pub fn get_mode(&self) -> &super::commonmodule::ENG_GridConnectModeKind {
        self.mode.as_ref().unwrap_or_else(|| <super::commonmodule::ENG_GridConnectModeKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::commonmodule::ENG_GridConnectModeKind) {
        self.mode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut super::commonmodule::ENG_GridConnectModeKind {
        if self.mode.is_none() {
            self.mode.set_default();
        }
        self.mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_mode(&mut self) -> super::commonmodule::ENG_GridConnectModeKind {
        self.mode.take().unwrap_or_else(|| super::commonmodule::ENG_GridConnectModeKind::new())
    }

    // .google.protobuf.FloatValue pctHzDroop = 5;


    pub fn get_pctHzDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctHzDroop(&mut self) {
        self.pctHzDroop.clear();
    }

    pub fn has_pctHzDroop(&self) -> bool {
        self.pctHzDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctHzDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctHzDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctHzDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctHzDroop.is_none() {
            self.pctHzDroop.set_default();
        }
        self.pctHzDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctHzDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctHzDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue pctVDroop = 6;


    pub fn get_pctVDroop(&self) -> &::protobuf::well_known_types::FloatValue {
        self.pctVDroop.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pctVDroop(&mut self) {
        self.pctVDroop.clear();
    }

    pub fn has_pctVDroop(&self) -> bool {
        self.pctVDroop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pctVDroop(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.pctVDroop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pctVDroop(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.pctVDroop.is_none() {
            self.pctVDroop.set_default();
        }
        self.pctVDroop.as_mut().unwrap()
    }

    // Take field
    pub fn take_pctVDroop(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.pctVDroop.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .commonmodule.RampRate rampRates = 7;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 8;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 9;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC reset = 10;


    pub fn get_reset(&self) -> &super::commonmodule::ControlDPC {
        self.reset.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: super::commonmodule::ControlDPC) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> super::commonmodule::ControlDPC {
        self.reset.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 11;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlDPC syncBackToGrid = 12;


    pub fn get_syncBackToGrid(&self) -> &super::commonmodule::ControlDPC {
        self.syncBackToGrid.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_syncBackToGrid(&mut self) {
        self.syncBackToGrid.clear();
    }

    pub fn has_syncBackToGrid(&self) -> bool {
        self.syncBackToGrid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBackToGrid(&mut self, v: super::commonmodule::ControlDPC) {
        self.syncBackToGrid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syncBackToGrid(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.syncBackToGrid.is_none() {
            self.syncBackToGrid.set_default();
        }
        self.syncBackToGrid.as_mut().unwrap()
    }

    // Take field
    pub fn take_syncBackToGrid(&mut self) -> super::commonmodule::ControlDPC {
        self.syncBackToGrid.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC transToIslndOnGridLossEnabled = 13;


    pub fn get_transToIslndOnGridLossEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transToIslndOnGridLossEnabled(&mut self) {
        self.transToIslndOnGridLossEnabled.clear();
    }

    pub fn has_transToIslndOnGridLossEnabled(&self) -> bool {
        self.transToIslndOnGridLossEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transToIslndOnGridLossEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.transToIslndOnGridLossEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transToIslndOnGridLossEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.transToIslndOnGridLossEnabled.is_none() {
            self.transToIslndOnGridLossEnabled.set_default();
        }
        self.transToIslndOnGridLossEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_transToIslndOnGridLossEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.transToIslndOnGridLossEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC voltageSetPointEnabled = 14;


    pub fn get_voltageSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voltageSetPointEnabled(&mut self) {
        self.voltageSetPointEnabled.clear();
    }

    pub fn has_voltageSetPointEnabled(&self) -> bool {
        self.voltageSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voltageSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.voltageSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voltageSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.voltageSetPointEnabled.is_none() {
            self.voltageSetPointEnabled.set_default();
        }
        self.voltageSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_voltageSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.voltageSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlTimestamp startTime = 15;


    pub fn get_startTime(&self) -> &super::commonmodule::ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <super::commonmodule::ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::commonmodule::ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::commonmodule::ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::commonmodule::ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| super::commonmodule::ControlTimestamp::new())
    }
}

impl ::protobuf::Message for ESSPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.blackStartEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequencySetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.function {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctHzDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pctVDroop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.syncBackToGrid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transToIslndOnGridLossEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voltageSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackStartEnabled)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequencySetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mode)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctHzDroop)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pctVDroop)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.syncBackToGrid)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transToIslndOnGridLossEnabled)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voltageSetPointEnabled)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blackStartEnabled.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequencySetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.function.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mode.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctHzDroop.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pctVDroop.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.syncBackToGrid.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transToIslndOnGridLossEnabled.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voltageSetPointEnabled.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSPoint {
        ESSPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "blackStartEnabled",
                |m: &ESSPoint| { &m.blackStartEnabled },
                |m: &mut ESSPoint| { &mut m.blackStartEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "frequencySetPointEnabled",
                |m: &ESSPoint| { &m.frequencySetPointEnabled },
                |m: &mut ESSPoint| { &mut m.frequencySetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSFunction>>(
                "function",
                |m: &ESSPoint| { &m.function },
                |m: &mut ESSPoint| { &mut m.function },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENG_GridConnectModeKind>>(
                "mode",
                |m: &ESSPoint| { &m.mode },
                |m: &mut ESSPoint| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctHzDroop",
                |m: &ESSPoint| { &m.pctHzDroop },
                |m: &mut ESSPoint| { &mut m.pctHzDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "pctVDroop",
                |m: &ESSPoint| { &m.pctVDroop },
                |m: &mut ESSPoint| { &mut m.pctVDroop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &ESSPoint| { &m.rampRates },
                |m: &mut ESSPoint| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &ESSPoint| { &m.reactivePwrSetPointEnabled },
                |m: &mut ESSPoint| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &ESSPoint| { &m.realPwrSetPointEnabled },
                |m: &mut ESSPoint| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reset",
                |m: &ESSPoint| { &m.reset },
                |m: &mut ESSPoint| { &mut m.reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &ESSPoint| { &m.state },
                |m: &mut ESSPoint| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "syncBackToGrid",
                |m: &ESSPoint| { &m.syncBackToGrid },
                |m: &mut ESSPoint| { &mut m.syncBackToGrid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "transToIslndOnGridLossEnabled",
                |m: &ESSPoint| { &m.transToIslndOnGridLossEnabled },
                |m: &mut ESSPoint| { &mut m.transToIslndOnGridLossEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "voltageSetPointEnabled",
                |m: &ESSPoint| { &m.voltageSetPointEnabled },
                |m: &mut ESSPoint| { &mut m.voltageSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlTimestamp>>(
                "startTime",
                |m: &ESSPoint| { &m.startTime },
                |m: &mut ESSPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSPoint>(
                "ESSPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSPoint {
        static instance: ::protobuf::rt::LazyV2<ESSPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSPoint::new)
    }
}

impl ::protobuf::Clear for ESSPoint {
    fn clear(&mut self) {
        self.blackStartEnabled.clear();
        self.frequencySetPointEnabled.clear();
        self.function.clear();
        self.mode.clear();
        self.pctHzDroop.clear();
        self.pctVDroop.clear();
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.reset.clear();
        self.state.clear();
        self.syncBackToGrid.clear();
        self.transToIslndOnGridLossEnabled.clear();
        self.voltageSetPointEnabled.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<ESSPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSCSG {
    fn default() -> &'a ESSCSG {
        <ESSCSG as ::protobuf::Message>::default_instance()
    }
}

impl ESSCSG {
    pub fn new() -> ESSCSG {
        ::std::default::Default::default()
    }

    // repeated .essmodule.ESSPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[ESSPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<ESSPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<ESSPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<ESSPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ESSCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSCSG {
        ESSCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSPoint>>(
                "crvPts",
                |m: &ESSCSG| { &m.crvPts },
                |m: &mut ESSCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSCSG>(
                "ESSCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSCSG {
        static instance: ::protobuf::rt::LazyV2<ESSCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSCSG::new)
    }
}

impl ::protobuf::Clear for ESSCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<ESSCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSControlScheduleFSCH {
    fn default() -> &'a ESSControlScheduleFSCH {
        <ESSControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl ESSControlScheduleFSCH {
    pub fn new() -> ESSControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .essmodule.ESSCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &ESSCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <ESSCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: ESSCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut ESSCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> ESSCSG {
        self.ValDCSG.take().unwrap_or_else(|| ESSCSG::new())
    }
}

impl ::protobuf::Message for ESSControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSControlScheduleFSCH {
        ESSControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSCSG>>(
                "ValDCSG",
                |m: &ESSControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut ESSControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSControlScheduleFSCH>(
                "ESSControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<ESSControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for ESSControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EssControlFSCC {
    // message fields
    controlFSCC: ::protobuf::SingularPtrField<super::commonmodule::ControlFSCC>,
    essControlScheduleFSCH: ::protobuf::SingularPtrField<ESSControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EssControlFSCC {
    fn default() -> &'a EssControlFSCC {
        <EssControlFSCC as ::protobuf::Message>::default_instance()
    }
}

impl EssControlFSCC {
    pub fn new() -> EssControlFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlFSCC controlFSCC = 1;


    pub fn get_controlFSCC(&self) -> &super::commonmodule::ControlFSCC {
        self.controlFSCC.as_ref().unwrap_or_else(|| <super::commonmodule::ControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlFSCC(&mut self) {
        self.controlFSCC.clear();
    }

    pub fn has_controlFSCC(&self) -> bool {
        self.controlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlFSCC(&mut self, v: super::commonmodule::ControlFSCC) {
        self.controlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlFSCC(&mut self) -> &mut super::commonmodule::ControlFSCC {
        if self.controlFSCC.is_none() {
            self.controlFSCC.set_default();
        }
        self.controlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlFSCC(&mut self) -> super::commonmodule::ControlFSCC {
        self.controlFSCC.take().unwrap_or_else(|| super::commonmodule::ControlFSCC::new())
    }

    // .essmodule.ESSControlScheduleFSCH essControlScheduleFSCH = 2;


    pub fn get_essControlScheduleFSCH(&self) -> &ESSControlScheduleFSCH {
        self.essControlScheduleFSCH.as_ref().unwrap_or_else(|| <ESSControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essControlScheduleFSCH(&mut self) {
        self.essControlScheduleFSCH.clear();
    }

    pub fn has_essControlScheduleFSCH(&self) -> bool {
        self.essControlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essControlScheduleFSCH(&mut self, v: ESSControlScheduleFSCH) {
        self.essControlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essControlScheduleFSCH(&mut self) -> &mut ESSControlScheduleFSCH {
        if self.essControlScheduleFSCH.is_none() {
            self.essControlScheduleFSCH.set_default();
        }
        self.essControlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_essControlScheduleFSCH(&mut self) -> ESSControlScheduleFSCH {
        self.essControlScheduleFSCH.take().unwrap_or_else(|| ESSControlScheduleFSCH::new())
    }
}

impl ::protobuf::Message for EssControlFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.controlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlFSCC)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essControlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlFSCC.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essControlScheduleFSCH.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EssControlFSCC {
        EssControlFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlFSCC>>(
                "controlFSCC",
                |m: &EssControlFSCC| { &m.controlFSCC },
                |m: &mut EssControlFSCC| { &mut m.controlFSCC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSControlScheduleFSCH>>(
                "essControlScheduleFSCH",
                |m: &EssControlFSCC| { &m.essControlScheduleFSCH },
                |m: &mut EssControlFSCC| { &mut m.essControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EssControlFSCC>(
                "EssControlFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EssControlFSCC {
        static instance: ::protobuf::rt::LazyV2<EssControlFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EssControlFSCC::new)
    }
}

impl ::protobuf::Clear for EssControlFSCC {
    fn clear(&mut self) {
        self.controlFSCC.clear();
        self.essControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EssControlFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EssControlFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSControl {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    essControlFSCC: ::protobuf::SingularPtrField<EssControlFSCC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSControl {
    fn default() -> &'a ESSControl {
        <ESSControl as ::protobuf::Message>::default_instance()
    }
}

impl ESSControl {
    pub fn new() -> ESSControl {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .essmodule.EssControlFSCC essControlFSCC = 3;


    pub fn get_essControlFSCC(&self) -> &EssControlFSCC {
        self.essControlFSCC.as_ref().unwrap_or_else(|| <EssControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essControlFSCC(&mut self) {
        self.essControlFSCC.clear();
    }

    pub fn has_essControlFSCC(&self) -> bool {
        self.essControlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essControlFSCC(&mut self, v: EssControlFSCC) {
        self.essControlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essControlFSCC(&mut self) -> &mut EssControlFSCC {
        if self.essControlFSCC.is_none() {
            self.essControlFSCC.set_default();
        }
        self.essControlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_essControlFSCC(&mut self) -> EssControlFSCC {
        self.essControlFSCC.take().unwrap_or_else(|| EssControlFSCC::new())
    }
}

impl ::protobuf::Message for ESSControl {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essControlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essControlFSCC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essControlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essControlFSCC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSControl {
        ESSControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &ESSControl| { &m.controlValue },
                |m: &mut ESSControl| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &ESSControl| { &m.check },
                |m: &mut ESSControl| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EssControlFSCC>>(
                "essControlFSCC",
                |m: &ESSControl| { &m.essControlFSCC },
                |m: &mut ESSControl| { &mut m.essControlFSCC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSControl>(
                "ESSControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSControl {
        static instance: ::protobuf::rt::LazyV2<ESSControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSControl::new)
    }
}

impl ::protobuf::Clear for ESSControl {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.essControlFSCC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ESSControlProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    ess: ::protobuf::SingularPtrField<super::commonmodule::ESS>,
    essControl: ::protobuf::SingularPtrField<ESSControl>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESSControlProfile {
    fn default() -> &'a ESSControlProfile {
        <ESSControlProfile as ::protobuf::Message>::default_instance()
    }
}

impl ESSControlProfile {
    pub fn new() -> ESSControlProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.ESS ess = 2;


    pub fn get_ess(&self) -> &super::commonmodule::ESS {
        self.ess.as_ref().unwrap_or_else(|| <super::commonmodule::ESS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ess(&mut self) {
        self.ess.clear();
    }

    pub fn has_ess(&self) -> bool {
        self.ess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ess(&mut self, v: super::commonmodule::ESS) {
        self.ess = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ess(&mut self) -> &mut super::commonmodule::ESS {
        if self.ess.is_none() {
            self.ess.set_default();
        }
        self.ess.as_mut().unwrap()
    }

    // Take field
    pub fn take_ess(&mut self) -> super::commonmodule::ESS {
        self.ess.take().unwrap_or_else(|| super::commonmodule::ESS::new())
    }

    // .essmodule.ESSControl essControl = 3;


    pub fn get_essControl(&self) -> &ESSControl {
        self.essControl.as_ref().unwrap_or_else(|| <ESSControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_essControl(&mut self) {
        self.essControl.clear();
    }

    pub fn has_essControl(&self) -> bool {
        self.essControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essControl(&mut self, v: ESSControl) {
        self.essControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_essControl(&mut self) -> &mut ESSControl {
        if self.essControl.is_none() {
            self.essControl.set_default();
        }
        self.essControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_essControl(&mut self) -> ESSControl {
        self.essControl.take().unwrap_or_else(|| ESSControl::new())
    }

    // .commonmodule.IED ied = 4;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }
}

impl ::protobuf::Message for ESSControlProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ess {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.essControl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ess)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.essControl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ess.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.essControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ess.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.essControl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESSControlProfile {
        ESSControlProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &ESSControlProfile| { &m.controlMessageInfo },
                |m: &mut ESSControlProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ESS>>(
                "ess",
                |m: &ESSControlProfile| { &m.ess },
                |m: &mut ESSControlProfile| { &mut m.ess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ESSControl>>(
                "essControl",
                |m: &ESSControlProfile| { &m.essControl },
                |m: &mut ESSControlProfile| { &mut m.essControl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &ESSControlProfile| { &m.ied },
                |m: &mut ESSControlProfile| { &mut m.ied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ESSControlProfile>(
                "ESSControlProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ESSControlProfile {
        static instance: ::protobuf::rt::LazyV2<ESSControlProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ESSControlProfile::new)
    }
}

impl ::protobuf::Clear for ESSControlProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.ess.clear();
        self.essControl.clear();
        self.ied.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESSControlProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESSControlProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19essmodule/essmodule.proto\x12\tessmodule\"\xf0\x02\n\x0cEssEventZB\
    AT\x12t\n\x1clogicalNodeForEventAndStatus\x18\x01\x20\x01(\x0b2*.commonm\
    odule.LogicalNodeForEventAndStatusR\x1clogicalNodeForEventAndStatusB\x04\
    \x80\xb5\x18\x01\x12/\n\x05BatHi\x18\x02\x20\x01(\x0b2\x17.commonmodule.\
    StatusSPSR\x05BatHiB\0\x12/\n\x05BatLo\x18\x03\x20\x01(\x0b2\x17.commonm\
    odule.StatusSPSR\x05BatLoB\0\x12/\n\x05BatSt\x18\x04\x20\x01(\x0b2\x17.c\
    ommonmodule.StatusSPSR\x05BatStB\0\x12$\n\x03Soc\x18\x05\x20\x01(\x0b2\
    \x10.commonmodule.MVR\x03SocB\0\x12/\n\x05Stdby\x18\x06\x20\x01(\x0b2\
    \x17.commonmodule.StatusSPSR\x05StdbyB\0:\0\"\xca\x05\n\x13FrequencyRegu\
    lation\x12U\n\x16frequencyDeadBandMinus\x18\x01\x20\x01(\x0b2\x1b.google\
    .protobuf.FloatValueR\x16frequencyDeadBandMinusB\0\x12S\n\x15frequencyDe\
    adBandPlus\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x15freq\
    uencyDeadBandPlusB\0\x12T\n\x16frequencyRegulationCtl\x18\x03\x20\x01(\
    \x0b2\x1a.google.protobuf.BoolValueR\x16frequencyRegulationCtlB\0\x12K\n\
    \x11frequencySetPoint\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.FloatVal\
    ueR\x11frequencySetPointB\0\x12a\n\x1cgridFrequencyStableBandMinus\x18\
    \x05\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x1cgridFrequencyStabl\
    eBandMinusB\0\x12_\n\x1bgridFrequencyStableBandPlus\x18\x06\x20\x01(\x0b\
    2\x1b.google.protobuf.FloatValueR\x1bgridFrequencyStableBandPlusB\0\x12M\
    \n\x12overFrequencyDroop\x18\x07\x20\x01(\x0b2\x1b.google.protobuf.Float\
    ValueR\x12overFrequencyDroopB\0\x12O\n\x13underFrequencyDroop\x18\x08\
    \x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x13underFrequencyDroopB\0\
    :\0\"\xb3\x03\n\x0bPeakShaving\x12I\n\x10baseShavingLimit\x18\x01\x20\
    \x01(\x0b2\x1b.google.protobuf.FloatValueR\x10baseShavingLimitB\0\x12D\n\
    \x0epeakShavingCtl\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\
    \x0epeakShavingCtlB\0\x12I\n\x10peakShavingLimit\x18\x03\x20\x01(\x0b2\
    \x1b.google.protobuf.FloatValueR\x10peakShavingLimitB\0\x12c\n\x1dsocMan\
    agementAllowedHighLimit\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.FloatV\
    alueR\x1dsocManagementAllowedHighLimitB\0\x12a\n\x1csocManagementAllowed\
    LowLimit\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x1csocMan\
    agementAllowedLowLimitB\0:\0\"\xfc\x02\n\x08SocLimit\x12A\n\x0csocHighLi\
    mit\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x0csocHighLimi\
    tB\0\x12U\n\x16socHighLimitHysteresis\x18\x02\x20\x01(\x0b2\x1b.google.p\
    rotobuf.FloatValueR\x16socHighLimitHysteresisB\0\x12>\n\x0bsocLimitCtl\
    \x18\x03\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x0bsocLimitCtlB\0\
    \x12?\n\x0bsocLowLimit\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.FloatVa\
    lueR\x0bsocLowLimitB\0\x12S\n\x15socLowLimitHysteresis\x18\x05\x20\x01(\
    \x0b2\x1b.google.protobuf.FloatValueR\x15socLowLimitHysteresisB\0:\0\"\
    \xfb\x02\n\rSOCManagement\x12I\n\x10socDeadBandMinus\x18\x01\x20\x01(\
    \x0b2\x1b.google.protobuf.FloatValueR\x10socDeadBandMinusB\0\x12G\n\x0fs\
    ocDeadBandPlus\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x0f\
    socDeadBandPlusB\0\x12H\n\x10socManagementCtl\x18\x03\x20\x01(\x0b2\x1a.\
    google.protobuf.BoolValueR\x10socManagementCtlB\0\x12I\n\x10socPowerSetP\
    oint\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\x10socPowerSe\
    tPointB\0\x12?\n\x0bsocSetPoint\x18\x05\x20\x01(\x0b2\x1b.google.protobu\
    f.FloatValueR\x0bsocSetPointB\0:\0\"\x9a\x03\n\x11VoltageRegulation\x12I\
    \n\x10overVoltageDroop\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.FloatVa\
    lueR\x10overVoltageDroopB\0\x12K\n\x11underVoltageDroop\x18\x02\x20\x01(\
    \x0b2\x1b.google.protobuf.FloatValueR\x11underVoltageDroopB\0\x12Q\n\x14\
    voltageDeadBandMinus\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.FloatValu\
    eR\x14voltageDeadBandMinusB\0\x12O\n\x13voltageDeadBandPlus\x18\x04\x20\
    \x01(\x0b2\x1b.google.protobuf.FloatValueR\x13voltageDeadBandPlusB\0\x12\
    G\n\x0fvoltageSetPoint\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.FloatVa\
    lueR\x0fvoltageSetPointB\0:\0\"\xa6\x01\n\x0cVoltageDroop\x12F\n\x0fvolt\
    ageDroopCtl\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x0fvolt\
    ageDroopCtlB\0\x12L\n\x11voltageRegulation\x18\x02\x20\x01(\x0b2\x1c.ess\
    module.VoltageRegulationR\x11voltageRegulationB\0:\0\"\x9d\x01\n\tVoltag\
    ePI\x12@\n\x0cvoltagePICtl\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Boo\
    lValueR\x0cvoltagePICtlB\0\x12L\n\x11voltageRegulation\x18\x02\x20\x01(\
    \x0b2\x1c.essmodule.VoltageRegulationR\x11voltageRegulationB\0:\0\"\xff\
    \x01\n\x0fCapacityFirming\x12L\n\x12capacityFirmingCtl\x18\x01\x20\x01(\
    \x0b2\x1a.google.protobuf.BoolValueR\x12capacityFirmingCtlB\0\x12M\n\x13\
    limitNegative_dp_dt\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.FloatValue\
    R\x11limitNegativeDpDtB\0\x12M\n\x13limitPositive_dp_dt\x18\x03\x20\x01(\
    \x0b2\x1b.google.protobuf.FloatValueR\x11limitPositiveDpDtB\0:\0\"\xd1\
    \x03\n\x0bESSFunction\x12F\n\x0fcapacityFirming\x18\x01\x20\x01(\x0b2\
    \x1a.essmodule.CapacityFirmingR\x0fcapacityFirmingB\0\x12R\n\x13frequenc\
    yRegulation\x18\x02\x20\x01(\x0b2\x1e.essmodule.FrequencyRegulationR\x13\
    frequencyRegulationB\0\x12:\n\x0bpeakShaving\x18\x03\x20\x01(\x0b2\x16.e\
    ssmodule.PeakShavingR\x0bpeakShavingB\0\x121\n\x08socLimit\x18\x04\x20\
    \x01(\x0b2\x13.essmodule.SocLimitR\x08socLimitB\0\x12@\n\rsocManagement\
    \x18\x05\x20\x01(\x0b2\x18.essmodule.SOCManagementR\rsocManagementB\0\
    \x12=\n\x0cvoltageDroop\x18\x06\x20\x01(\x0b2\x17.essmodule.VoltageDroop\
    R\x0cvoltageDroopB\0\x124\n\tvoltagePI\x18\x07\x20\x01(\x0b2\x14.essmodu\
    le.VoltagePIR\tvoltagePIB\0:\0\"\xbf\x07\n\x0eESSPointStatus\x12H\n\x11b\
    lackStartEnabled\x18\x01\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x11b\
    lackStartEnabledB\0\x12V\n\x18frequencySetPointEnabled\x18\x02\x20\x01(\
    \x0b2\x18.commonmodule.ControlDPCR\x18frequencySetPointEnabledB\0\x124\n\
    \x08function\x18\x03\x20\x01(\x0b2\x16.essmodule.ESSFunctionR\x08functio\
    nB\0\x12;\n\x04mode\x18\x04\x20\x01(\x0b2%.commonmodule.ENG_GridConnectM\
    odeKindR\x04modeB\0\x12=\n\npctHzDroop\x18\x05\x20\x01(\x0b2\x1b.google.\
    protobuf.FloatValueR\npctHzDroopB\0\x12;\n\tpctVDroop\x18\x06\x20\x01(\
    \x0b2\x1b.google.protobuf.FloatValueR\tpctVDroopB\0\x126\n\trampRates\
    \x18\x07\x20\x01(\x0b2\x16.commonmodule.RampRateR\trampRatesB\0\x12Z\n\
    \x1areactivePwrSetPointEnabled\x18\x08\x20\x01(\x0b2\x18.commonmodule.Co\
    ntrolDPCR\x1areactivePwrSetPointEnabledB\0\x12R\n\x16realPwrSetPointEnab\
    led\x18\t\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16realPwrSetPointE\
    nabledB\0\x128\n\x05state\x18\n\x20\x01(\x0b2\x20.commonmodule.Optional_\
    StateKindR\x05stateB\0\x12B\n\x0esyncBackToGrid\x18\x0b\x20\x01(\x0b2\
    \x18.commonmodule.ControlDPCR\x0esyncBackToGridB\0\x12`\n\x1dtransToIsln\
    dOnGridLossEnabled\x18\x0c\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x1dtransToIslndOnGridLossEnabledB\0\x12R\n\x16voltageSetPointEnabled\
    \x18\r\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16voltageSetPointEnab\
    ledB\0:\0\"\xb6\x03\n\x15ESSEventAndStatusZGEN\x12t\n\x1clogicalNodeForE\
    ventAndStatus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeForEventAnd\
    StatusR\x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\x125\n\x08A\
    uxPwrSt\x18\x02\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x08AuxPwrStB\0\
    \x12E\n\x0bDynamicTest\x18\x03\x20\x01(\x0b2!.commonmodule.ENS_DynamicTe\
    stKindR\x0bDynamicTestB\0\x123\n\x07EmgStop\x18\x04\x20\x01(\x0b2\x17.co\
    mmonmodule.StatusSPSR\x07EmgStopB\0\x123\n\x07GnSynSt\x18\x05\x20\x01(\
    \x0b2\x17.commonmodule.StatusSPSR\x07GnSynStB\0\x12=\n\x0bPointStatus\
    \x18\x06\x20\x01(\x0b2\x19.essmodule.ESSPointStatusR\x0bPointStatusB\0:\
    \0\"n\n\x0cESSEventZGEN\x12\\\n\x15eSSEventAndStatusZGEN\x18\x01\x20\x01\
    (\x0b2\x20.essmodule.ESSEventAndStatusZGENR\x15eSSEventAndStatusZGENB\
    \x04\x80\xb5\x18\x01:\0\"\xca\x01\n\x08ESSEvent\x12>\n\neventValue\x18\
    \x01\x20\x01(\x0b2\x18.commonmodule.EventValueR\neventValueB\x04\x80\xb5\
    \x18\x01\x12=\n\x0cessEventZBAT\x18\x02\x20\x01(\x0b2\x17.essmodule.EssE\
    ventZBATR\x0cessEventZBATB\0\x12=\n\x0cessEventZGEN\x18\x03\x20\x01(\x0b\
    2\x17.essmodule.ESSEventZGENR\x0cessEventZGENB\0:\0\"\x82\x02\n\x0fESSEv\
    entProfile\x12P\n\x10eventMessageInfo\x18\x01\x20\x01(\x0b2\x1e.commonmo\
    dule.EventMessageInfoR\x10eventMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\
    \x03ess\x18\x02\x20\x01(\x0b2\x11.commonmodule.ESSR\x03essB\x08\x90\xb5\
    \x18\x01\x88\xb5\x18\x01\x129\n\x08essEvent\x18\x03\x20\x01(\x0b2\x13.es\
    smodule.ESSEventR\x08essEventB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12-\
    \n\x03ied\x18\x04\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x88\
    \xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\xce\x02\n\nESSReadin\
    g\x12\x86\x01\n\"conductingEquipmentTerminalReading\x18\x01\x20\x01(\x0b\
    20.commonmodule.ConductingEquipmentTerminalReadingR\"conductingEquipment\
    TerminalReadingB\x04\x80\xb5\x18\x01\x127\n\tphaseMMTN\x18\x02\x20\x01(\
    \x0b2\x17.commonmodule.PhaseMMTNR\tphaseMMTNB\0\x12=\n\x0breadingMMTR\
    \x18\x03\x20\x01(\x0b2\x19.commonmodule.ReadingMMTRR\x0breadingMMTRB\0\
    \x12=\n\x0breadingMMXU\x18\x04\x20\x01(\x0b2\x19.commonmodule.ReadingMMX\
    UR\x0breadingMMXUB\0:\0\"\x90\x02\n\x11ESSReadingProfile\x12V\n\x12readi\
    ngMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ReadingMessageInfoR\
    \x12readingMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03ess\x18\x02\x20\
    \x01(\x0b2\x11.commonmodule.ESSR\x03essB\x08\x88\xb5\x18\x01\x90\xb5\x18\
    \x01\x12?\n\nessReading\x18\x03\x20\x01(\x0b2\x15.essmodule.ESSReadingR\
    \nessReadingB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ied\x18\x04\
    \x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01:\x04\xc0\xf3\x18\x01\"\xd8\x02\n\rEssStatusZBAT\x12t\n\x1clogic\
    alNodeForEventAndStatus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeF\
    orEventAndStatusR\x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\
    \x127\n\x05BatSt\x18\x02\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x05Ba\
    tStB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12?\n\x06GriMod\x18\x03\x20\
    \x01(\x0b2%.commonmodule.ENG_GridConnectModeKindR\x06GriModB\0\x12$\n\
    \x03Soc\x18\x04\x20\x01(\x0b2\x10.commonmodule.MVR\x03SocB\0\x12/\n\x05S\
    tdby\x18\x05\x20\x01(\x0b2\x17.commonmodule.StatusSPSR\x05StdbyB\0:\0\"o\
    \n\rESSStatusZGEN\x12\\\n\x15eSSEventAndStatusZGEN\x18\x01\x20\x01(\x0b2\
    \x20.essmodule.ESSEventAndStatusZGENR\x15eSSEventAndStatusZGENB\x04\x80\
    \xb5\x18\x01:\0\"\xd4\x01\n\tESSStatus\x12A\n\x0bstatusValue\x18\x01\x20\
    \x01(\x0b2\x19.commonmodule.StatusValueR\x0bstatusValueB\x04\x80\xb5\x18\
    \x01\x12@\n\ressStatusZBAT\x18\x02\x20\x01(\x0b2\x18.essmodule.EssStatus\
    ZBATR\ressStatusZBATB\0\x12@\n\ressStatusZGEN\x18\x03\x20\x01(\x0b2\x18.\
    essmodule.ESSStatusZGENR\ressStatusZGENB\0:\0\"\x89\x02\n\x10ESSStatusPr\
    ofile\x12S\n\x11statusMessageInfo\x18\x01\x20\x01(\x0b2\x1f.commonmodule\
    .StatusMessageInfoR\x11statusMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03\
    ess\x18\x02\x20\x01(\x0b2\x11.commonmodule.ESSR\x03essB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01\x12<\n\tessStatus\x18\x03\x20\x01(\x0b2\x14.essmodu\
    le.ESSStatusR\tessStatusB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03\
    ied\x18\x04\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\
    \x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"\xb3\x08\n\x08ESSPoint\x12H\n\
    \x11blackStartEnabled\x18\x01\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x11blackStartEnabledB\0\x12V\n\x18frequencySetPointEnabled\x18\x02\x20\
    \x01(\x0b2\x18.commonmodule.ControlDPCR\x18frequencySetPointEnabledB\0\
    \x124\n\x08function\x18\x03\x20\x01(\x0b2\x16.essmodule.ESSFunctionR\x08\
    functionB\0\x12;\n\x04mode\x18\x04\x20\x01(\x0b2%.commonmodule.ENG_GridC\
    onnectModeKindR\x04modeB\0\x12=\n\npctHzDroop\x18\x05\x20\x01(\x0b2\x1b.\
    google.protobuf.FloatValueR\npctHzDroopB\0\x12;\n\tpctVDroop\x18\x06\x20\
    \x01(\x0b2\x1b.google.protobuf.FloatValueR\tpctVDroopB\0\x126\n\trampRat\
    es\x18\x07\x20\x01(\x0b2\x16.commonmodule.RampRateR\trampRatesB\0\x12Z\n\
    \x1areactivePwrSetPointEnabled\x18\x08\x20\x01(\x0b2\x18.commonmodule.Co\
    ntrolDPCR\x1areactivePwrSetPointEnabledB\0\x12R\n\x16realPwrSetPointEnab\
    led\x18\t\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16realPwrSetPointE\
    nabledB\0\x120\n\x05reset\x18\n\x20\x01(\x0b2\x18.commonmodule.ControlDP\
    CR\x05resetB\0\x128\n\x05state\x18\x0b\x20\x01(\x0b2\x20.commonmodule.Op\
    tional_StateKindR\x05stateB\0\x12B\n\x0esyncBackToGrid\x18\x0c\x20\x01(\
    \x0b2\x18.commonmodule.ControlDPCR\x0esyncBackToGridB\0\x12`\n\x1dtransT\
    oIslndOnGridLossEnabled\x18\r\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x1dtransToIslndOnGridLossEnabledB\0\x12R\n\x16voltageSetPointEnabled\
    \x18\x0e\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x16voltageSetPointEn\
    abledB\0\x12F\n\tstartTime\x18\x0f\x20\x01(\x0b2\x1e.commonmodule.Contro\
    lTimestampR\tstartTimeB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"A\n\x06E\
    SSCSG\x125\n\x06crvPts\x18\x01\x20\x03(\x0b2\x13.essmodule.ESSPointR\x06\
    crvPtsB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"Q\n\x16ESSControlSchedul\
    eFSCH\x125\n\x07ValDCSG\x18\x01\x20\x01(\x0b2\x11.essmodule.ESSCSGR\x07V\
    alDCSGB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xb2\x01\n\x0eEssControl\
    FSCC\x12A\n\x0bcontrolFSCC\x18\x01\x20\x01(\x0b2\x19.commonmodule.Contro\
    lFSCCR\x0bcontrolFSCCB\x04\x80\xb5\x18\x01\x12[\n\x16essControlScheduleF\
    SCH\x18\x02\x20\x01(\x0b2!.essmodule.ESSControlScheduleFSCHR\x16essContr\
    olScheduleFSCHB\0:\0\"\xd8\x01\n\nESSControl\x12D\n\x0ccontrolValue\x18\
    \x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\x0ccontrolValueB\x04\
    \x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\x0b2\x1d.commonmodule.\
    CheckConditionsR\x05checkB\0\x12K\n\x0eessControlFSCC\x18\x03\x20\x01(\
    \x0b2\x19.essmodule.EssControlFSCCR\x0eessControlFSCCB\x08\x88\xb5\x18\
    \x01\x90\xb5\x18\x01:\0\"\x90\x02\n\x11ESSControlProfile\x12V\n\x12contr\
    olMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ControlMessageInfoR\
    \x12controlMessageInfoB\x04\x80\xb5\x18\x01\x12-\n\x03ess\x18\x02\x20\
    \x01(\x0b2\x11.commonmodule.ESSR\x03essB\x08\x90\xb5\x18\x01\x88\xb5\x18\
    \x01\x12?\n\nessControl\x18\x03\x20\x01(\x0b2\x15.essmodule.ESSControlR\
    \nessControlB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ied\x18\x04\
    \x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01:\x04\xc0\xf3\x18\x01B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
