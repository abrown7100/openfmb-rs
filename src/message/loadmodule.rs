// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `loadmodule/loadmodule.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadPoint {
    // message fields
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    reset: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    startTime: ::protobuf::SingularPtrField<super::commonmodule::ControlTimestamp>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadPoint {
    fn default() -> &'a LoadPoint {
        <LoadPoint as ::protobuf::Message>::default_instance()
    }
}

impl LoadPoint {
    pub fn new() -> LoadPoint {
        ::std::default::Default::default()
    }

    // .commonmodule.RampRate rampRates = 1;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 2;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 3;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC reset = 4;


    pub fn get_reset(&self) -> &super::commonmodule::ControlDPC {
        self.reset.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: super::commonmodule::ControlDPC) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> super::commonmodule::ControlDPC {
        self.reset.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 5;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }

    // .commonmodule.ControlTimestamp startTime = 6;


    pub fn get_startTime(&self) -> &super::commonmodule::ControlTimestamp {
        self.startTime.as_ref().unwrap_or_else(|| <super::commonmodule::ControlTimestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::commonmodule::ControlTimestamp) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::commonmodule::ControlTimestamp {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::commonmodule::ControlTimestamp {
        self.startTime.take().unwrap_or_else(|| super::commonmodule::ControlTimestamp::new())
    }
}

impl ::protobuf::Message for LoadPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadPoint {
        LoadPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &LoadPoint| { &m.rampRates },
                |m: &mut LoadPoint| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &LoadPoint| { &m.reactivePwrSetPointEnabled },
                |m: &mut LoadPoint| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &LoadPoint| { &m.realPwrSetPointEnabled },
                |m: &mut LoadPoint| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reset",
                |m: &LoadPoint| { &m.reset },
                |m: &mut LoadPoint| { &mut m.reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &LoadPoint| { &m.state },
                |m: &mut LoadPoint| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlTimestamp>>(
                "startTime",
                |m: &LoadPoint| { &m.startTime },
                |m: &mut LoadPoint| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadPoint>(
                "LoadPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadPoint {
        static instance: ::protobuf::rt::LazyV2<LoadPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadPoint::new)
    }
}

impl ::protobuf::Clear for LoadPoint {
    fn clear(&mut self) {
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.reset.clear();
        self.state.clear();
        self.startTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadCSG {
    // message fields
    crvPts: ::protobuf::RepeatedField<LoadPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadCSG {
    fn default() -> &'a LoadCSG {
        <LoadCSG as ::protobuf::Message>::default_instance()
    }
}

impl LoadCSG {
    pub fn new() -> LoadCSG {
        ::std::default::Default::default()
    }

    // repeated .loadmodule.LoadPoint crvPts = 1;


    pub fn get_crvPts(&self) -> &[LoadPoint] {
        &self.crvPts
    }
    pub fn clear_crvPts(&mut self) {
        self.crvPts.clear();
    }

    // Param is passed by value, moved
    pub fn set_crvPts(&mut self, v: ::protobuf::RepeatedField<LoadPoint>) {
        self.crvPts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_crvPts(&mut self) -> &mut ::protobuf::RepeatedField<LoadPoint> {
        &mut self.crvPts
    }

    // Take field
    pub fn take_crvPts(&mut self) -> ::protobuf::RepeatedField<LoadPoint> {
        ::std::mem::replace(&mut self.crvPts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LoadCSG {
    fn is_initialized(&self) -> bool {
        for v in &self.crvPts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.crvPts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.crvPts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.crvPts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadCSG {
        LoadCSG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadPoint>>(
                "crvPts",
                |m: &LoadCSG| { &m.crvPts },
                |m: &mut LoadCSG| { &mut m.crvPts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadCSG>(
                "LoadCSG",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadCSG {
        static instance: ::protobuf::rt::LazyV2<LoadCSG> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadCSG::new)
    }
}

impl ::protobuf::Clear for LoadCSG {
    fn clear(&mut self) {
        self.crvPts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadCSG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCSG {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadControlScheduleFSCH {
    // message fields
    ValDCSG: ::protobuf::SingularPtrField<LoadCSG>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadControlScheduleFSCH {
    fn default() -> &'a LoadControlScheduleFSCH {
        <LoadControlScheduleFSCH as ::protobuf::Message>::default_instance()
    }
}

impl LoadControlScheduleFSCH {
    pub fn new() -> LoadControlScheduleFSCH {
        ::std::default::Default::default()
    }

    // .loadmodule.LoadCSG ValDCSG = 1;


    pub fn get_ValDCSG(&self) -> &LoadCSG {
        self.ValDCSG.as_ref().unwrap_or_else(|| <LoadCSG as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ValDCSG(&mut self) {
        self.ValDCSG.clear();
    }

    pub fn has_ValDCSG(&self) -> bool {
        self.ValDCSG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ValDCSG(&mut self, v: LoadCSG) {
        self.ValDCSG = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ValDCSG(&mut self) -> &mut LoadCSG {
        if self.ValDCSG.is_none() {
            self.ValDCSG.set_default();
        }
        self.ValDCSG.as_mut().unwrap()
    }

    // Take field
    pub fn take_ValDCSG(&mut self) -> LoadCSG {
        self.ValDCSG.take().unwrap_or_else(|| LoadCSG::new())
    }
}

impl ::protobuf::Message for LoadControlScheduleFSCH {
    fn is_initialized(&self) -> bool {
        for v in &self.ValDCSG {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ValDCSG)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ValDCSG.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ValDCSG.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadControlScheduleFSCH {
        LoadControlScheduleFSCH::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadCSG>>(
                "ValDCSG",
                |m: &LoadControlScheduleFSCH| { &m.ValDCSG },
                |m: &mut LoadControlScheduleFSCH| { &mut m.ValDCSG },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadControlScheduleFSCH>(
                "LoadControlScheduleFSCH",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadControlScheduleFSCH {
        static instance: ::protobuf::rt::LazyV2<LoadControlScheduleFSCH> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadControlScheduleFSCH::new)
    }
}

impl ::protobuf::Clear for LoadControlScheduleFSCH {
    fn clear(&mut self) {
        self.ValDCSG.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadControlScheduleFSCH {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadControlScheduleFSCH {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadControlFSCC {
    // message fields
    controlFSCC: ::protobuf::SingularPtrField<super::commonmodule::ControlFSCC>,
    loadControlScheduleFSCH: ::protobuf::SingularPtrField<LoadControlScheduleFSCH>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadControlFSCC {
    fn default() -> &'a LoadControlFSCC {
        <LoadControlFSCC as ::protobuf::Message>::default_instance()
    }
}

impl LoadControlFSCC {
    pub fn new() -> LoadControlFSCC {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlFSCC controlFSCC = 1;


    pub fn get_controlFSCC(&self) -> &super::commonmodule::ControlFSCC {
        self.controlFSCC.as_ref().unwrap_or_else(|| <super::commonmodule::ControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlFSCC(&mut self) {
        self.controlFSCC.clear();
    }

    pub fn has_controlFSCC(&self) -> bool {
        self.controlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlFSCC(&mut self, v: super::commonmodule::ControlFSCC) {
        self.controlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlFSCC(&mut self) -> &mut super::commonmodule::ControlFSCC {
        if self.controlFSCC.is_none() {
            self.controlFSCC.set_default();
        }
        self.controlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlFSCC(&mut self) -> super::commonmodule::ControlFSCC {
        self.controlFSCC.take().unwrap_or_else(|| super::commonmodule::ControlFSCC::new())
    }

    // .loadmodule.LoadControlScheduleFSCH loadControlScheduleFSCH = 2;


    pub fn get_loadControlScheduleFSCH(&self) -> &LoadControlScheduleFSCH {
        self.loadControlScheduleFSCH.as_ref().unwrap_or_else(|| <LoadControlScheduleFSCH as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadControlScheduleFSCH(&mut self) {
        self.loadControlScheduleFSCH.clear();
    }

    pub fn has_loadControlScheduleFSCH(&self) -> bool {
        self.loadControlScheduleFSCH.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadControlScheduleFSCH(&mut self, v: LoadControlScheduleFSCH) {
        self.loadControlScheduleFSCH = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadControlScheduleFSCH(&mut self) -> &mut LoadControlScheduleFSCH {
        if self.loadControlScheduleFSCH.is_none() {
            self.loadControlScheduleFSCH.set_default();
        }
        self.loadControlScheduleFSCH.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadControlScheduleFSCH(&mut self) -> LoadControlScheduleFSCH {
        self.loadControlScheduleFSCH.take().unwrap_or_else(|| LoadControlScheduleFSCH::new())
    }
}

impl ::protobuf::Message for LoadControlFSCC {
    fn is_initialized(&self) -> bool {
        for v in &self.controlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadControlScheduleFSCH {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlFSCC)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadControlScheduleFSCH)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadControlScheduleFSCH.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlFSCC.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadControlScheduleFSCH.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadControlFSCC {
        LoadControlFSCC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlFSCC>>(
                "controlFSCC",
                |m: &LoadControlFSCC| { &m.controlFSCC },
                |m: &mut LoadControlFSCC| { &mut m.controlFSCC },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadControlScheduleFSCH>>(
                "loadControlScheduleFSCH",
                |m: &LoadControlFSCC| { &m.loadControlScheduleFSCH },
                |m: &mut LoadControlFSCC| { &mut m.loadControlScheduleFSCH },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadControlFSCC>(
                "LoadControlFSCC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadControlFSCC {
        static instance: ::protobuf::rt::LazyV2<LoadControlFSCC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadControlFSCC::new)
    }
}

impl ::protobuf::Clear for LoadControlFSCC {
    fn clear(&mut self) {
        self.controlFSCC.clear();
        self.loadControlScheduleFSCH.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadControlFSCC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadControlFSCC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadControl {
    // message fields
    controlValue: ::protobuf::SingularPtrField<super::commonmodule::ControlValue>,
    check: ::protobuf::SingularPtrField<super::commonmodule::CheckConditions>,
    loadControlFSCC: ::protobuf::SingularPtrField<LoadControlFSCC>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadControl {
    fn default() -> &'a LoadControl {
        <LoadControl as ::protobuf::Message>::default_instance()
    }
}

impl LoadControl {
    pub fn new() -> LoadControl {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlValue controlValue = 1;


    pub fn get_controlValue(&self) -> &super::commonmodule::ControlValue {
        self.controlValue.as_ref().unwrap_or_else(|| <super::commonmodule::ControlValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlValue(&mut self) {
        self.controlValue.clear();
    }

    pub fn has_controlValue(&self) -> bool {
        self.controlValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlValue(&mut self, v: super::commonmodule::ControlValue) {
        self.controlValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlValue(&mut self) -> &mut super::commonmodule::ControlValue {
        if self.controlValue.is_none() {
            self.controlValue.set_default();
        }
        self.controlValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlValue(&mut self) -> super::commonmodule::ControlValue {
        self.controlValue.take().unwrap_or_else(|| super::commonmodule::ControlValue::new())
    }

    // .commonmodule.CheckConditions check = 2;


    pub fn get_check(&self) -> &super::commonmodule::CheckConditions {
        self.check.as_ref().unwrap_or_else(|| <super::commonmodule::CheckConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    pub fn has_check(&self) -> bool {
        self.check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: super::commonmodule::CheckConditions) {
        self.check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut super::commonmodule::CheckConditions {
        if self.check.is_none() {
            self.check.set_default();
        }
        self.check.as_mut().unwrap()
    }

    // Take field
    pub fn take_check(&mut self) -> super::commonmodule::CheckConditions {
        self.check.take().unwrap_or_else(|| super::commonmodule::CheckConditions::new())
    }

    // .loadmodule.LoadControlFSCC loadControlFSCC = 3;


    pub fn get_loadControlFSCC(&self) -> &LoadControlFSCC {
        self.loadControlFSCC.as_ref().unwrap_or_else(|| <LoadControlFSCC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadControlFSCC(&mut self) {
        self.loadControlFSCC.clear();
    }

    pub fn has_loadControlFSCC(&self) -> bool {
        self.loadControlFSCC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadControlFSCC(&mut self, v: LoadControlFSCC) {
        self.loadControlFSCC = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadControlFSCC(&mut self) -> &mut LoadControlFSCC {
        if self.loadControlFSCC.is_none() {
            self.loadControlFSCC.set_default();
        }
        self.loadControlFSCC.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadControlFSCC(&mut self) -> LoadControlFSCC {
        self.loadControlFSCC.take().unwrap_or_else(|| LoadControlFSCC::new())
    }
}

impl ::protobuf::Message for LoadControl {
    fn is_initialized(&self) -> bool {
        for v in &self.controlValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.check {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadControlFSCC {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.check)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadControlFSCC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.check.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadControlFSCC.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.check.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadControlFSCC.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadControl {
        LoadControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlValue>>(
                "controlValue",
                |m: &LoadControl| { &m.controlValue },
                |m: &mut LoadControl| { &mut m.controlValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::CheckConditions>>(
                "check",
                |m: &LoadControl| { &m.check },
                |m: &mut LoadControl| { &mut m.check },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadControlFSCC>>(
                "loadControlFSCC",
                |m: &LoadControl| { &m.loadControlFSCC },
                |m: &mut LoadControl| { &mut m.loadControlFSCC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadControl>(
                "LoadControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadControl {
        static instance: ::protobuf::rt::LazyV2<LoadControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadControl::new)
    }
}

impl ::protobuf::Clear for LoadControl {
    fn clear(&mut self) {
        self.controlValue.clear();
        self.check.clear();
        self.loadControlFSCC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadControlProfile {
    // message fields
    controlMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ControlMessageInfo>,
    energyConsumer: ::protobuf::SingularPtrField<super::commonmodule::EnergyConsumer>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    loadControl: ::protobuf::SingularPtrField<LoadControl>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadControlProfile {
    fn default() -> &'a LoadControlProfile {
        <LoadControlProfile as ::protobuf::Message>::default_instance()
    }
}

impl LoadControlProfile {
    pub fn new() -> LoadControlProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ControlMessageInfo controlMessageInfo = 1;


    pub fn get_controlMessageInfo(&self) -> &super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ControlMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controlMessageInfo(&mut self) {
        self.controlMessageInfo.clear();
    }

    pub fn has_controlMessageInfo(&self) -> bool {
        self.controlMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controlMessageInfo(&mut self, v: super::commonmodule::ControlMessageInfo) {
        self.controlMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controlMessageInfo(&mut self) -> &mut super::commonmodule::ControlMessageInfo {
        if self.controlMessageInfo.is_none() {
            self.controlMessageInfo.set_default();
        }
        self.controlMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_controlMessageInfo(&mut self) -> super::commonmodule::ControlMessageInfo {
        self.controlMessageInfo.take().unwrap_or_else(|| super::commonmodule::ControlMessageInfo::new())
    }

    // .commonmodule.EnergyConsumer energyConsumer = 2;


    pub fn get_energyConsumer(&self) -> &super::commonmodule::EnergyConsumer {
        self.energyConsumer.as_ref().unwrap_or_else(|| <super::commonmodule::EnergyConsumer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_energyConsumer(&mut self) {
        self.energyConsumer.clear();
    }

    pub fn has_energyConsumer(&self) -> bool {
        self.energyConsumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energyConsumer(&mut self, v: super::commonmodule::EnergyConsumer) {
        self.energyConsumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_energyConsumer(&mut self) -> &mut super::commonmodule::EnergyConsumer {
        if self.energyConsumer.is_none() {
            self.energyConsumer.set_default();
        }
        self.energyConsumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_energyConsumer(&mut self) -> super::commonmodule::EnergyConsumer {
        self.energyConsumer.take().unwrap_or_else(|| super::commonmodule::EnergyConsumer::new())
    }

    // .commonmodule.IED ied = 3;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .loadmodule.LoadControl loadControl = 4;


    pub fn get_loadControl(&self) -> &LoadControl {
        self.loadControl.as_ref().unwrap_or_else(|| <LoadControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadControl(&mut self) {
        self.loadControl.clear();
    }

    pub fn has_loadControl(&self) -> bool {
        self.loadControl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadControl(&mut self, v: LoadControl) {
        self.loadControl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadControl(&mut self) -> &mut LoadControl {
        if self.loadControl.is_none() {
            self.loadControl.set_default();
        }
        self.loadControl.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadControl(&mut self) -> LoadControl {
        self.loadControl.take().unwrap_or_else(|| LoadControl::new())
    }
}

impl ::protobuf::Message for LoadControlProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.controlMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.energyConsumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadControl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controlMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.energyConsumer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadControl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadControl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.controlMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadControl.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadControlProfile {
        LoadControlProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlMessageInfo>>(
                "controlMessageInfo",
                |m: &LoadControlProfile| { &m.controlMessageInfo },
                |m: &mut LoadControlProfile| { &mut m.controlMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EnergyConsumer>>(
                "energyConsumer",
                |m: &LoadControlProfile| { &m.energyConsumer },
                |m: &mut LoadControlProfile| { &mut m.energyConsumer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &LoadControlProfile| { &m.ied },
                |m: &mut LoadControlProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadControl>>(
                "loadControl",
                |m: &LoadControlProfile| { &m.loadControl },
                |m: &mut LoadControlProfile| { &mut m.loadControl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadControlProfile>(
                "LoadControlProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadControlProfile {
        static instance: ::protobuf::rt::LazyV2<LoadControlProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadControlProfile::new)
    }
}

impl ::protobuf::Clear for LoadControlProfile {
    fn clear(&mut self) {
        self.controlMessageInfo.clear();
        self.energyConsumer.clear();
        self.ied.clear();
        self.loadControl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadControlProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadControlProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadPointStatus {
    // message fields
    rampRates: ::protobuf::SingularPtrField<super::commonmodule::RampRate>,
    reactivePwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    realPwrSetPointEnabled: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    reset: ::protobuf::SingularPtrField<super::commonmodule::ControlDPC>,
    state: ::protobuf::SingularPtrField<super::commonmodule::Optional_StateKind>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadPointStatus {
    fn default() -> &'a LoadPointStatus {
        <LoadPointStatus as ::protobuf::Message>::default_instance()
    }
}

impl LoadPointStatus {
    pub fn new() -> LoadPointStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.RampRate rampRates = 1;


    pub fn get_rampRates(&self) -> &super::commonmodule::RampRate {
        self.rampRates.as_ref().unwrap_or_else(|| <super::commonmodule::RampRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rampRates(&mut self) {
        self.rampRates.clear();
    }

    pub fn has_rampRates(&self) -> bool {
        self.rampRates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampRates(&mut self, v: super::commonmodule::RampRate) {
        self.rampRates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rampRates(&mut self) -> &mut super::commonmodule::RampRate {
        if self.rampRates.is_none() {
            self.rampRates.set_default();
        }
        self.rampRates.as_mut().unwrap()
    }

    // Take field
    pub fn take_rampRates(&mut self) -> super::commonmodule::RampRate {
        self.rampRates.take().unwrap_or_else(|| super::commonmodule::RampRate::new())
    }

    // .commonmodule.ControlDPC reactivePwrSetPointEnabled = 2;


    pub fn get_reactivePwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reactivePwrSetPointEnabled(&mut self) {
        self.reactivePwrSetPointEnabled.clear();
    }

    pub fn has_reactivePwrSetPointEnabled(&self) -> bool {
        self.reactivePwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactivePwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.reactivePwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reactivePwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reactivePwrSetPointEnabled.is_none() {
            self.reactivePwrSetPointEnabled.set_default();
        }
        self.reactivePwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_reactivePwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.reactivePwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC realPwrSetPointEnabled = 3;


    pub fn get_realPwrSetPointEnabled(&self) -> &super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_realPwrSetPointEnabled(&mut self) {
        self.realPwrSetPointEnabled.clear();
    }

    pub fn has_realPwrSetPointEnabled(&self) -> bool {
        self.realPwrSetPointEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realPwrSetPointEnabled(&mut self, v: super::commonmodule::ControlDPC) {
        self.realPwrSetPointEnabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_realPwrSetPointEnabled(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.realPwrSetPointEnabled.is_none() {
            self.realPwrSetPointEnabled.set_default();
        }
        self.realPwrSetPointEnabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_realPwrSetPointEnabled(&mut self) -> super::commonmodule::ControlDPC {
        self.realPwrSetPointEnabled.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.ControlDPC reset = 4;


    pub fn get_reset(&self) -> &super::commonmodule::ControlDPC {
        self.reset.as_ref().unwrap_or_else(|| <super::commonmodule::ControlDPC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reset(&mut self) {
        self.reset.clear();
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: super::commonmodule::ControlDPC) {
        self.reset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reset(&mut self) -> &mut super::commonmodule::ControlDPC {
        if self.reset.is_none() {
            self.reset.set_default();
        }
        self.reset.as_mut().unwrap()
    }

    // Take field
    pub fn take_reset(&mut self) -> super::commonmodule::ControlDPC {
        self.reset.take().unwrap_or_else(|| super::commonmodule::ControlDPC::new())
    }

    // .commonmodule.Optional_StateKind state = 5;


    pub fn get_state(&self) -> &super::commonmodule::Optional_StateKind {
        self.state.as_ref().unwrap_or_else(|| <super::commonmodule::Optional_StateKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::commonmodule::Optional_StateKind) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::commonmodule::Optional_StateKind {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::commonmodule::Optional_StateKind {
        self.state.take().unwrap_or_else(|| super::commonmodule::Optional_StateKind::new())
    }
}

impl ::protobuf::Message for LoadPointStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.rampRates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactivePwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.realPwrSetPointEnabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rampRates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reactivePwrSetPointEnabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.realPwrSetPointEnabled)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reset)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rampRates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rampRates.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reactivePwrSetPointEnabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.realPwrSetPointEnabled.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reset.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadPointStatus {
        LoadPointStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::RampRate>>(
                "rampRates",
                |m: &LoadPointStatus| { &m.rampRates },
                |m: &mut LoadPointStatus| { &mut m.rampRates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reactivePwrSetPointEnabled",
                |m: &LoadPointStatus| { &m.reactivePwrSetPointEnabled },
                |m: &mut LoadPointStatus| { &mut m.reactivePwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "realPwrSetPointEnabled",
                |m: &LoadPointStatus| { &m.realPwrSetPointEnabled },
                |m: &mut LoadPointStatus| { &mut m.realPwrSetPointEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ControlDPC>>(
                "reset",
                |m: &LoadPointStatus| { &m.reset },
                |m: &mut LoadPointStatus| { &mut m.reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::Optional_StateKind>>(
                "state",
                |m: &LoadPointStatus| { &m.state },
                |m: &mut LoadPointStatus| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadPointStatus>(
                "LoadPointStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadPointStatus {
        static instance: ::protobuf::rt::LazyV2<LoadPointStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadPointStatus::new)
    }
}

impl ::protobuf::Clear for LoadPointStatus {
    fn clear(&mut self) {
        self.rampRates.clear();
        self.reactivePwrSetPointEnabled.clear();
        self.realPwrSetPointEnabled.clear();
        self.reset.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadPointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadPointStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadEventAndStatusZGLD {
    // message fields
    logicalNodeForEventAndStatus: ::protobuf::SingularPtrField<super::commonmodule::LogicalNodeForEventAndStatus>,
    DynamicTest: ::protobuf::SingularPtrField<super::commonmodule::ENS_DynamicTestKind>,
    EmgStop: ::protobuf::SingularPtrField<super::commonmodule::StatusSPS>,
    PointStatus: ::protobuf::SingularPtrField<LoadPointStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadEventAndStatusZGLD {
    fn default() -> &'a LoadEventAndStatusZGLD {
        <LoadEventAndStatusZGLD as ::protobuf::Message>::default_instance()
    }
}

impl LoadEventAndStatusZGLD {
    pub fn new() -> LoadEventAndStatusZGLD {
        ::std::default::Default::default()
    }

    // .commonmodule.LogicalNodeForEventAndStatus logicalNodeForEventAndStatus = 1;


    pub fn get_logicalNodeForEventAndStatus(&self) -> &super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.as_ref().unwrap_or_else(|| <super::commonmodule::LogicalNodeForEventAndStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logicalNodeForEventAndStatus(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
    }

    pub fn has_logicalNodeForEventAndStatus(&self) -> bool {
        self.logicalNodeForEventAndStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logicalNodeForEventAndStatus(&mut self, v: super::commonmodule::LogicalNodeForEventAndStatus) {
        self.logicalNodeForEventAndStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logicalNodeForEventAndStatus(&mut self) -> &mut super::commonmodule::LogicalNodeForEventAndStatus {
        if self.logicalNodeForEventAndStatus.is_none() {
            self.logicalNodeForEventAndStatus.set_default();
        }
        self.logicalNodeForEventAndStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_logicalNodeForEventAndStatus(&mut self) -> super::commonmodule::LogicalNodeForEventAndStatus {
        self.logicalNodeForEventAndStatus.take().unwrap_or_else(|| super::commonmodule::LogicalNodeForEventAndStatus::new())
    }

    // .commonmodule.ENS_DynamicTestKind DynamicTest = 2;


    pub fn get_DynamicTest(&self) -> &super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.as_ref().unwrap_or_else(|| <super::commonmodule::ENS_DynamicTestKind as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DynamicTest(&mut self) {
        self.DynamicTest.clear();
    }

    pub fn has_DynamicTest(&self) -> bool {
        self.DynamicTest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DynamicTest(&mut self, v: super::commonmodule::ENS_DynamicTestKind) {
        self.DynamicTest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DynamicTest(&mut self) -> &mut super::commonmodule::ENS_DynamicTestKind {
        if self.DynamicTest.is_none() {
            self.DynamicTest.set_default();
        }
        self.DynamicTest.as_mut().unwrap()
    }

    // Take field
    pub fn take_DynamicTest(&mut self) -> super::commonmodule::ENS_DynamicTestKind {
        self.DynamicTest.take().unwrap_or_else(|| super::commonmodule::ENS_DynamicTestKind::new())
    }

    // .commonmodule.StatusSPS EmgStop = 3;


    pub fn get_EmgStop(&self) -> &super::commonmodule::StatusSPS {
        self.EmgStop.as_ref().unwrap_or_else(|| <super::commonmodule::StatusSPS as ::protobuf::Message>::default_instance())
    }
    pub fn clear_EmgStop(&mut self) {
        self.EmgStop.clear();
    }

    pub fn has_EmgStop(&self) -> bool {
        self.EmgStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EmgStop(&mut self, v: super::commonmodule::StatusSPS) {
        self.EmgStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EmgStop(&mut self) -> &mut super::commonmodule::StatusSPS {
        if self.EmgStop.is_none() {
            self.EmgStop.set_default();
        }
        self.EmgStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_EmgStop(&mut self) -> super::commonmodule::StatusSPS {
        self.EmgStop.take().unwrap_or_else(|| super::commonmodule::StatusSPS::new())
    }

    // .loadmodule.LoadPointStatus PointStatus = 4;


    pub fn get_PointStatus(&self) -> &LoadPointStatus {
        self.PointStatus.as_ref().unwrap_or_else(|| <LoadPointStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PointStatus(&mut self) {
        self.PointStatus.clear();
    }

    pub fn has_PointStatus(&self) -> bool {
        self.PointStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PointStatus(&mut self, v: LoadPointStatus) {
        self.PointStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PointStatus(&mut self) -> &mut LoadPointStatus {
        if self.PointStatus.is_none() {
            self.PointStatus.set_default();
        }
        self.PointStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_PointStatus(&mut self) -> LoadPointStatus {
        self.PointStatus.take().unwrap_or_else(|| LoadPointStatus::new())
    }
}

impl ::protobuf::Message for LoadEventAndStatusZGLD {
    fn is_initialized(&self) -> bool {
        for v in &self.logicalNodeForEventAndStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DynamicTest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.EmgStop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PointStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logicalNodeForEventAndStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DynamicTest)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.EmgStop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PointStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.logicalNodeForEventAndStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DynamicTest.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.EmgStop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PointStatus.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadEventAndStatusZGLD {
        LoadEventAndStatusZGLD::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::LogicalNodeForEventAndStatus>>(
                "logicalNodeForEventAndStatus",
                |m: &LoadEventAndStatusZGLD| { &m.logicalNodeForEventAndStatus },
                |m: &mut LoadEventAndStatusZGLD| { &mut m.logicalNodeForEventAndStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ENS_DynamicTestKind>>(
                "DynamicTest",
                |m: &LoadEventAndStatusZGLD| { &m.DynamicTest },
                |m: &mut LoadEventAndStatusZGLD| { &mut m.DynamicTest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusSPS>>(
                "EmgStop",
                |m: &LoadEventAndStatusZGLD| { &m.EmgStop },
                |m: &mut LoadEventAndStatusZGLD| { &mut m.EmgStop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadPointStatus>>(
                "PointStatus",
                |m: &LoadEventAndStatusZGLD| { &m.PointStatus },
                |m: &mut LoadEventAndStatusZGLD| { &mut m.PointStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadEventAndStatusZGLD>(
                "LoadEventAndStatusZGLD",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadEventAndStatusZGLD {
        static instance: ::protobuf::rt::LazyV2<LoadEventAndStatusZGLD> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadEventAndStatusZGLD::new)
    }
}

impl ::protobuf::Clear for LoadEventAndStatusZGLD {
    fn clear(&mut self) {
        self.logicalNodeForEventAndStatus.clear();
        self.DynamicTest.clear();
        self.EmgStop.clear();
        self.PointStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadEventAndStatusZGLD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadEventAndStatusZGLD {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadEventZGLD {
    // message fields
    loadEventAndStatusZGLD: ::protobuf::SingularPtrField<LoadEventAndStatusZGLD>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadEventZGLD {
    fn default() -> &'a LoadEventZGLD {
        <LoadEventZGLD as ::protobuf::Message>::default_instance()
    }
}

impl LoadEventZGLD {
    pub fn new() -> LoadEventZGLD {
        ::std::default::Default::default()
    }

    // .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1;


    pub fn get_loadEventAndStatusZGLD(&self) -> &LoadEventAndStatusZGLD {
        self.loadEventAndStatusZGLD.as_ref().unwrap_or_else(|| <LoadEventAndStatusZGLD as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadEventAndStatusZGLD(&mut self) {
        self.loadEventAndStatusZGLD.clear();
    }

    pub fn has_loadEventAndStatusZGLD(&self) -> bool {
        self.loadEventAndStatusZGLD.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadEventAndStatusZGLD(&mut self, v: LoadEventAndStatusZGLD) {
        self.loadEventAndStatusZGLD = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadEventAndStatusZGLD(&mut self) -> &mut LoadEventAndStatusZGLD {
        if self.loadEventAndStatusZGLD.is_none() {
            self.loadEventAndStatusZGLD.set_default();
        }
        self.loadEventAndStatusZGLD.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadEventAndStatusZGLD(&mut self) -> LoadEventAndStatusZGLD {
        self.loadEventAndStatusZGLD.take().unwrap_or_else(|| LoadEventAndStatusZGLD::new())
    }
}

impl ::protobuf::Message for LoadEventZGLD {
    fn is_initialized(&self) -> bool {
        for v in &self.loadEventAndStatusZGLD {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadEventAndStatusZGLD)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loadEventAndStatusZGLD.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loadEventAndStatusZGLD.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadEventZGLD {
        LoadEventZGLD::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadEventAndStatusZGLD>>(
                "loadEventAndStatusZGLD",
                |m: &LoadEventZGLD| { &m.loadEventAndStatusZGLD },
                |m: &mut LoadEventZGLD| { &mut m.loadEventAndStatusZGLD },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadEventZGLD>(
                "LoadEventZGLD",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadEventZGLD {
        static instance: ::protobuf::rt::LazyV2<LoadEventZGLD> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadEventZGLD::new)
    }
}

impl ::protobuf::Clear for LoadEventZGLD {
    fn clear(&mut self) {
        self.loadEventAndStatusZGLD.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadEventZGLD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadEventZGLD {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadEvent {
    // message fields
    eventValue: ::protobuf::SingularPtrField<super::commonmodule::EventValue>,
    loadEventZGLD: ::protobuf::SingularPtrField<LoadEventZGLD>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadEvent {
    fn default() -> &'a LoadEvent {
        <LoadEvent as ::protobuf::Message>::default_instance()
    }
}

impl LoadEvent {
    pub fn new() -> LoadEvent {
        ::std::default::Default::default()
    }

    // .commonmodule.EventValue eventValue = 1;


    pub fn get_eventValue(&self) -> &super::commonmodule::EventValue {
        self.eventValue.as_ref().unwrap_or_else(|| <super::commonmodule::EventValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventValue(&mut self) {
        self.eventValue.clear();
    }

    pub fn has_eventValue(&self) -> bool {
        self.eventValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventValue(&mut self, v: super::commonmodule::EventValue) {
        self.eventValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventValue(&mut self) -> &mut super::commonmodule::EventValue {
        if self.eventValue.is_none() {
            self.eventValue.set_default();
        }
        self.eventValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventValue(&mut self) -> super::commonmodule::EventValue {
        self.eventValue.take().unwrap_or_else(|| super::commonmodule::EventValue::new())
    }

    // .loadmodule.LoadEventZGLD loadEventZGLD = 2;


    pub fn get_loadEventZGLD(&self) -> &LoadEventZGLD {
        self.loadEventZGLD.as_ref().unwrap_or_else(|| <LoadEventZGLD as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadEventZGLD(&mut self) {
        self.loadEventZGLD.clear();
    }

    pub fn has_loadEventZGLD(&self) -> bool {
        self.loadEventZGLD.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadEventZGLD(&mut self, v: LoadEventZGLD) {
        self.loadEventZGLD = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadEventZGLD(&mut self) -> &mut LoadEventZGLD {
        if self.loadEventZGLD.is_none() {
            self.loadEventZGLD.set_default();
        }
        self.loadEventZGLD.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadEventZGLD(&mut self) -> LoadEventZGLD {
        self.loadEventZGLD.take().unwrap_or_else(|| LoadEventZGLD::new())
    }
}

impl ::protobuf::Message for LoadEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.eventValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadEventZGLD {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadEventZGLD)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadEventZGLD.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadEventZGLD.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadEvent {
        LoadEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventValue>>(
                "eventValue",
                |m: &LoadEvent| { &m.eventValue },
                |m: &mut LoadEvent| { &mut m.eventValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadEventZGLD>>(
                "loadEventZGLD",
                |m: &LoadEvent| { &m.loadEventZGLD },
                |m: &mut LoadEvent| { &mut m.loadEventZGLD },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadEvent>(
                "LoadEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadEvent {
        static instance: ::protobuf::rt::LazyV2<LoadEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadEvent::new)
    }
}

impl ::protobuf::Clear for LoadEvent {
    fn clear(&mut self) {
        self.eventValue.clear();
        self.loadEventZGLD.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadEventProfile {
    // message fields
    eventMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::EventMessageInfo>,
    energyConsumer: ::protobuf::SingularPtrField<super::commonmodule::EnergyConsumer>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    loadEvent: ::protobuf::SingularPtrField<LoadEvent>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadEventProfile {
    fn default() -> &'a LoadEventProfile {
        <LoadEventProfile as ::protobuf::Message>::default_instance()
    }
}

impl LoadEventProfile {
    pub fn new() -> LoadEventProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.EventMessageInfo eventMessageInfo = 1;


    pub fn get_eventMessageInfo(&self) -> &super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::EventMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventMessageInfo(&mut self) {
        self.eventMessageInfo.clear();
    }

    pub fn has_eventMessageInfo(&self) -> bool {
        self.eventMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventMessageInfo(&mut self, v: super::commonmodule::EventMessageInfo) {
        self.eventMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventMessageInfo(&mut self) -> &mut super::commonmodule::EventMessageInfo {
        if self.eventMessageInfo.is_none() {
            self.eventMessageInfo.set_default();
        }
        self.eventMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventMessageInfo(&mut self) -> super::commonmodule::EventMessageInfo {
        self.eventMessageInfo.take().unwrap_or_else(|| super::commonmodule::EventMessageInfo::new())
    }

    // .commonmodule.EnergyConsumer energyConsumer = 2;


    pub fn get_energyConsumer(&self) -> &super::commonmodule::EnergyConsumer {
        self.energyConsumer.as_ref().unwrap_or_else(|| <super::commonmodule::EnergyConsumer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_energyConsumer(&mut self) {
        self.energyConsumer.clear();
    }

    pub fn has_energyConsumer(&self) -> bool {
        self.energyConsumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energyConsumer(&mut self, v: super::commonmodule::EnergyConsumer) {
        self.energyConsumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_energyConsumer(&mut self) -> &mut super::commonmodule::EnergyConsumer {
        if self.energyConsumer.is_none() {
            self.energyConsumer.set_default();
        }
        self.energyConsumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_energyConsumer(&mut self) -> super::commonmodule::EnergyConsumer {
        self.energyConsumer.take().unwrap_or_else(|| super::commonmodule::EnergyConsumer::new())
    }

    // .commonmodule.IED ied = 3;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .loadmodule.LoadEvent loadEvent = 4;


    pub fn get_loadEvent(&self) -> &LoadEvent {
        self.loadEvent.as_ref().unwrap_or_else(|| <LoadEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadEvent(&mut self) {
        self.loadEvent.clear();
    }

    pub fn has_loadEvent(&self) -> bool {
        self.loadEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadEvent(&mut self, v: LoadEvent) {
        self.loadEvent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadEvent(&mut self) -> &mut LoadEvent {
        if self.loadEvent.is_none() {
            self.loadEvent.set_default();
        }
        self.loadEvent.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadEvent(&mut self) -> LoadEvent {
        self.loadEvent.take().unwrap_or_else(|| LoadEvent::new())
    }
}

impl ::protobuf::Message for LoadEventProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.eventMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.energyConsumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.energyConsumer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadEvent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadEvent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadEvent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadEventProfile {
        LoadEventProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EventMessageInfo>>(
                "eventMessageInfo",
                |m: &LoadEventProfile| { &m.eventMessageInfo },
                |m: &mut LoadEventProfile| { &mut m.eventMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EnergyConsumer>>(
                "energyConsumer",
                |m: &LoadEventProfile| { &m.energyConsumer },
                |m: &mut LoadEventProfile| { &mut m.energyConsumer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &LoadEventProfile| { &m.ied },
                |m: &mut LoadEventProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadEvent>>(
                "loadEvent",
                |m: &LoadEventProfile| { &m.loadEvent },
                |m: &mut LoadEventProfile| { &mut m.loadEvent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadEventProfile>(
                "LoadEventProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadEventProfile {
        static instance: ::protobuf::rt::LazyV2<LoadEventProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadEventProfile::new)
    }
}

impl ::protobuf::Clear for LoadEventProfile {
    fn clear(&mut self) {
        self.eventMessageInfo.clear();
        self.energyConsumer.clear();
        self.ied.clear();
        self.loadEvent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadEventProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadEventProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadReading {
    // message fields
    conductingEquipmentTerminalReading: ::protobuf::SingularPtrField<super::commonmodule::ConductingEquipmentTerminalReading>,
    phaseMMTN: ::protobuf::SingularPtrField<super::commonmodule::PhaseMMTN>,
    readingMMTR: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMTR>,
    readingMMXU: ::protobuf::SingularPtrField<super::commonmodule::ReadingMMXU>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadReading {
    fn default() -> &'a LoadReading {
        <LoadReading as ::protobuf::Message>::default_instance()
    }
}

impl LoadReading {
    pub fn new() -> LoadReading {
        ::std::default::Default::default()
    }

    // .commonmodule.ConductingEquipmentTerminalReading conductingEquipmentTerminalReading = 1;


    pub fn get_conductingEquipmentTerminalReading(&self) -> &super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.as_ref().unwrap_or_else(|| <super::commonmodule::ConductingEquipmentTerminalReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conductingEquipmentTerminalReading(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
    }

    pub fn has_conductingEquipmentTerminalReading(&self) -> bool {
        self.conductingEquipmentTerminalReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conductingEquipmentTerminalReading(&mut self, v: super::commonmodule::ConductingEquipmentTerminalReading) {
        self.conductingEquipmentTerminalReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conductingEquipmentTerminalReading(&mut self) -> &mut super::commonmodule::ConductingEquipmentTerminalReading {
        if self.conductingEquipmentTerminalReading.is_none() {
            self.conductingEquipmentTerminalReading.set_default();
        }
        self.conductingEquipmentTerminalReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_conductingEquipmentTerminalReading(&mut self) -> super::commonmodule::ConductingEquipmentTerminalReading {
        self.conductingEquipmentTerminalReading.take().unwrap_or_else(|| super::commonmodule::ConductingEquipmentTerminalReading::new())
    }

    // .commonmodule.PhaseMMTN phaseMMTN = 2;


    pub fn get_phaseMMTN(&self) -> &super::commonmodule::PhaseMMTN {
        self.phaseMMTN.as_ref().unwrap_or_else(|| <super::commonmodule::PhaseMMTN as ::protobuf::Message>::default_instance())
    }
    pub fn clear_phaseMMTN(&mut self) {
        self.phaseMMTN.clear();
    }

    pub fn has_phaseMMTN(&self) -> bool {
        self.phaseMMTN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phaseMMTN(&mut self, v: super::commonmodule::PhaseMMTN) {
        self.phaseMMTN = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phaseMMTN(&mut self) -> &mut super::commonmodule::PhaseMMTN {
        if self.phaseMMTN.is_none() {
            self.phaseMMTN.set_default();
        }
        self.phaseMMTN.as_mut().unwrap()
    }

    // Take field
    pub fn take_phaseMMTN(&mut self) -> super::commonmodule::PhaseMMTN {
        self.phaseMMTN.take().unwrap_or_else(|| super::commonmodule::PhaseMMTN::new())
    }

    // .commonmodule.ReadingMMTR readingMMTR = 3;


    pub fn get_readingMMTR(&self) -> &super::commonmodule::ReadingMMTR {
        self.readingMMTR.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMTR as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMTR(&mut self) {
        self.readingMMTR.clear();
    }

    pub fn has_readingMMTR(&self) -> bool {
        self.readingMMTR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMTR(&mut self, v: super::commonmodule::ReadingMMTR) {
        self.readingMMTR = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMTR(&mut self) -> &mut super::commonmodule::ReadingMMTR {
        if self.readingMMTR.is_none() {
            self.readingMMTR.set_default();
        }
        self.readingMMTR.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMTR(&mut self) -> super::commonmodule::ReadingMMTR {
        self.readingMMTR.take().unwrap_or_else(|| super::commonmodule::ReadingMMTR::new())
    }

    // .commonmodule.ReadingMMXU readingMMXU = 4;


    pub fn get_readingMMXU(&self) -> &super::commonmodule::ReadingMMXU {
        self.readingMMXU.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMMXU as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMMXU(&mut self) {
        self.readingMMXU.clear();
    }

    pub fn has_readingMMXU(&self) -> bool {
        self.readingMMXU.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMMXU(&mut self, v: super::commonmodule::ReadingMMXU) {
        self.readingMMXU = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMMXU(&mut self) -> &mut super::commonmodule::ReadingMMXU {
        if self.readingMMXU.is_none() {
            self.readingMMXU.set_default();
        }
        self.readingMMXU.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMMXU(&mut self) -> super::commonmodule::ReadingMMXU {
        self.readingMMXU.take().unwrap_or_else(|| super::commonmodule::ReadingMMXU::new())
    }
}

impl ::protobuf::Message for LoadReading {
    fn is_initialized(&self) -> bool {
        for v in &self.conductingEquipmentTerminalReading {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.phaseMMTN {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMTR {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readingMMXU {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conductingEquipmentTerminalReading)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.phaseMMTN)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMTR)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMMXU)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conductingEquipmentTerminalReading.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.phaseMMTN.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMTR.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readingMMXU.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadReading {
        LoadReading::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ConductingEquipmentTerminalReading>>(
                "conductingEquipmentTerminalReading",
                |m: &LoadReading| { &m.conductingEquipmentTerminalReading },
                |m: &mut LoadReading| { &mut m.conductingEquipmentTerminalReading },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::PhaseMMTN>>(
                "phaseMMTN",
                |m: &LoadReading| { &m.phaseMMTN },
                |m: &mut LoadReading| { &mut m.phaseMMTN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMTR>>(
                "readingMMTR",
                |m: &LoadReading| { &m.readingMMTR },
                |m: &mut LoadReading| { &mut m.readingMMTR },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMMXU>>(
                "readingMMXU",
                |m: &LoadReading| { &m.readingMMXU },
                |m: &mut LoadReading| { &mut m.readingMMXU },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadReading>(
                "LoadReading",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadReading {
        static instance: ::protobuf::rt::LazyV2<LoadReading> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadReading::new)
    }
}

impl ::protobuf::Clear for LoadReading {
    fn clear(&mut self) {
        self.conductingEquipmentTerminalReading.clear();
        self.phaseMMTN.clear();
        self.readingMMTR.clear();
        self.readingMMXU.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadReading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadReading {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadReadingProfile {
    // message fields
    readingMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::ReadingMessageInfo>,
    energyConsumer: ::protobuf::SingularPtrField<super::commonmodule::EnergyConsumer>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    loadReading: ::protobuf::SingularPtrField<LoadReading>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadReadingProfile {
    fn default() -> &'a LoadReadingProfile {
        <LoadReadingProfile as ::protobuf::Message>::default_instance()
    }
}

impl LoadReadingProfile {
    pub fn new() -> LoadReadingProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.ReadingMessageInfo readingMessageInfo = 1;


    pub fn get_readingMessageInfo(&self) -> &super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::ReadingMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readingMessageInfo(&mut self) {
        self.readingMessageInfo.clear();
    }

    pub fn has_readingMessageInfo(&self) -> bool {
        self.readingMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readingMessageInfo(&mut self, v: super::commonmodule::ReadingMessageInfo) {
        self.readingMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readingMessageInfo(&mut self) -> &mut super::commonmodule::ReadingMessageInfo {
        if self.readingMessageInfo.is_none() {
            self.readingMessageInfo.set_default();
        }
        self.readingMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readingMessageInfo(&mut self) -> super::commonmodule::ReadingMessageInfo {
        self.readingMessageInfo.take().unwrap_or_else(|| super::commonmodule::ReadingMessageInfo::new())
    }

    // .commonmodule.EnergyConsumer energyConsumer = 2;


    pub fn get_energyConsumer(&self) -> &super::commonmodule::EnergyConsumer {
        self.energyConsumer.as_ref().unwrap_or_else(|| <super::commonmodule::EnergyConsumer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_energyConsumer(&mut self) {
        self.energyConsumer.clear();
    }

    pub fn has_energyConsumer(&self) -> bool {
        self.energyConsumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energyConsumer(&mut self, v: super::commonmodule::EnergyConsumer) {
        self.energyConsumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_energyConsumer(&mut self) -> &mut super::commonmodule::EnergyConsumer {
        if self.energyConsumer.is_none() {
            self.energyConsumer.set_default();
        }
        self.energyConsumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_energyConsumer(&mut self) -> super::commonmodule::EnergyConsumer {
        self.energyConsumer.take().unwrap_or_else(|| super::commonmodule::EnergyConsumer::new())
    }

    // .commonmodule.IED ied = 3;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .loadmodule.LoadReading loadReading = 4;


    pub fn get_loadReading(&self) -> &LoadReading {
        self.loadReading.as_ref().unwrap_or_else(|| <LoadReading as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadReading(&mut self) {
        self.loadReading.clear();
    }

    pub fn has_loadReading(&self) -> bool {
        self.loadReading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadReading(&mut self, v: LoadReading) {
        self.loadReading = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadReading(&mut self) -> &mut LoadReading {
        if self.loadReading.is_none() {
            self.loadReading.set_default();
        }
        self.loadReading.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadReading(&mut self) -> LoadReading {
        self.loadReading.take().unwrap_or_else(|| LoadReading::new())
    }
}

impl ::protobuf::Message for LoadReadingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.readingMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.energyConsumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadReading {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readingMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.energyConsumer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadReading)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadReading.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.readingMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadReading.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadReadingProfile {
        LoadReadingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::ReadingMessageInfo>>(
                "readingMessageInfo",
                |m: &LoadReadingProfile| { &m.readingMessageInfo },
                |m: &mut LoadReadingProfile| { &mut m.readingMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EnergyConsumer>>(
                "energyConsumer",
                |m: &LoadReadingProfile| { &m.energyConsumer },
                |m: &mut LoadReadingProfile| { &mut m.energyConsumer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &LoadReadingProfile| { &m.ied },
                |m: &mut LoadReadingProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadReading>>(
                "loadReading",
                |m: &LoadReadingProfile| { &m.loadReading },
                |m: &mut LoadReadingProfile| { &mut m.loadReading },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadReadingProfile>(
                "LoadReadingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadReadingProfile {
        static instance: ::protobuf::rt::LazyV2<LoadReadingProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadReadingProfile::new)
    }
}

impl ::protobuf::Clear for LoadReadingProfile {
    fn clear(&mut self) {
        self.readingMessageInfo.clear();
        self.energyConsumer.clear();
        self.ied.clear();
        self.loadReading.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadReadingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadReadingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadStatusZGLD {
    // message fields
    loadEventAndStatusZGLD: ::protobuf::SingularPtrField<LoadEventAndStatusZGLD>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadStatusZGLD {
    fn default() -> &'a LoadStatusZGLD {
        <LoadStatusZGLD as ::protobuf::Message>::default_instance()
    }
}

impl LoadStatusZGLD {
    pub fn new() -> LoadStatusZGLD {
        ::std::default::Default::default()
    }

    // .loadmodule.LoadEventAndStatusZGLD loadEventAndStatusZGLD = 1;


    pub fn get_loadEventAndStatusZGLD(&self) -> &LoadEventAndStatusZGLD {
        self.loadEventAndStatusZGLD.as_ref().unwrap_or_else(|| <LoadEventAndStatusZGLD as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadEventAndStatusZGLD(&mut self) {
        self.loadEventAndStatusZGLD.clear();
    }

    pub fn has_loadEventAndStatusZGLD(&self) -> bool {
        self.loadEventAndStatusZGLD.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadEventAndStatusZGLD(&mut self, v: LoadEventAndStatusZGLD) {
        self.loadEventAndStatusZGLD = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadEventAndStatusZGLD(&mut self) -> &mut LoadEventAndStatusZGLD {
        if self.loadEventAndStatusZGLD.is_none() {
            self.loadEventAndStatusZGLD.set_default();
        }
        self.loadEventAndStatusZGLD.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadEventAndStatusZGLD(&mut self) -> LoadEventAndStatusZGLD {
        self.loadEventAndStatusZGLD.take().unwrap_or_else(|| LoadEventAndStatusZGLD::new())
    }
}

impl ::protobuf::Message for LoadStatusZGLD {
    fn is_initialized(&self) -> bool {
        for v in &self.loadEventAndStatusZGLD {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadEventAndStatusZGLD)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loadEventAndStatusZGLD.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loadEventAndStatusZGLD.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadStatusZGLD {
        LoadStatusZGLD::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadEventAndStatusZGLD>>(
                "loadEventAndStatusZGLD",
                |m: &LoadStatusZGLD| { &m.loadEventAndStatusZGLD },
                |m: &mut LoadStatusZGLD| { &mut m.loadEventAndStatusZGLD },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadStatusZGLD>(
                "LoadStatusZGLD",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadStatusZGLD {
        static instance: ::protobuf::rt::LazyV2<LoadStatusZGLD> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadStatusZGLD::new)
    }
}

impl ::protobuf::Clear for LoadStatusZGLD {
    fn clear(&mut self) {
        self.loadEventAndStatusZGLD.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadStatusZGLD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadStatusZGLD {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadStatus {
    // message fields
    statusValue: ::protobuf::SingularPtrField<super::commonmodule::StatusValue>,
    loadStatusZGLD: ::protobuf::SingularPtrField<LoadStatusZGLD>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadStatus {
    fn default() -> &'a LoadStatus {
        <LoadStatus as ::protobuf::Message>::default_instance()
    }
}

impl LoadStatus {
    pub fn new() -> LoadStatus {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusValue statusValue = 1;


    pub fn get_statusValue(&self) -> &super::commonmodule::StatusValue {
        self.statusValue.as_ref().unwrap_or_else(|| <super::commonmodule::StatusValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusValue(&mut self) {
        self.statusValue.clear();
    }

    pub fn has_statusValue(&self) -> bool {
        self.statusValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusValue(&mut self, v: super::commonmodule::StatusValue) {
        self.statusValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusValue(&mut self) -> &mut super::commonmodule::StatusValue {
        if self.statusValue.is_none() {
            self.statusValue.set_default();
        }
        self.statusValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusValue(&mut self) -> super::commonmodule::StatusValue {
        self.statusValue.take().unwrap_or_else(|| super::commonmodule::StatusValue::new())
    }

    // .loadmodule.LoadStatusZGLD loadStatusZGLD = 2;


    pub fn get_loadStatusZGLD(&self) -> &LoadStatusZGLD {
        self.loadStatusZGLD.as_ref().unwrap_or_else(|| <LoadStatusZGLD as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadStatusZGLD(&mut self) {
        self.loadStatusZGLD.clear();
    }

    pub fn has_loadStatusZGLD(&self) -> bool {
        self.loadStatusZGLD.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadStatusZGLD(&mut self, v: LoadStatusZGLD) {
        self.loadStatusZGLD = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadStatusZGLD(&mut self) -> &mut LoadStatusZGLD {
        if self.loadStatusZGLD.is_none() {
            self.loadStatusZGLD.set_default();
        }
        self.loadStatusZGLD.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadStatusZGLD(&mut self) -> LoadStatusZGLD {
        self.loadStatusZGLD.take().unwrap_or_else(|| LoadStatusZGLD::new())
    }
}

impl ::protobuf::Message for LoadStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.statusValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadStatusZGLD {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadStatusZGLD)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadStatusZGLD.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusValue.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadStatusZGLD.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadStatus {
        LoadStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusValue>>(
                "statusValue",
                |m: &LoadStatus| { &m.statusValue },
                |m: &mut LoadStatus| { &mut m.statusValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadStatusZGLD>>(
                "loadStatusZGLD",
                |m: &LoadStatus| { &m.loadStatusZGLD },
                |m: &mut LoadStatus| { &mut m.loadStatusZGLD },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadStatus>(
                "LoadStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadStatus {
        static instance: ::protobuf::rt::LazyV2<LoadStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadStatus::new)
    }
}

impl ::protobuf::Clear for LoadStatus {
    fn clear(&mut self) {
        self.statusValue.clear();
        self.loadStatusZGLD.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LoadStatusProfile {
    // message fields
    statusMessageInfo: ::protobuf::SingularPtrField<super::commonmodule::StatusMessageInfo>,
    energyConsumer: ::protobuf::SingularPtrField<super::commonmodule::EnergyConsumer>,
    ied: ::protobuf::SingularPtrField<super::commonmodule::IED>,
    loadStatus: ::protobuf::SingularPtrField<LoadStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadStatusProfile {
    fn default() -> &'a LoadStatusProfile {
        <LoadStatusProfile as ::protobuf::Message>::default_instance()
    }
}

impl LoadStatusProfile {
    pub fn new() -> LoadStatusProfile {
        ::std::default::Default::default()
    }

    // .commonmodule.StatusMessageInfo statusMessageInfo = 1;


    pub fn get_statusMessageInfo(&self) -> &super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.as_ref().unwrap_or_else(|| <super::commonmodule::StatusMessageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statusMessageInfo(&mut self) {
        self.statusMessageInfo.clear();
    }

    pub fn has_statusMessageInfo(&self) -> bool {
        self.statusMessageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusMessageInfo(&mut self, v: super::commonmodule::StatusMessageInfo) {
        self.statusMessageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusMessageInfo(&mut self) -> &mut super::commonmodule::StatusMessageInfo {
        if self.statusMessageInfo.is_none() {
            self.statusMessageInfo.set_default();
        }
        self.statusMessageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusMessageInfo(&mut self) -> super::commonmodule::StatusMessageInfo {
        self.statusMessageInfo.take().unwrap_or_else(|| super::commonmodule::StatusMessageInfo::new())
    }

    // .commonmodule.EnergyConsumer energyConsumer = 2;


    pub fn get_energyConsumer(&self) -> &super::commonmodule::EnergyConsumer {
        self.energyConsumer.as_ref().unwrap_or_else(|| <super::commonmodule::EnergyConsumer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_energyConsumer(&mut self) {
        self.energyConsumer.clear();
    }

    pub fn has_energyConsumer(&self) -> bool {
        self.energyConsumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energyConsumer(&mut self, v: super::commonmodule::EnergyConsumer) {
        self.energyConsumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_energyConsumer(&mut self) -> &mut super::commonmodule::EnergyConsumer {
        if self.energyConsumer.is_none() {
            self.energyConsumer.set_default();
        }
        self.energyConsumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_energyConsumer(&mut self) -> super::commonmodule::EnergyConsumer {
        self.energyConsumer.take().unwrap_or_else(|| super::commonmodule::EnergyConsumer::new())
    }

    // .commonmodule.IED ied = 3;


    pub fn get_ied(&self) -> &super::commonmodule::IED {
        self.ied.as_ref().unwrap_or_else(|| <super::commonmodule::IED as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ied(&mut self) {
        self.ied.clear();
    }

    pub fn has_ied(&self) -> bool {
        self.ied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ied(&mut self, v: super::commonmodule::IED) {
        self.ied = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ied(&mut self) -> &mut super::commonmodule::IED {
        if self.ied.is_none() {
            self.ied.set_default();
        }
        self.ied.as_mut().unwrap()
    }

    // Take field
    pub fn take_ied(&mut self) -> super::commonmodule::IED {
        self.ied.take().unwrap_or_else(|| super::commonmodule::IED::new())
    }

    // .loadmodule.LoadStatus loadStatus = 4;


    pub fn get_loadStatus(&self) -> &LoadStatus {
        self.loadStatus.as_ref().unwrap_or_else(|| <LoadStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadStatus(&mut self) {
        self.loadStatus.clear();
    }

    pub fn has_loadStatus(&self) -> bool {
        self.loadStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadStatus(&mut self, v: LoadStatus) {
        self.loadStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadStatus(&mut self) -> &mut LoadStatus {
        if self.loadStatus.is_none() {
            self.loadStatus.set_default();
        }
        self.loadStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadStatus(&mut self) -> LoadStatus {
        self.loadStatus.take().unwrap_or_else(|| LoadStatus::new())
    }
}

impl ::protobuf::Message for LoadStatusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.statusMessageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.energyConsumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ied {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.loadStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statusMessageInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.energyConsumer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ied)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ied.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loadStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statusMessageInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.energyConsumer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ied.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loadStatus.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadStatusProfile {
        LoadStatusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::StatusMessageInfo>>(
                "statusMessageInfo",
                |m: &LoadStatusProfile| { &m.statusMessageInfo },
                |m: &mut LoadStatusProfile| { &mut m.statusMessageInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::EnergyConsumer>>(
                "energyConsumer",
                |m: &LoadStatusProfile| { &m.energyConsumer },
                |m: &mut LoadStatusProfile| { &mut m.energyConsumer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::commonmodule::IED>>(
                "ied",
                |m: &LoadStatusProfile| { &m.ied },
                |m: &mut LoadStatusProfile| { &mut m.ied },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadStatus>>(
                "loadStatus",
                |m: &LoadStatusProfile| { &m.loadStatus },
                |m: &mut LoadStatusProfile| { &mut m.loadStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadStatusProfile>(
                "LoadStatusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadStatusProfile {
        static instance: ::protobuf::rt::LazyV2<LoadStatusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadStatusProfile::new)
    }
}

impl ::protobuf::Clear for LoadStatusProfile {
    fn clear(&mut self) {
        self.statusMessageInfo.clear();
        self.energyConsumer.clear();
        self.ied.clear();
        self.loadStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadStatusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadStatusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bloadmodule/loadmodule.proto\x12\nloadmodule\"\xa9\x03\n\tLoadPoint\
    \x126\n\trampRates\x18\x01\x20\x01(\x0b2\x16.commonmodule.RampRateR\tram\
    pRatesB\0\x12Z\n\x1areactivePwrSetPointEnabled\x18\x02\x20\x01(\x0b2\x18\
    .commonmodule.ControlDPCR\x1areactivePwrSetPointEnabledB\0\x12R\n\x16rea\
    lPwrSetPointEnabled\x18\x03\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\
    \x16realPwrSetPointEnabledB\0\x120\n\x05reset\x18\x04\x20\x01(\x0b2\x18.\
    commonmodule.ControlDPCR\x05resetB\0\x128\n\x05state\x18\x05\x20\x01(\
    \x0b2\x20.commonmodule.Optional_StateKindR\x05stateB\0\x12F\n\tstartTime\
    \x18\x06\x20\x01(\x0b2\x1e.commonmodule.ControlTimestampR\tstartTimeB\
    \x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"D\n\x07LoadCSG\x127\n\x06crvPts\
    \x18\x01\x20\x03(\x0b2\x15.loadmodule.LoadPointR\x06crvPtsB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"T\n\x17LoadControlScheduleFSCH\x127\n\x07Va\
    lDCSG\x18\x01\x20\x01(\x0b2\x13.loadmodule.LoadCSGR\x07ValDCSGB\x08\x90\
    \xb5\x18\x01\x88\xb5\x18\x01:\0\"\xb7\x01\n\x0fLoadControlFSCC\x12A\n\
    \x0bcontrolFSCC\x18\x01\x20\x01(\x0b2\x19.commonmodule.ControlFSCCR\x0bc\
    ontrolFSCCB\x04\x80\xb5\x18\x01\x12_\n\x17loadControlScheduleFSCH\x18\
    \x02\x20\x01(\x0b2#.loadmodule.LoadControlScheduleFSCHR\x17loadControlSc\
    heduleFSCHB\0:\0\"\xdd\x01\n\x0bLoadControl\x12D\n\x0ccontrolValue\x18\
    \x01\x20\x01(\x0b2\x1a.commonmodule.ControlValueR\x0ccontrolValueB\x04\
    \x80\xb5\x18\x01\x125\n\x05check\x18\x02\x20\x01(\x0b2\x1d.commonmodule.\
    CheckConditionsR\x05checkB\0\x12O\n\x0floadControlFSCC\x18\x03\x20\x01(\
    \x0b2\x1b.loadmodule.LoadControlFSCCR\x0floadControlFSCCB\x08\x88\xb5\
    \x18\x01\x90\xb5\x18\x01:\0\"\xb6\x02\n\x12LoadControlProfile\x12V\n\x12\
    controlMessageInfo\x18\x01\x20\x01(\x0b2\x20.commonmodule.ControlMessage\
    InfoR\x12controlMessageInfoB\x04\x80\xb5\x18\x01\x12N\n\x0eenergyConsume\
    r\x18\x02\x20\x01(\x0b2\x1c.commonmodule.EnergyConsumerR\x0eenergyConsum\
    erB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ied\x18\x03\x20\x01(\
    \x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\
    \x12C\n\x0bloadControl\x18\x04\x20\x01(\x0b2\x17.loadmodule.LoadControlR\
    \x0bloadControlB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01:\x04\xc0\xf3\x18\
    \x01\"\xe7\x02\n\x0fLoadPointStatus\x126\n\trampRates\x18\x01\x20\x01(\
    \x0b2\x16.commonmodule.RampRateR\trampRatesB\0\x12Z\n\x1areactivePwrSetP\
    ointEnabled\x18\x02\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x1areacti\
    vePwrSetPointEnabledB\0\x12R\n\x16realPwrSetPointEnabled\x18\x03\x20\x01\
    (\x0b2\x18.commonmodule.ControlDPCR\x16realPwrSetPointEnabledB\0\x120\n\
    \x05reset\x18\x04\x20\x01(\x0b2\x18.commonmodule.ControlDPCR\x05resetB\0\
    \x128\n\x05state\x18\x05\x20\x01(\x0b2\x20.commonmodule.Optional_StateKi\
    ndR\x05stateB\0:\0\"\xcd\x02\n\x16LoadEventAndStatusZGLD\x12t\n\x1clogic\
    alNodeForEventAndStatus\x18\x01\x20\x01(\x0b2*.commonmodule.LogicalNodeF\
    orEventAndStatusR\x1clogicalNodeForEventAndStatusB\x04\x80\xb5\x18\x01\
    \x12E\n\x0bDynamicTest\x18\x02\x20\x01(\x0b2!.commonmodule.ENS_DynamicTe\
    stKindR\x0bDynamicTestB\0\x123\n\x07EmgStop\x18\x03\x20\x01(\x0b2\x17.co\
    mmonmodule.StatusSPSR\x07EmgStopB\0\x12?\n\x0bPointStatus\x18\x04\x20\
    \x01(\x0b2\x1b.loadmodule.LoadPointStatusR\x0bPointStatusB\0:\0\"s\n\rLo\
    adEventZGLD\x12`\n\x16loadEventAndStatusZGLD\x18\x01\x20\x01(\x0b2\".loa\
    dmodule.LoadEventAndStatusZGLDR\x16loadEventAndStatusZGLDB\x04\x80\xb5\
    \x18\x01:\0\"\x98\x01\n\tLoadEvent\x12>\n\neventValue\x18\x01\x20\x01(\
    \x0b2\x18.commonmodule.EventValueR\neventValueB\x04\x80\xb5\x18\x01\x12I\
    \n\rloadEventZGLD\x18\x02\x20\x01(\x0b2\x19.loadmodule.LoadEventZGLDR\rl\
    oadEventZGLDB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xa8\x02\n\x10Load\
    EventProfile\x12P\n\x10eventMessageInfo\x18\x01\x20\x01(\x0b2\x1e.common\
    module.EventMessageInfoR\x10eventMessageInfoB\x04\x80\xb5\x18\x01\x12N\n\
    \x0eenergyConsumer\x18\x02\x20\x01(\x0b2\x1c.commonmodule.EnergyConsumer\
    R\x0eenergyConsumerB\x08\x90\xb5\x18\x01\x88\xb5\x18\x01\x12-\n\x03ied\
    \x18\x03\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x88\xb5\x18\x01\
    \x90\xb5\x18\x01\x12=\n\tloadEvent\x18\x04\x20\x01(\x0b2\x15.loadmodule.\
    LoadEventR\tloadEventB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\xf3\
    \x18\x01\"\xcf\x02\n\x0bLoadReading\x12\x86\x01\n\"conductingEquipmentTe\
    rminalReading\x18\x01\x20\x01(\x0b20.commonmodule.ConductingEquipmentTer\
    minalReadingR\"conductingEquipmentTerminalReadingB\x04\x80\xb5\x18\x01\
    \x127\n\tphaseMMTN\x18\x02\x20\x01(\x0b2\x17.commonmodule.PhaseMMTNR\tph\
    aseMMTNB\0\x12=\n\x0breadingMMTR\x18\x03\x20\x01(\x0b2\x19.commonmodule.\
    ReadingMMTRR\x0breadingMMTRB\0\x12=\n\x0breadingMMXU\x18\x04\x20\x01(\
    \x0b2\x19.commonmodule.ReadingMMXUR\x0breadingMMXUB\0:\0\"\xb6\x02\n\x12\
    LoadReadingProfile\x12V\n\x12readingMessageInfo\x18\x01\x20\x01(\x0b2\
    \x20.commonmodule.ReadingMessageInfoR\x12readingMessageInfoB\x04\x80\xb5\
    \x18\x01\x12N\n\x0eenergyConsumer\x18\x02\x20\x01(\x0b2\x1c.commonmodule\
    .EnergyConsumerR\x0eenergyConsumerB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\
    \x12-\n\x03ied\x18\x03\x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\
    \x88\xb5\x18\x01\x90\xb5\x18\x01\x12C\n\x0bloadReading\x18\x04\x20\x01(\
    \x0b2\x17.loadmodule.LoadReadingR\x0bloadReadingB\x08\x88\xb5\x18\x01\
    \x90\xb5\x18\x01:\x04\xc0\xf3\x18\x01\"t\n\x0eLoadStatusZGLD\x12`\n\x16l\
    oadEventAndStatusZGLD\x18\x01\x20\x01(\x0b2\".loadmodule.LoadEventAndSta\
    tusZGLDR\x16loadEventAndStatusZGLDB\x04\x80\xb5\x18\x01:\0\"\x9f\x01\n\n\
    LoadStatus\x12A\n\x0bstatusValue\x18\x01\x20\x01(\x0b2\x19.commonmodule.\
    StatusValueR\x0bstatusValueB\x04\x80\xb5\x18\x01\x12L\n\x0eloadStatusZGL\
    D\x18\x02\x20\x01(\x0b2\x1a.loadmodule.LoadStatusZGLDR\x0eloadStatusZGLD\
    B\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\0\"\xaf\x02\n\x11LoadStatusProfil\
    e\x12S\n\x11statusMessageInfo\x18\x01\x20\x01(\x0b2\x1f.commonmodule.Sta\
    tusMessageInfoR\x11statusMessageInfoB\x04\x80\xb5\x18\x01\x12N\n\x0eener\
    gyConsumer\x18\x02\x20\x01(\x0b2\x1c.commonmodule.EnergyConsumerR\x0eene\
    rgyConsumerB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01\x12-\n\x03ied\x18\x03\
    \x20\x01(\x0b2\x11.commonmodule.IEDR\x03iedB\x08\x90\xb5\x18\x01\x88\xb5\
    \x18\x01\x12@\n\nloadStatus\x18\x04\x20\x01(\x0b2\x16.loadmodule.LoadSta\
    tusR\nloadStatusB\x08\x88\xb5\x18\x01\x90\xb5\x18\x01:\x04\xc0\xf3\x18\
    \x01B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
